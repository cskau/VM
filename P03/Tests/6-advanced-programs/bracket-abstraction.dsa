(DAIMI-SchemeE03
  (19 5 1)
  ((1 lambda-deep%0)
   (1 lambda-deep%1)
   (2 lambda-deep%2)
   (1 lambda-deep%3)
   (2 lambda-deep%4)
   (1 lambda-deep%5)
   (1 lambda-deep%6)
   (2 lambda-deep%7)
   (2 lambda-deep%8)
   (-1 lambda-deep%9)
   (1 lambda-deep%10)
   (1 lambda-deep%11)
   (2 lambda-deep%12)
   (1 lambda-deep%13)
   (2 lambda-deep%14)
   (1 lambda-deep%15)
   (1 lambda-deep%16)
   (2 lambda-deep%17))
  ((new-vec 2)
   (load sym f vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym y vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load sym y vec 0)
   (load nil _ vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load sym f vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 2 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 0)
   (new-vec 2)
   (load sym f vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym g vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load sym g vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load sym f vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 2 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym y vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym y vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 2)
   (load close-deep 0 glo 3)
   (load close-deep 1 glo 4)
   (load close-deep 2 glo 5)
   (load close-deep 3 glo 6)
   (load close-deep 4 glo 7)
   (load close-deep 5 glo 8)
   (load close-deep 6 glo 9)
   (load close-deep 7 glo 10)
   (load close-deep 8 glo 11)
   (load close-deep 9 glo 12)
   (load close-deep 10 glo 13)
   (load close-deep 11 glo 14)
   (load close-deep 12 glo 15)
   (load close-deep 13 glo 16)
   (load close-deep 14 glo 17)
   (load close-deep 15 glo 18)
   (new-vec 1)
   (move glo 2 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move glo 1 vec 0)
   (call glo 18 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move glo 0 vec 0)
   (call glo 18 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 12)

   (label lambda-deep%0)
   (new-vec 2)
   (load sym Var vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%46)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%47)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Var vec 1)
   (tail-call lib 40)
   (label else%47)
   (load bool 0 res 0)
   (return)
   (label else%46)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%2)
   (new-vec 3)
   (load sym Lam vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%3)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%48)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%49)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Lam vec 1)
   (tail-call lib 40)
   (label else%49)
   (load bool 0 res 0)
   (return)
   (label else%48)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%4)
   (new-vec 3)
   (load sym App vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%5)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%50)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%51)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym App vec 1)
   (tail-call lib 40)
   (label else%51)
   (load bool 0 res 0)
   (return)
   (label else%50)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%6)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%52)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 3)
   (label else%52)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%53)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym lambda vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%54)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 9 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 10)
   (label else%54)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 9 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)
   (label else%53)
   (new-vec 1)
   (load sym parse vec 0)
   (tail-call lib 42)

   (label lambda-deep%7)
   (new-vec 1)
   (extend)
   (load close-deep 16 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%8)
   (new-vec 1)
   (extend)
   (load close-deep 17 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%9)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%10)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%55)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%55)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%56)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 12 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 13 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load sym lambda vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 12)
   (label else%56)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%57)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 13 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 12)
   (label else%57)
   (new-vec 1)
   (load sym unparse vec 0)
   (tail-call lib 42)

   (label lambda-deep%11)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%58)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 1 0 res 0)
   (return)
   (label else%58)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%59)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 15)
   (label else%59)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%60)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 7)
   (label else%60)
   (new-vec 1)
   (load sym ba vec 0)
   (tail-call lib 42)

   (label lambda-deep%12)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 17 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%61)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%62)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load sym I vec 0)
   (tail-call glo 3)
   (label else%62)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%63)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 15 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 15)
   (label else%63)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%64)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (load sym S vec 0)
   (call glo 3 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (call glo 15 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 7 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (call glo 15 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 7)
   (label else%64)
   (new-vec 1)
   (load sym ba-var vec 0)
   (tail-call lib 42)
   (label else%61)
   (new-vec 1)
   (load sym K vec 0)
   (call glo 3 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 7)

   (label lambda-deep%13)
   (jump-if-false 0 0 else%65)
   (load bool 0 res 0)
   (return)
   (label else%65)
   (load bool 1 res 0)
   (return)

   (label lambda-deep%14)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%66)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 40)
   (label else%66)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%67)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 16 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%68)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 17)
   (label else%68)
   (load bool 0 res 0)
   (return)
   (label else%67)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%69)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%70)
   (move 0 0 res 0)
   (return)
   (label else%70)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 1 1 vec 1)
   (tail-call glo 17)
   (label else%69)
   (new-vec 1)
   (load sym occurs? vec 0)
   (tail-call lib 42)

   (label lambda-deep%15)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 9 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 13)

   (label lambda-deep%16)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%71)
   (move 2 1 res 0)
   (return)
   (label else%71)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 5)

   (label lambda-deep%17)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%72)
   (move 0 0 res 0)
   (return)
   (label else%72)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 9 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 7 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0))
  "DAIMI-Scheme compiler, 03-10-22")
