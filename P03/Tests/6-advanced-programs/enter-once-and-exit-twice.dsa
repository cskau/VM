(DAIMI-SchemeE03
  (4 2 1)
  ((2 lambda-deep%0)
   (1 lambda-deep%1)
   (1 lambda-deep%2)
   (1 lambda-deep%3)
   (1 lambda-flat%4)
   (1 lambda-flat%5)
   (1 lambda-deep%6))
  ((load close-deep 0 glo 0)
   (load close-deep 1 glo 1)
   (load close-deep 2 glo 2)
   (load close-deep 3 glo 3)
   (new-vec 1)
   (move glo 3 vec 0)
   (call lib 41 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 49 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 2 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 4 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 41 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 50 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 2 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 5 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 41 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 51 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 2 0)
   (load sym ok? res 0)
   (return)

   (label lambda-deep%0)
   (new-vec 3)
   (load sym Stuff vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%10)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%11)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Stuff vec 1)
   (tail-call lib 40)
   (label else%11)
   (load bool 0 res 0)
   (return)
   (label else%10)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%2)
   (new-vec 2)
   (load char 10 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 54)

   (label lambda-deep%3)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 72 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 101 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 108 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 108 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 111 vec 0)
   (move tmp 0 vec 1)
   (call lib 54 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 2 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 41 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%12)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 6 tmp 0)
   (jump-if-false 0 0 else%13)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 119 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 111 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 114 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 108 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 100 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%13)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 65 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 97 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 114 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 104 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 117 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load char 115 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%12)
   (new-vec 1)
   (load int 1 vec 0)
   (tail-call lib 42)

   (label lambda-flat%4)
   (new-vec 2)
   (load bool 1 vec 0)
   (move 0 0 vec 1)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%5)
   (new-vec 2)
   (load bool 0 vec 0)
   (move 0 0 vec 1)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%6)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 2 0)
   (new-vec 1)
   (load sym done vec 0)
   (tail-call 1 1))
  "DAIMI-Scheme compiler, 03-10-22")
