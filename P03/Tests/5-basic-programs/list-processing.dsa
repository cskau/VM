(DAIMI-SchemeE03
  (14 4 1)
  ((-1 lambda-deep%0)
   (3 lambda-deep%1)
   (3 lambda-deep%2)
   (2 lambda-deep%3)
   (2 lambda-deep%4)
   (-1 lambda-deep%5)
   (1 lambda-deep%6)
   (1 lambda-deep%7)
   (1 lambda-deep%8)
   (2 lambda-deep%9)
   (2 lambda-flat%10))
  ((new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 0)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (new-vec 2)
   (load int 6 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 5 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 4 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 2)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 3)
   (new-vec 2)
   (load int 6 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 5 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 4 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 4)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 5)
   (load close-deep 0 glo 6)
   (load close-deep 1 glo 7)
   (load close-deep 2 glo 8)
   (load close-deep 3 glo 9)
   (load close-deep 4 glo 10)
   (load close-deep 5 glo 11)
   (load close-deep 6 glo 12)
   (load close-deep 7 glo 13)
   (new-vec 2)
   (move glo 5 vec 0)
   (move glo 4 vec 1)
   (call glo 10 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 3 vec 0)
   (move glo 2 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move glo 1 vec 0)
   (call glo 12 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move glo 0 vec 0)
   (call glo 13 3)
   (move res 0 tmp 3)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (tail-call glo 6)

   (label lambda-deep%0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%1)
   (new-vec 1)
   (extend)
   (load close-deep 8 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%2)
   (new-vec 1)
   (extend)
   (load close-deep 9 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%3)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%4)
   (new-vec 3)
   (move glo 9 vec 0)
   (move 0 1 vec 1)
   (move 0 0 vec 2)
   (tail-call glo 7)

   (label lambda-deep%5)
   (new-vec 3)
   (move glo 10 vec 0)
   (load nil _ vec 1)
   (move 0 0 vec 2)
   (tail-call glo 8)

   (label lambda-deep%6)
   (new-vec 3)
   (move glo 9 vec 0)
   (load nil _ vec 1)
   (move 0 0 vec 2)
   (tail-call glo 8)

   (label lambda-deep%7)
   (new-vec 0)
   (load close-flat 10 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (tail-call glo 8)

   (label lambda-deep%8)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%27)
   (move 2 1 res 0)
   (return)
   (label else%27)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%9)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%28)
   (move 0 1 res 0)
   (return)
   (label else%28)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%10)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 1))
  "DAIMI-Scheme compiler, 03-10-22")
