(DAIMI-SchemeE03
  (132 5 1)
  ((1 lambda-deep%0)
   (1 lambda-deep%1)
   (2 lambda-deep%2)
   (2 lambda-deep%3)
   (2 lambda-deep%4)
   (2 lambda-deep%5)
   (-1 lambda-deep%6)
   (1 lambda-deep%7)
   (1 lambda-deep%8)
   (1 lambda-deep%9)
   (2 lambda-deep%10)
   (-1 lambda-deep%11)
   (1 lambda-deep%12)
   (1 lambda-deep%13)
   (1 lambda-deep%14)
   (2 lambda-deep%15)
   (2 lambda-deep%16)
   (3 lambda-deep%17)
   (2 lambda-deep%18)
   (2 lambda-deep%19)
   (2 lambda-deep%20)
   (2 lambda-deep%21)
   (1 lambda-deep%22)
   (1 lambda-deep%23)
   (1 lambda-deep%24)
   (1 lambda-deep%25)
   (1 lambda-deep%26)
   (1 lambda-deep%27)
   (1 lambda-deep%28)
   (2 lambda-deep%29)
   (2 lambda-deep%30)
   (2 lambda-deep%31)
   (2 lambda-deep%32)
   (-1 lambda-deep%33)
   (-1 lambda-deep%34)
   (2 lambda-deep%35)
   (-1 lambda-deep%36)
   (3 lambda-deep%37)
   (3 lambda-deep%38)
   (3 lambda-deep%39)
   (3 lambda-deep%40)
   (-1 lambda-deep%41)
   (-1 lambda-deep%42)
   (3 lambda-deep%43)
   (2 lambda-deep%44)
   (3 lambda-deep%45)
   (2 lambda-deep%46)
   (1 lambda-deep%47)
   (1 lambda-deep%48)
   (1 lambda-deep%49)
   (1 lambda-deep%50)
   (1 lambda-deep%51)
   (1 lambda-deep%52)
   (1 lambda-deep%53)
   (2 lambda-deep%54)
   (1 lambda-deep%55)
   (2 lambda-deep%56)
   (2 lambda-deep%57)
   (2 lambda-deep%58)
   (1 lambda-deep%59)
   (1 lambda-deep%60)
   (2 lambda-deep%61)
   (3 lambda-deep%62)
   (2 lambda-deep%63)
   (1 lambda-deep%64)
   (1 lambda-deep%65)
   (1 lambda-deep%66)
   (1 lambda-deep%67)
   (1 lambda-deep%68)
   (1 lambda-deep%69)
   (1 lambda-deep%70)
   (-1 lambda-deep%71)
   (1 lambda-deep%72)
   (1 lambda-deep%73)
   (1 lambda-deep%74)
   (1 lambda-deep%75)
   (1 lambda-deep%76)
   (1 lambda-deep%77)
   (1 lambda-deep%78)
   (2 lambda-deep%79)
   (2 lambda-deep%80)
   (-1 lambda-deep%81)
   (3 lambda-deep%82)
   (3 lambda-deep%83)
   (3 lambda-deep%84)
   (3 lambda-deep%85)
   (3 lambda-deep%86)
   (3 lambda-deep%87)
   (3 lambda-deep%88)
   (2 lambda-deep%89)
   (2 lambda-deep%90)
   (3 lambda-deep%91)
   (-1 lambda-deep%92)
   (2 lambda-deep%93)
   (-1 lambda-deep%94)
   (2 lambda-deep%95)
   (-1 lambda-deep%96)
   (1 lambda-deep%97)
   (-1 lambda-deep%98)
   (3 lambda-deep%99)
   (2 lambda-deep%100)
   (2 lambda-deep%101)
   (1 lambda-deep%102)
   (1 lambda-deep%103)
   (1 lambda-deep%104)
   (3 lambda-flat%105)
   (1 lambda-flat%106)
   (2 lambda-flat%107)
   (1 lambda-deep%108)
   (1 lambda-flat%109)
   (2 lambda-deep%110)
   (3 lambda-deep%111)
   (1 lambda-deep%112)
   (2 lambda-deep%113)
   (2 lambda-deep%114)
   (2 lambda-deep%115)
   (2 lambda-deep%116)
   (2 lambda-deep%117)
   (1 lambda-deep%118)
   (1 lambda-deep%119)
   (1 lambda-flat%120)
   (1 lambda-deep%121)
   (1 lambda-deep%122)
   (1 lambda-deep%123)
   (1 lambda-deep%124)
   (1 lambda-deep%125)
   (1 lambda-deep%126)
   (1 lambda-deep%127)
   (1 lambda-deep%128)
   (1 lambda-deep%129)
   (2 lambda-deep%130)
   (1 lambda-deep%131)
   (2 lambda-deep%132)
   (1 lambda-deep%133)
   (2 lambda-deep%134)
   (1 lambda-deep%135)
   (1 lambda-flat%136)
   (1 lambda-flat%137)
   (1 lambda-deep%138)
   (2 lambda-deep%139)
   (1 lambda-deep%140)
   (1 lambda-deep%141)
   (1 lambda-deep%142)
   (2 lambda-deep%143)
   (2 lambda-deep%144)
   (1 lambda-deep%145)
   (1 lambda-deep%146)
   (2 lambda-deep%147)
   (1 lambda-deep%148)
   (1 lambda-deep%149)
   (1 lambda-deep%150)
   (2 lambda-deep%151)
   (1 lambda-deep%152)
   (1 lambda-deep%153)
   (0 lambda-deep%154)
   (0 lambda-deep%155)
   (1 lambda-flat%156)
   (1 lambda-flat%157)
   (1 lambda-flat%158)
   (1 lambda-deep%159)
   (1 lambda-flat%160)
   (1 lambda-flat%161)
   (1 lambda-deep%162)
   (1 lambda-deep%163)
   (1 lambda-deep%164)
   (1 lambda-flat%165)
   (1 lambda-deep%166)
   (1 lambda-flat%167)
   (1 lambda-flat%168)
   (1 lambda-deep%169)
   (-1 lambda-flat%170)
   (1 lambda-deep%171)
   (1 lambda-deep%172)
   (2 lambda-flat%173)
   (2 lambda-deep%174)
   (1 lambda-deep%175)
   (1 lambda-deep%176)
   (1 lambda-deep%177)
   (1 lambda-deep%178)
   (1 lambda-deep%179)
   (1 lambda-deep%180)
   (2 lambda-deep%181)
   (1 lambda-flat%182)
   (1 lambda-flat%183)
   (1 lambda-flat%184)
   (1 lambda-flat%185)
   (1 lambda-flat%186)
   (1 lambda-flat%187)
   (1 lambda-flat%188)
   (1 lambda-flat%189)
   (1 lambda-flat%190)
   (1 lambda-flat%191)
   (1 lambda-flat%192)
   (1 lambda-flat%193)
   (1 lambda-flat%194)
   (1 lambda-flat%195)
   (1 lambda-flat%196)
   (1 lambda-flat%197)
   (1 lambda-flat%198)
   (1 lambda-flat%199)
   (1 lambda-flat%200)
   (1 lambda-deep%201)
   (1 lambda-flat%202)
   (1 lambda-flat%203)
   (1 lambda-deep%204)
   (1 lambda-deep%205)
   (1 lambda-flat%206)
   (1 lambda-flat%207)
   (1 lambda-flat%208)
   (1 lambda-flat%209)
   (1 lambda-flat%210)
   (1 lambda-flat%211)
   (1 lambda-flat%212)
   (1 lambda-flat%213)
   (1 lambda-flat%214)
   (1 lambda-flat%215)
   (1 lambda-flat%216)
   (1 lambda-flat%217)
   (1 lambda-flat%218)
   (1 lambda-flat%219)
   (1 lambda-flat%220)
   (1 lambda-flat%221)
   (1 lambda-flat%222)
   (1 lambda-flat%223)
   (1 lambda-flat%224)
   (1 lambda-flat%225)
   (1 lambda-flat%226)
   (1 lambda-flat%227)
   (1 lambda-flat%228)
   (1 lambda-flat%229)
   (1 lambda-flat%230)
   (1 lambda-flat%231)
   (1 lambda-flat%232)
   (1 lambda-flat%233)
   (1 lambda-flat%234)
   (1 lambda-flat%235)
   (1 lambda-flat%236)
   (1 lambda-flat%237)
   (1 lambda-flat%238)
   (1 lambda-deep%239)
   (1 lambda-flat%240)
   (1 lambda-flat%241)
   (1 lambda-flat%242)
   (1 lambda-flat%243)
   (1 lambda-flat%244)
   (1 lambda-flat%245)
   (1 lambda-flat%246)
   (1 lambda-deep%247)
   (1 lambda-flat%248)
   (1 lambda-flat%249)
   (1 lambda-flat%250)
   (1 lambda-flat%251)
   (1 lambda-flat%252)
   (1 lambda-flat%253))
  ((load close-deep 0 glo 0)
   (new-vec 2)
   (load int 10 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 10 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 10 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (new-vec 2)
   (load int 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 3 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 2)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 3)
   (new-vec 2)
   (load int 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 3 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 4 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 4)
   (new-vec 2)
   (load int 4 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 3 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 5)
   (new-vec 2)
   (load int 9 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 8 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 7 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 6 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 5 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 4 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 3 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 6)
   (new-vec 2)
   (load int 9 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 8 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 7 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 6 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 5 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 4 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 3 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 7)
   (load close-deep 1 glo 8)
   (load close-deep 2 glo 9)
   (load close-deep 3 glo 10)
   (load close-deep 4 glo 11)
   (load close-deep 5 glo 12)
   (load close-deep 6 glo 13)
   (load close-deep 7 glo 14)
   (load close-deep 8 glo 15)
   (load close-deep 9 glo 16)
   (load close-deep 10 glo 17)
   (load close-deep 11 glo 18)
   (load close-deep 12 glo 19)
   (load close-deep 13 glo 20)
   (load close-deep 14 glo 21)
   (load close-deep 15 glo 22)
   (load close-deep 16 glo 23)
   (load close-deep 17 glo 24)
   (load close-deep 18 glo 25)
   (load close-deep 19 glo 26)
   (load close-deep 20 glo 27)
   (load close-deep 21 glo 28)
   (load close-deep 22 glo 29)
   (load close-deep 23 glo 30)
   (load close-deep 24 glo 31)
   (load close-deep 25 glo 32)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 29 vec 1)
   (call glo 9 0)
   (move res 0 glo 33)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 29 vec 1)
   (call glo 9 0)
   (move res 0 glo 34)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 31 vec 1)
   (call glo 9 0)
   (move res 0 glo 35)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 31 vec 1)
   (call glo 9 0)
   (move res 0 glo 36)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 30 vec 1)
   (call glo 9 0)
   (move res 0 glo 37)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 30 vec 1)
   (call glo 9 0)
   (move res 0 glo 38)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 32 vec 1)
   (call glo 9 0)
   (move res 0 glo 39)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 32 vec 1)
   (call glo 9 0)
   (move res 0 glo 40)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 40 vec 1)
   (call glo 9 0)
   (move res 0 glo 41)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 40 vec 1)
   (call glo 9 0)
   (move res 0 glo 42)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 42 vec 1)
   (call glo 9 0)
   (move res 0 glo 43)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 42 vec 1)
   (call glo 9 0)
   (move res 0 glo 44)
   (load close-deep 26 glo 45)
   (load close-deep 27 glo 46)
   (load close-deep 28 glo 47)
   (load close-deep 29 glo 48)
   (load close-deep 30 glo 49)
   (load close-deep 31 glo 50)
   (load close-deep 32 glo 51)
   (load close-deep 33 glo 52)
   (load close-deep 34 glo 53)
   (load close-deep 35 glo 54)
   (load close-deep 36 glo 55)
   (load close-deep 37 glo 56)
   (load close-deep 38 glo 57)
   (load close-deep 39 glo 58)
   (load close-deep 40 glo 59)
   (load close-deep 41 glo 60)
   (load close-deep 42 glo 61)
   (load close-deep 43 glo 62)
   (load close-deep 44 glo 63)
   (load close-deep 45 glo 64)
   (load close-deep 46 glo 65)
   (load close-deep 47 glo 66)
   (move glo 66 glo 67)
   (load close-deep 48 glo 68)
   (move glo 68 glo 69)
   (load close-deep 49 glo 70)
   (load close-deep 50 glo 71)
   (load close-deep 51 glo 72)
   (load close-deep 52 glo 73)
   (load close-deep 53 glo 74)
   (load close-deep 54 glo 75)
   (load close-deep 55 glo 76)
   (load close-deep 56 glo 77)
   (load close-deep 57 glo 78)
   (load close-deep 58 glo 79)
   (new-vec 1)
   (load int 9 vec 0)
   (call lib 15 0)
   (move res 0 glo 80)
   (new-vec 1)
   (load int 10 vec 0)
   (call lib 15 0)
   (move res 0 glo 81)
   (new-vec 1)
   (load int 32 vec 0)
   (call lib 15 0)
   (move res 0 glo 82)
   (load close-deep 59 glo 83)
   (load close-deep 60 glo 84)
   (load close-deep 61 glo 85)
   (load close-deep 62 glo 86)
   (load close-deep 63 glo 87)
   (load close-deep 64 glo 88)
   (load close-deep 65 glo 89)
   (load close-deep 66 glo 90)
   (load close-deep 67 glo 91)
   (load close-deep 68 glo 92)
   (load close-deep 69 glo 93)
   (load close-deep 70 glo 94)
   (load close-deep 71 glo 95)
   (load close-deep 72 glo 96)
   (load close-deep 73 glo 97)
   (load close-deep 74 glo 98)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load char 57 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 75 glo 99)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 76 glo 100)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 77 glo 101)
   (load close-deep 78 glo 102)
   (load close-deep 79 glo 103)
   (load close-deep 80 glo 104)
   (load close-deep 81 glo 105)
   (load close-deep 82 glo 106)
   (load close-deep 83 glo 107)
   (load close-deep 84 glo 108)
   (load close-deep 85 glo 109)
   (load close-deep 86 glo 110)
   (load close-deep 87 glo 111)
   (load close-deep 88 glo 112)
   (load close-deep 89 glo 113)
   (load close-deep 90 glo 114)
   (load close-deep 91 glo 115)
   (load close-deep 92 glo 116)
   (load close-deep 93 glo 117)
   (load close-deep 94 glo 118)
   (load close-deep 95 glo 119)
   (load close-deep 96 glo 120)
   (load close-deep 97 glo 121)
   (load close-deep 98 glo 122)
   (load close-deep 99 glo 123)
   (load close-deep 100 glo 124)
   (move lib 41 glo 125)
   (load close-deep 101 glo 126)
   (load close-deep 102 glo 127)
   (load close-deep 103 glo 128)
   (new-vec 1)
   (move lib 40 vec 0)
   (call glo 128 0)
   (move res 0 glo 129)
   (new-vec 1)
   (move glo 11 vec 0)
   (call glo 128 0)
   (move res 0 glo 130)
   (load close-deep 104 glo 67)
   (new-vec 2)
   (move glo 67 vec 0)
   (move glo 7 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 67 vec 0)
   (move glo 6 vec 1)
   (call glo 52 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move lib 1 vec 0)
   (move glo 5 vec 1)
   (move glo 4 vec 2)
   (call glo 52 2)
   (move res 0 tmp 2)
   (new-vec 0)
   (load close-flat 105 tmp 3)
   (new-vec 4)
   (move tmp 3 vec 0)
   (move glo 3 vec 1)
   (move glo 2 vec 2)
   (move glo 1 vec 3)
   (call glo 52 3)
   (move res 0 tmp 3)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (tail-call glo 13)

   (label lambda-deep%0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%1)
   (jump-if-false 0 0 else%462)
   (load bool 0 res 0)
   (return)
   (label else%462)
   (load bool 1 res 0)
   (return)

   (label lambda-deep%2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 106 res 0)
   (return)

   (label lambda-deep%3)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 107 res 0)
   (return)

   (label lambda-deep%4)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%463)
   (load bool 1 res 0)
   (return)
   (label else%463)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%464)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%465)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 21)
   (label else%465)
   (load bool 0 res 0)
   (return)
   (label else%464)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%466)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%467)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%468)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%469)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)
   (label else%469)
   (load bool 0 res 0)
   (return)
   (label else%468)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%470)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)
   (label else%470)
   (load bool 0 res 0)
   (return)
   (label else%467)
   (load bool 0 res 0)
   (return)
   (label else%466)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%471)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%472)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%473)
   (new-vec 1)
   (extend)
   (load close-deep 108 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%473)
   (load bool 0 res 0)
   (return)
   (label else%472)
   (load bool 0 res 0)
   (return)
   (label else%471)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%5)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 109 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 41)

   (label lambda-deep%6)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%7)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%474)
   (move 0 0 res 0)
   (return)
   (label else%474)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%8)
   (new-vec 1)
   (extend)
   (load close-deep 110 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%475)
   (move 0 0 res 0)
   (return)
   (label else%475)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%476)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%476)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%9)
   (new-vec 1)
   (extend)
   (load close-deep 111 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 0 vec 1)
   (load int 1 vec 2)
   (tail-call 1 0)

   (label lambda-deep%10)
   (new-vec 1)
   (extend)
   (load close-deep 112 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%11)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%477)
   (load nil _ res 0)
   (return)
   (label else%477)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%478)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 27)
   (label else%478)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%479)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 17)
   (label else%479)
   (new-vec 3)
   (move glo 17 vec 0)
   (load nil _ vec 1)
   (move 1 0 vec 2)
   (tail-call glo 56)

   (label lambda-deep%12)
   (new-vec 3)
   (move lib 26 vec 0)
   (load nil _ vec 1)
   (move 0 0 vec 2)
   (tail-call glo 57)

   (label lambda-deep%13)
   (new-vec 1)
   (extend)
   (load close-deep 113 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%14)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%480)
   (new-vec 1)
   (extend)
   (load close-deep 114 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 0 0)
   (label else%480)
   (new-vec 3)
   (load sym last-pair vec 0)
   (load str "not a non-empty list: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%15)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%481)
   (new-vec 3)
   (load sym list-ref vec 0)
   (load str "negative offset: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 122)
   (label else%481)
   (new-vec 1)
   (extend)
   (load close-deep 115 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%16)
   (new-vec 1)
   (extend)
   (load close-deep 116 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%17)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%482)
   (new-vec 3)
   (load sym list-set! vec 0)
   (load str "negative offset: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 122)
   (label else%482)
   (new-vec 1)
   (extend)
   (load close-deep 117 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%18)
   (new-vec 1)
   (extend)
   (load close-deep 118 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%19)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%20)
   (new-vec 1)
   (extend)
   (load close-deep 119 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%21)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%22)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%23)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%24)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%25)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%26)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 120 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 50)

   (label lambda-deep%27)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 48)

   (label lambda-deep%28)
   (new-vec 2)
   (move lib 28 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 48)

   (label lambda-deep%29)
   (new-vec 1)
   (extend)
   (load close-deep 121 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%30)
   (new-vec 1)
   (extend)
   (load close-deep 122 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%31)
   (new-vec 1)
   (extend)
   (load close-deep 123 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%32)
   (new-vec 1)
   (extend)
   (load close-deep 124 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%33)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%483)
   (new-vec 2)
   (load sym map vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 122)
   (label else%483)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%484)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 48)
   (label else%484)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%485)
   (new-vec 1)
   (extend)
   (load close-deep 125 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%485)
   (new-vec 2)
   (load sym map vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 122)

   (label lambda-deep%34)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%486)
   (new-vec 2)
   (load sym map-append vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 122)
   (label else%486)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%487)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 49)
   (label else%487)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%488)
   (new-vec 1)
   (extend)
   (load close-deep 126 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%488)
   (new-vec 2)
   (load sym map-append vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 122)

   (label lambda-deep%35)
   (new-vec 1)
   (extend)
   (load close-deep 127 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%36)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%489)
   (new-vec 2)
   (load sym for-each vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 122)
   (label else%489)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%490)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 54)
   (label else%490)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%491)
   (new-vec 1)
   (extend)
   (load close-deep 128 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%491)
   (new-vec 2)
   (load sym for-each vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 122)

   (label lambda-deep%37)
   (new-vec 1)
   (extend)
   (load close-deep 129 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%38)
   (new-vec 1)
   (extend)
   (load close-deep 130 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%39)
   (new-vec 1)
   (extend)
   (load close-deep 131 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%40)
   (new-vec 1)
   (extend)
   (load close-deep 132 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%41)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%492)
   (new-vec 2)
   (load sym right-fold vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 122)
   (label else%492)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 32 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%493)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 58)
   (label else%493)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%494)
   (new-vec 1)
   (extend)
   (load close-deep 133 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)
   (label else%494)
   (new-vec 2)
   (load sym variadic-right-fold vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 122)

   (label lambda-deep%42)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%495)
   (new-vec 2)
   (load sym left-fold vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 122)
   (label else%495)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 32 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%496)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 59)
   (label else%496)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%497)
   (new-vec 1)
   (extend)
   (load close-deep 134 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)
   (label else%497)
   (new-vec 2)
   (load sym variadic-left-fold vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 122)

   (label lambda-deep%43)
   (new-vec 1)
   (extend)
   (load close-deep 135 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%44)
   (new-vec 0)
   (load close-flat 136 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 62)

   (label lambda-deep%45)
   (new-vec 2)
   (move glo 8 vec 0)
   (move 0 0 vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 62)

   (label lambda-deep%46)
   (new-vec 0)
   (load close-flat 137 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 64)

   (label lambda-deep%47)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 1)

   (label lambda-deep%48)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 2)

   (label lambda-deep%49)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 6)

   (label lambda-deep%50)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%51)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 10)

   (label lambda-deep%52)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%53)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 8)

   (label lambda-deep%54)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 70 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%498)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 70 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%499)
   (move 0 0 res 0)
   (return)
   (label else%499)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 1)
   (label else%498)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 70 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%500)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 1)
   (label else%500)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%55)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%501)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 2)
   (label else%501)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%56)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%502)
   (move 0 0 res 0)
   (return)
   (label else%502)
   (move 0 1 res 0)
   (return)

   (label lambda-deep%57)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%503)
   (move 0 1 res 0)
   (return)
   (label else%503)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%58)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 8)

   (label lambda-deep%59)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%504)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 32 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%505)
   (load bool 1 res 0)
   (return)
   (label else%505)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 10 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%506)
   (load bool 1 res 0)
   (return)
   (label else%506)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 9 vec 1)
   (tail-call lib 8)
   (label else%504)
   (new-vec 3)
   (load sym char:whitespace? vec 0)
   (load str "not a char: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%60)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 83 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%507)
   (load bool 1 res 0)
   (return)
   (label else%507)
   (load close-deep 138 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 40 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%508)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%508)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%509)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%509)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 91 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%510)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%510)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%511)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%511)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 39 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%512)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%512)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 96 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%513)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%513)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 44 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%514)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%514)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 59 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%61)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 139 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%62)
   (new-vec 1)
   (extend)
   (load close-deep 140 0 0)
   (load close-deep 141 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 1 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%515)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%516)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 2 vec 0)
   (move tmp 1 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%516)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%515)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%63)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%517)
   (new-vec 3)
   (load sym string-suffix? vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)
   (label else%517)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%518)
   (new-vec 3)
   (load sym string-suffix? vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 122)
   (label else%518)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%519)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (call glo 86 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 21)
   (label else%519)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%64)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%520)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 142 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%520)
   (new-vec 3)
   (load sym string->list vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%65)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 88 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 34 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 34 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%66)
   (new-vec 1)
   (extend)
   (load close-deep 143 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 70 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%521)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 45 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%521)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (tail-call 0 0)

   (label lambda-deep%67)
   (new-vec 1)
   (extend)
   (load close-deep 144 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%522)
   (new-vec 2)
   (load char 40 vec 0)
   (load char 41 vec 1)
   (tail-call glo 13)
   (label else%522)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%523)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 40 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%523)
   (new-vec 3)
   (load sym list-of-values->list-of-chars vec 0)
   (load str "not a list: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%68)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 90 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (extend)
   (load close-deep 145 0 0)
   (load close-deep 146 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%524)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%524)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 93 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 1 vec 0)
   (call 0 0 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 18 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%69)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 14 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%525)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 91)
   (label else%525)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%526)
   (jump-if-false 0 0 else%527)
   (new-vec 1)
   (load str "#t" vec 0)
   (tail-call glo 88)
   (label else%527)
   (new-vec 1)
   (load str "#f" vec 0)
   (tail-call glo 88)
   (label else%526)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%528)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 90)
   (label else%528)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%529)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)
   (label else%529)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%530)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 89)
   (label else%530)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%531)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 88)
   (label else%531)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%532)
   (new-vec 1)
   (load str "#<procedure>" vec 0)
   (tail-call glo 88)
   (label else%532)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%533)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 92)
   (label else%533)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 44 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%534)
   (new-vec 1)
   (load str "#<input-port>" vec 0)
   (tail-call glo 88)
   (label else%534)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 51 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%535)
   (new-vec 1)
   (load str "#<output-port>" vec 0)
   (tail-call glo 88)
   (label else%535)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%536)
   (new-vec 1)
   (load str "#<eof-object>" vec 0)
   (tail-call glo 88)
   (label else%536)
   (new-vec 3)
   (load sym value->list-of-chars vec 0)
   (load str "unrecognized value: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%70)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%71)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%537)
   (load str "" res 0)
   (return)
   (label else%537)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%538)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (extend)
   (load close-deep 147 0 0)
   (load close-deep 148 0 1)
   (load close-deep 149 0 2)
   (new-vec 2)
   (load int 0 vec 0)
   (move 2 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)
   (label else%538)
   (new-vec 3)
   (load sym format vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%72)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 150 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%73)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 151 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 3 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%74)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 90 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%75)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%539)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%540)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 7)
   (label else%540)
   (load bool 0 res 0)
   (return)
   (label else%539)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%76)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 99 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%541)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 2)
   (label else%541)
   (new-vec 3)
   (load sym digit->integer vec 0)
   (load str "not a digit: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%77)
   (load close-deep 152 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%542)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 9 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%542)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%78)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%543)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 153 tmp 0)
   (jump-if-false 0 0 else%544)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%544)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load char 45 vec 1)
   (call glo 79 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%545)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%545)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%543)
   (new-vec 3)
   (load sym string->integer vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%79)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 43 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 45 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%80)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 52 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%81)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%546)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 10 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 54)
   (label else%546)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%547)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 51 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%548)
   (new-vec 2)
   (load char 10 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 54)
   (label else%548)
   (new-vec 3)
   (load sym newline vec 0)
   (load str "not a port: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)
   (label else%547)
   (new-vec 3)
   (load sym newline vec 0)
   (load str "Too many arguments: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%82)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%549)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 2)
   (label else%549)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%83)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%550)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 2)
   (label else%550)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%84)
   (new-vec 1)
   (extend)
   (load close-deep 154 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%85)
   (new-vec 1)
   (extend)
   (load close-deep 155 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%86)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 156 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 109)

   (label lambda-deep%87)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (load close-flat 157 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 2 vec 1)
   (load close-flat 158 tmp 1)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)

   (label lambda-deep%88)
   (new-vec 1)
   (extend)
   (load close-deep 159 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%89)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 160 tmp 0)
   (new-vec 0)
   (load close-flat 161 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)

   (label lambda-deep%90)
   (new-vec 1)
   (extend)
   (load close-deep 162 0 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 0 0)

   (label lambda-deep%91)
   (new-vec 2)
   (extend)
   (load close-deep 163 0 0)
   (load close-deep 164 0 1)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (move 1 0 vec 3)
   (load close-flat 165 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 1 2 vec 2)
   (tail-call glo 110)

   (label lambda-deep%92)
   (load close-deep 166 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%551)
   (new-vec 0)
   (call lib 46 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%551)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%93)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 167 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 93 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 55)

   (label lambda-deep%94)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%552)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 117)
   (label else%552)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%553)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 117)
   (label else%553)
   (new-vec 3)
   (load sym write vec 0)
   (load str "wrong arity: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%95)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 168 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 93 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 55)

   (label lambda-deep%96)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%554)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 119)
   (label else%554)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%555)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 119)
   (label else%555)
   (new-vec 3)
   (load sym display vec 0)
   (load str "wrong arity: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%97)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%556)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 169 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%556)
   (new-vec 3)
   (load sym extract-directory-name vec 0)
   (load str "not a file name: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%98)
   (new-vec 0)
   (load close-flat 170 tmp 0)
   (move tmp 0 glo 122)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 105 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "DAIMI-Scheme error -- " vec 0)
   (move tmp 0 vec 1)
   (call glo 120 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%557)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 105 0)
   (new-vec 1)
   (load int 1 vec 0)
   (tail-call lib 42)
   (label else%557)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 171 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%558)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%558)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%99)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%559)
   (move 0 2 res 0)
   (return)
   (label else%559)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%560)
   (move 0 1 res 0)
   (return)
   (label else%560)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%561)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (move 0 2 vec 2)
   (call glo 123 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%561)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 1 vec 2)
   (call glo 123 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%100)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 172 tmp 0)
   (jump-if-false 0 0 else%562)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%562)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%101)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%102)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%103)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 173 res 0)
   (return)

   (label lambda-deep%104)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 1)

   (label lambda-flat%105)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 2 vec 1)
   (call lib 3 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 3)

   (label lambda-flat%106)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%107)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%108)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%563)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)
   (label else%563)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%564)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%564)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%109)
   (new-vec 1)
   (extend)
   (load close-deep 174 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%110)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%565)
   (move 0 0 res 0)
   (return)
   (label else%565)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%566)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%567)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%568)
   (move 0 0 res 0)
   (return)
   (label else%568)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%569)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%569)
   (load bool 0 res 0)
   (return)
   (label else%567)
   (load bool 0 res 0)
   (return)
   (label else%566)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%111)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 2 0 vec 1)
   (call lib 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%570)
   (move 0 0 res 0)
   (return)
   (label else%570)
   (new-vec 1)
   (extend)
   (load close-deep 175 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 15 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%571)
   (new-vec 3)
   (load sym test-proper-list? vec 0)
   (load str "length ~s, cycle 0" vec 1)
   (move 2 2 vec 2)
   (tail-call glo 122)
   (label else%571)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%112)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%572)
   (move 2 1 res 0)
   (return)
   (label else%572)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%113)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%573)
   (move 0 1 res 0)
   (return)
   (label else%573)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%114)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%574)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%574)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%115)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%575)
   (new-vec 4)
   (load sym list-ref vec 0)
   (load str "offset ~s is out of range for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 122)
   (label else%575)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%576)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call lib 27)
   (label else%576)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%116)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%577)
   (new-vec 4)
   (load sym ref-list vec 0)
   (load str "~s is not in ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 122)
   (label else%577)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%578)
   (move 0 1 res 0)
   (return)
   (label else%578)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%117)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%579)
   (new-vec 4)
   (load sym list-set! vec 0)
   (load str "offset ~s is out of range for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 122)
   (label else%579)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%580)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 3 2 vec 1)
   (call lib 29 0)
   (move 0 0 res 0)
   (return)
   (label else%580)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%118)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%581)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%582)
   (move 0 0 res 0)
   (return)
   (label else%582)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%581)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%119)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%583)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%584)
   (move 0 0 res 0)
   (return)
   (label else%584)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%583)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%120)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%121)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%585)
   (load nil _ res 0)
   (return)
   (label else%585)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%122)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%586)
   (load nil _ res 0)
   (return)
   (label else%586)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 18)

   (label lambda-deep%123)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%587)
   (load bool 1 res 0)
   (return)
   (label else%587)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%588)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%588)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%124)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%589)
   (load bool 0 res 0)
   (return)
   (label else%589)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%590)
   (move 0 0 res 0)
   (return)
   (label else%590)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%125)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%591)
   (load nil _ res 0)
   (return)
   (label else%591)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 47 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%126)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%592)
   (load nil _ res 0)
   (return)
   (label else%592)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 47 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 18)

   (label lambda-deep%127)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%593)
   (load nil _ res 0)
   (return)
   (label else%593)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%128)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%594)
   (load nil _ res 0)
   (return)
   (label else%594)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%129)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%595)
   (move 2 1 res 0)
   (return)
   (label else%595)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%130)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%596)
   (move 0 1 res 0)
   (return)
   (label else%596)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%131)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%597)
   (move 2 1 res 0)
   (return)
   (label else%597)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%132)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%598)
   (move 0 1 res 0)
   (return)
   (label else%598)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%133)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%599)
   (move 2 1 res 0)
   (return)
   (label else%599)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 46 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%134)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%600)
   (move 0 1 res 0)
   (return)
   (label else%600)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 46 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 39 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%135)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%601)
   (load nil _ res 0)
   (return)
   (label else%601)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%602)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%602)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%136)
   (move 0 0 res 0)
   (return)

   (label lambda-flat%137)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%138)
   (jump-if-false 0 0 else%603)
   (load bool 1 res 0)
   (return)
   (label else%603)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%139)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 2 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%604)
   (load bool 0 res 0)
   (return)
   (label else%604)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%605)
   (load bool 1 res 0)
   (return)
   (label else%605)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 1 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%606)
   (load bool 1 res 0)
   (return)
   (label else%606)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 10 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%607)
   (load bool 0 res 0)
   (return)
   (label else%607)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%140)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%608)
   (load nil _ res 0)
   (return)
   (label else%608)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%141)
   (jump-if-false 0 0 else%609)
   (new-vec 1)
   (move 2 1 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)
   (label else%609)
   (new-vec 5)
   (load sym substring vec 0)
   (load str "~s and ~s are not valid start/end indices for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 2 vec 3)
   (move 2 0 vec 4)
   (tail-call glo 122)

   (label lambda-deep%142)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%610)
   (load nil _ res 0)
   (return)
   (label else%610)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%611)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%611)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%143)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 10 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "0123456789" vec 0)
   (move tmp 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 10 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%612)
   (move 0 0 res 0)
   (return)
   (label else%612)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 10 vec 1)
   (call lib 4 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 2 0)

   (label lambda-deep%144)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (load close-deep 176 tmp 1)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%613)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%613)
   (load close-deep 177 tmp 2)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%614)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call 1 0 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%614)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 93 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 18 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move glo 82 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load char 46 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)

   (label lambda-deep%145)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%615)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)
   (label else%615)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 82 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%146)
   (new-vec 2)
   (load char 40 vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 35 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%147)
   (new-vec 3)
   (extend)
   (load close-deep 178 0 0)
   (load close-deep 179 0 1)
   (load close-deep 180 0 2)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%616)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 2 1)
   (label else%616)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%148)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%617)
   (load nil _ res 0)
   (return)
   (label else%617)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 126 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%618)
   (new-vec 3)
   (load sym format vec 0)
   (load str "too many arguments for ~s" vec 1)
   (move 4 0 vec 2)
   (tail-call glo 122)
   (label else%618)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%619)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 2)
   (label else%619)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%149)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%620)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 122)
   (label else%620)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%150)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%621)
   (load nil _ res 0)
   (return)
   (label else%621)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%151)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%622)
   (move 2 0 res 0)
   (return)
   (label else%622)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%152)
   (jump-if-false 0 0 else%623)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 0 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 15)
   (label else%623)
   (new-vec 3)
   (load sym integer->digit vec 0)
   (load str "non-digitable integer: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%153)
   (jump-if-false 0 0 else%624)
   (new-vec 3)
   (load sym string->integer vec 0)
   (load str "invalid string: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 122)
   (label else%624)
   (new-vec 1)
   (extend)
   (load close-deep 181 0 0)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 45 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%625)
   (new-vec 2)
   (load int 1 vec 0)
   (load int 0 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 2)
   (label else%625)
   (new-vec 2)
   (load int 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%154)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 1 0 vec 1)
   (load close-flat 182 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 106)

   (label lambda-deep%155)
   (new-vec 4)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (move 2 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 183 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 107)

   (label lambda-flat%156)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%157)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 99 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%626)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (load int 10 vec 0)
   (move 1 1 vec 1)
   (call lib 3 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 100 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 111)
   (label else%626)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%627)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 1 0)
   (label else%627)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 184 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 112)

   (label lambda-flat%158)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%159)
   (new-vec 4)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 185 tmp 0)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 186 tmp 1)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)

   (label lambda-flat%160)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 110 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%628)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%629)
   (new-vec 1)
   (load char 110 vec 0)
   (tail-call 2 1)
   (label else%629)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%630)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 187 tmp 0)
   (new-vec 0)
   (load close-flat 188 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%630)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\n~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)
   (label else%628)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 115 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%631)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%632)
   (new-vec 1)
   (load char 115 vec 0)
   (tail-call 2 1)
   (label else%632)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 112 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%633)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 189 tmp 0)
   (new-vec 0)
   (load close-flat 190 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%633)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\s~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)
   (label else%631)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 116 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%634)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%635)
   (new-vec 1)
   (load char 116 vec 0)
   (tail-call 2 1)
   (label else%635)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 97 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%636)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 191 tmp 0)
   (new-vec 0)
   (load close-flat 192 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%636)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\t~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)
   (label else%634)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 193 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 194 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)

   (label lambda-flat%161)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-deep%162)
   (new-vec 4)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (move 1 0 vec 2)
   (move 0 0 vec 3)
   (load close-flat 195 tmp 0)
   (new-vec 0)
   (load close-flat 196 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)

   (label lambda-deep%163)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (load close-flat 197 tmp 0)
   (new-vec 0)
   (load close-flat 198 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 109)

   (label lambda-deep%164)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 199 tmp 0)
   (new-vec 0)
   (load close-flat 200 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 109)

   (label lambda-flat%165)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 40 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%637)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 1 0)
   (label else%637)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 91 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%638)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 1 1)
   (label else%638)
   (load close-deep 201 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%639)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%639)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%166)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 202 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 41)

   (label lambda-flat%167)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 54)

   (label lambda-flat%168)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 34 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%640)
   (load nil _ res 0)
   (return)
   (label else%640)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 54)

   (label lambda-deep%169)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 70 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%641)
   (load str "" res 0)
   (return)
   (label else%641)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 47 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%642)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 86)
   (label else%642)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%170)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 105 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "DAIMI-Scheme: error in error." vec 0)
   (move tmp 0 vec 1)
   (call glo 120 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 105 0)
   (new-vec 1)
   (load int 3 vec 0)
   (tail-call lib 42)

   (label lambda-deep%171)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 120 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str " -- " vec 0)
   (move tmp 0 vec 1)
   (call glo 120 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 95 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 120 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 105 0)
   (new-vec 1)
   (load int 2 vec 0)
   (tail-call lib 42)

   (label lambda-deep%172)
   (jump-if-false 0 0 else%643)
   (move 2 1 res 0)
   (return)
   (label else%643)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (load close-flat 203 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 63 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 124 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 65 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 124 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (call glo 123 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 4 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 123)

   (label lambda-flat%173)
   (new-vec 1)
   (extend)
   (load close-deep 204 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%174)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%644)
   (load bool 1 res 0)
   (return)
   (label else%644)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%645)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%646)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%647)
   (load bool 1 res 0)
   (return)
   (label else%647)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%646)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%645)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%648)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%649)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%650)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%651)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%651)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%650)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%652)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%652)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 1 0 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%649)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%648)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%653)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%654)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%655)
   (new-vec 1)
   (extend)
   (load close-deep 205 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%655)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 3 0)
   (label else%654)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%653)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%175)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%656)
   (new-vec 2)
   (move 3 2 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 2 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 3 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call 4 0)
   (label else%656)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call glo 15 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%657)
   (new-vec 4)
   (load sym test-proper-list? vec 0)
   (load str "length ~s, cycle ~s" vec 1)
   (move 3 2 vec 2)
   (move 0 0 vec 3)
   (tail-call glo 122)
   (label else%657)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%176)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 18)

   (label lambda-deep%177)
   (new-vec 2)
   (move glo 82 vec 0)
   (move 0 0 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%178)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%658)
   (load nil _ res 0)
   (return)
   (label else%658)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 126 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%659)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 1)
   (label else%659)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%660)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 2)
   (label else%660)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%179)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%661)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 5 0 vec 2)
   (tail-call glo 122)
   (label else%661)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 115 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%662)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%663)
   (new-vec 3)
   (load sym format vec 0)
   (load str "too few arguments for ~s" vec 1)
   (move 6 0 vec 2)
   (tail-call glo 122)
   (label else%663)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 4 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 18)
   (label else%662)
   (new-vec 3)
   (load sym format vec 0)
   (load str "illegal control character: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-deep%180)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%664)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 5 0 vec 2)
   (tail-call glo 122)
   (label else%664)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%181)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%665)
   (move 0 1 res 0)
   (return)
   (label else%665)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 100 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load int 10 vec 0)
   (move 0 1 vec 1)
   (call lib 3 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%182)
   (new-vec 2)
   (move 0 0 vec 0)
   (move glo 81 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%666)
   (new-vec 0)
   (tail-call 1 0)
   (label else%666)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-flat%183)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 83 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%667)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (new-vec 0)
   (tail-call 1 1)
   (label else%667)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 59 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%668)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 108)
   (label else%668)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 3)

   (label lambda-flat%184)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 98 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%185)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%669)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%669)
   (new-vec 1)
   (move 1 3 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%186)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%187)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 119 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%670)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 206 tmp 0)
   (new-vec 0)
   (load close-flat 207 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%670)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\ne~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%188)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\ne" vec 1)
   (tail-call glo 122)

   (label lambda-flat%189)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 97 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%671)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 208 tmp 0)
   (new-vec 0)
   (load close-flat 209 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%671)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\sp~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%190)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\sp" vec 1)
   (tail-call glo 122)

   (label lambda-flat%191)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 98 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%672)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 210 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 211 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)
   (label else%672)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\ta~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%192)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\ta" vec 1)
   (tail-call glo 122)

   (label lambda-flat%193)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%673)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 1 0)
   (label else%673)
   (new-vec 4)
   (load sym read vec 0)
   (load str "Invalid character name #\\~s~s" vec 1)
   (move 1 1 vec 2)
   (move 0 0 vec 3)
   (tail-call glo 122)

   (label lambda-flat%194)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%195)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 34 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%674)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%674)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%675)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 3 vec 1)
   (load close-flat 212 tmp 0)
   (new-vec 0)
   (load close-flat 213 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%675)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 3 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 2)

   (label lambda-flat%196)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%197)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%676)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 1 2)
   (label else%676)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (load close-flat 214 tmp 0)
   (new-vec 0)
   (load close-flat 215 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 115)

   (label lambda-flat%198)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%199)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%677)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 1 2)
   (label else%677)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (load close-flat 216 tmp 0)
   (new-vec 0)
   (load close-flat 217 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 115)

   (label lambda-flat%200)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-deep%201)
   (jump-if-false 0 0 else%678)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unexpected ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 122)
   (label else%678)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 39 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%679)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 218 tmp 0)
   (new-vec 0)
   (load close-flat 219 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 115)
   (label else%679)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 96 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%680)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 220 tmp 0)
   (new-vec 0)
   (load close-flat 221 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 115)
   (label else%680)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 44 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%681)
   (new-vec 1)
   (move 2 3 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 64 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%682)
   (new-vec 1)
   (move 2 3 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 222 tmp 0)
   (new-vec 0)
   (load close-flat 223 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 115)
   (label else%682)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 224 tmp 0)
   (new-vec 0)
   (load close-flat 225 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 115)
   (label else%681)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 35 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%683)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 226 tmp 0)
   (new-vec 0)
   (load close-flat 227 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%683)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 34 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%684)
   (new-vec 2)
   (move 2 3 vec 0)
   (move 2 2 vec 1)
   (tail-call glo 114)
   (label else%684)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 45 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%685)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 228 tmp 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 229 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)
   (label else%685)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 43 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%686)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 230 tmp 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 231 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)
   (label else%686)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 99 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%687)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 100 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 111)
   (label else%687)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 112)

   (label lambda-flat%202)
   (new-vec 0)
   (load close-flat 232 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%203)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 1 1)

   (label lambda-deep%204)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%688)
   (load bool 0 res 0)
   (return)
   (label else%688)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (move tmp 0 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%689)
   (move 0 0 res 0)
   (return)
   (label else%689)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%205)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%690)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%690)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 4 0 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%206)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 108 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%691)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 233 tmp 0)
   (new-vec 0)
   (load close-flat 234 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%691)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\new~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%207)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\new" vec 1)
   (tail-call glo 122)

   (label lambda-flat%208)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 99 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%692)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 235 tmp 0)
   (new-vec 0)
   (load close-flat 236 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%692)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%209)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa" vec 1)
   (tail-call glo 122)

   (label lambda-flat%210)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%693)
   (new-vec 1)
   (move glo 80 vec 0)
   (tail-call 1 0)
   (label else%693)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\tab~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%211)
   (new-vec 1)
   (move glo 80 vec 0)
   (tail-call 1 0)

   (label lambda-flat%212)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%213)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%214)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 237 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%215)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%216)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 238 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%217)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%218)
   (new-vec 2)
   (load sym quote vec 0)
   (move 0 0 vec 1)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%219)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%220)
   (new-vec 2)
   (load sym quasiquote vec 0)
   (move 0 0 vec 1)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%221)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%222)
   (new-vec 2)
   (load sym unquote-splicing vec 0)
   (move 0 0 vec 1)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%223)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%224)
   (new-vec 2)
   (load sym unquote vec 0)
   (move 0 0 vec 1)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%225)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%226)
   (load close-deep 239 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 116 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%694)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%694)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 84 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%227)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 122)

   (label lambda-flat%228)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 99 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%695)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 100 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (load close-flat 240 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 111)
   (label else%695)
   (new-vec 3)
   (load char 45 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 112)

   (label lambda-flat%229)
   (new-vec 1)
   (load sym - vec 0)
   (tail-call 1 0)

   (label lambda-flat%230)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 99 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%696)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 100 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 111)
   (label else%696)
   (new-vec 3)
   (load char 43 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 112)

   (label lambda-flat%231)
   (new-vec 1)
   (load sym + vec 0)
   (tail-call 1 0)

   (label lambda-flat%232)
   (move 0 0 res 0)
   (return)

   (label lambda-flat%233)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 105 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%697)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 241 tmp 0)
   (new-vec 0)
   (load close-flat 242 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%697)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newl~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%234)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newl" vec 1)
   (tail-call glo 122)

   (label lambda-flat%235)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%698)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 243 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 244 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%698)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%236)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa" vec 1)
   (tail-call glo 122)

   (label lambda-flat%237)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%238)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%239)
   (jump-if-false 0 0 else%699)
   (new-vec 1)
   (move 2 0 vec 0)
   (load close-flat 245 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (load close-flat 246 tmp 1)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)
   (label else%699)
   (load close-deep 247 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 102 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%700)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%700)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 70 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%240)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%701)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%701)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "-" vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 23)

   (label lambda-flat%241)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 110 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%702)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 248 tmp 0)
   (new-vec 0)
   (load close-flat 249 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%702)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newli~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%242)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newli" vec 1)
   (tail-call glo 122)

   (label lambda-flat%243)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%703)
   (new-vec 1)
   (move glo 82 vec 0)
   (tail-call 1 0)
   (label else%703)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\space~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%244)
   (new-vec 1)
   (move glo 82 vec 0)
   (tail-call 1 0)

   (label lambda-flat%245)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%704)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call 1 0)
   (label else%704)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown #t~s sequence" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%246)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call 1 0)

   (label lambda-deep%247)
   (jump-if-false 0 0 else%705)
   (new-vec 1)
   (move 3 0 vec 0)
   (load close-flat 250 tmp 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (load close-flat 251 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)
   (label else%705)
   (new-vec 2)
   (move 2 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%706)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 3 0 vec 1)
   (tail-call glo 113)
   (label else%706)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown # code: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%248)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 79 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%707)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 252 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 253 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 106)
   (label else%707)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newlin~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%249)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newlin" vec 1)
   (tail-call glo 122)

   (label lambda-flat%250)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%708)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 1 0)
   (label else%708)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown #f~s sequence" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%251)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%252)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 84 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%709)
   (new-vec 1)
   (move glo 81 vec 0)
   (tail-call 1 0)
   (label else%709)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newline~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 122)

   (label lambda-flat%253)
   (new-vec 1)
   (move glo 81 vec 0)
   (tail-call 1 0))
  "DAIMI-Scheme compiler, 03-10-22")
