(DAIMI-SchemeE03
  (3 2 1)
  ((1 lambda-deep%0)
   (-1 lambda-flat%1))
  ((load close-deep 0 glo 0)
   (new-vec 1)
   (load int 10 vec 0)
   (call glo 0 0)
   (move res 0 glo 1)
   (new-vec 1)
   (load int 20 vec 0)
   (call glo 0 0)
   (move res 0 glo 2)
   (new-vec 1)
   (load sym up vec 0)
   (call glo 1 0)
   (new-vec 1)
   (load sym down vec 0)
   (call glo 2 0)
   (new-vec 1)
   (load sym reset vec 0)
   (call glo 1 0)
   (new-vec 1)
   (load sym up vec 0)
   (call glo 1 0)
   (new-vec 1)
   (load sym up vec 0)
   (call glo 1 0)
   (new-vec 2)
   (load sym set vec 0)
   (load int 100 vec 1)
   (call glo 2 0)
   (new-vec 1)
   (load sym get vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load sym get vec 0)
   (call glo 2 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 1)

   (label lambda-deep%0)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (load close-flat 1 res 0)
   (return)

   (label lambda-flat%1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym get vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%4)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (tail-call lib 36)
   (label else%4)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym up vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%5)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call lib 37)
   (label else%5)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym down vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%6)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call lib 37)
   (label else%6)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym reset vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%7)
   (new-vec 3)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (move 2 0 vec 2)
   (tail-call lib 37)
   (label else%7)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym set vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%8)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call lib 37)
   (label else%8)
   (load str "Hvad sige du?" res 0)
   (return))
  "DAIMI-Scheme compiler, 03-10-22")
