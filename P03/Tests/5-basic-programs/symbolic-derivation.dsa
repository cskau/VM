(DAIMI-SchemeE03
  (22 3 1)
  ((-1 lambda-deep%0)
   (1 lambda-deep%1)
   (1 lambda-deep%2)
   (1 lambda-deep%3)
   (1 lambda-deep%4)
   (2 lambda-deep%5)
   (1 lambda-deep%6)
   (2 lambda-deep%7)
   (2 lambda-deep%8)
   (2 lambda-deep%9)
   (1 lambda-flat%10)
   (1 lambda-deep%11))
  ((new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym x vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym * vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 10 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym * vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym + vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym * vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 500 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym + vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 0)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym x vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym * vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym x vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym + vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (load close-deep 0 glo 2)
   (load close-deep 1 glo 3)
   (load close-deep 2 glo 4)
   (load close-deep 3 glo 5)
   (load close-deep 4 glo 6)
   (move lib 0 glo 7)
   (move lib 12 glo 8)
   (load close-deep 5 glo 9)
   (load close-deep 6 glo 10)
   (new-vec 1)
   (load sym + vec 0)
   (call glo 10 0)
   (move res 0 glo 11)
   (new-vec 1)
   (load sym * vec 0)
   (call glo 10 0)
   (move res 0 glo 12)
   (move glo 3 glo 13)
   (move glo 5 glo 14)
   (move glo 3 glo 15)
   (move glo 5 glo 16)
   (load close-deep 7 glo 17)
   (load close-deep 8 glo 18)
   (load close-deep 9 glo 19)
   (new-vec 2)
   (move glo 1 vec 0)
   (load sym x vec 1)
   (call glo 19 0)
   (move res 0 glo 20)
   (new-vec 2)
   (move glo 0 vec 0)
   (load sym x vec 1)
   (call glo 19 0)
   (move res 0 glo 21)
   (new-vec 2)
   (move glo 20 vec 0)
   (move glo 21 vec 1)
   (tail-call glo 2)

   (label lambda-deep%0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%2)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%3)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 3)

   (label lambda-deep%4)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 4)

   (label lambda-deep%5)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%18)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%19)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 40)
   (label else%19)
   (load bool 0 res 0)
   (return)
   (label else%18)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%6)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 10 res 0)
   (return)

   (label lambda-deep%7)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%20)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%21)
   (move 0 1 res 0)
   (return)
   (label else%21)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%22)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 1)
   (label else%22)
   (new-vec 3)
   (load sym + vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 2)
   (label else%20)
   (load close-deep 11 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 0 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%23)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%23)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%8)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%24)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%25)
   (load int 0 res 0)
   (return)
   (label else%25)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%26)
   (move 0 1 res 0)
   (return)
   (label else%26)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%27)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 3)
   (label else%27)
   (new-vec 3)
   (load sym * vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 2)
   (label else%24)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%28)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%29)
   (load int 0 res 0)
   (return)
   (label else%29)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%30)
   (move 0 0 res 0)
   (return)
   (label else%30)
   (new-vec 3)
   (load sym * vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 2)
   (label else%28)
   (new-vec 3)
   (load sym * vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 2)

   (label lambda-deep%9)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%31)
   (load int 0 res 0)
   (return)
   (label else%31)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%32)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%33)
   (load int 1 res 0)
   (return)
   (label else%33)
   (load int 0 res 0)
   (return)
   (label else%32)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%34)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call glo 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 17)
   (label else%34)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%35)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 15 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 16 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call glo 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 15 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call glo 19 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 16 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 18 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 17)
   (label else%35)
   (new-vec 1)
   (load int 1 vec 0)
   (tail-call lib 42)

   (label lambda-flat%10)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%36)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%37)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%38)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 4 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%39)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 31)
   (label else%39)
   (load bool 0 res 0)
   (return)
   (label else%38)
   (load bool 0 res 0)
   (return)
   (label else%37)
   (load bool 0 res 0)
   (return)
   (label else%36)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%11)
   (jump-if-false 0 0 else%40)
   (move 1 0 res 0)
   (return)
   (label else%40)
   (new-vec 3)
   (load sym + vec 0)
   (move 1 0 vec 1)
   (move 1 1 vec 2)
   (tail-call glo 2))
  "DAIMI-Scheme compiler, 03-10-22")
