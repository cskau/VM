(DAIMI-SchemeE03
  (133 5 1)
  ((1 lambda-deep%0)
   (1 lambda-deep%1)
   (2 lambda-deep%2)
   (2 lambda-deep%3)
   (2 lambda-deep%4)
   (2 lambda-deep%5)
   (-1 lambda-deep%6)
   (1 lambda-deep%7)
   (1 lambda-deep%8)
   (1 lambda-deep%9)
   (2 lambda-deep%10)
   (-1 lambda-deep%11)
   (1 lambda-deep%12)
   (1 lambda-deep%13)
   (1 lambda-deep%14)
   (2 lambda-deep%15)
   (2 lambda-deep%16)
   (3 lambda-deep%17)
   (2 lambda-deep%18)
   (2 lambda-deep%19)
   (2 lambda-deep%20)
   (2 lambda-deep%21)
   (1 lambda-deep%22)
   (1 lambda-deep%23)
   (1 lambda-deep%24)
   (1 lambda-deep%25)
   (1 lambda-deep%26)
   (1 lambda-deep%27)
   (1 lambda-deep%28)
   (2 lambda-deep%29)
   (2 lambda-deep%30)
   (2 lambda-deep%31)
   (2 lambda-deep%32)
   (-1 lambda-deep%33)
   (-1 lambda-deep%34)
   (2 lambda-deep%35)
   (-1 lambda-deep%36)
   (3 lambda-deep%37)
   (3 lambda-deep%38)
   (3 lambda-deep%39)
   (3 lambda-deep%40)
   (-1 lambda-deep%41)
   (-1 lambda-deep%42)
   (3 lambda-deep%43)
   (2 lambda-deep%44)
   (3 lambda-deep%45)
   (2 lambda-deep%46)
   (1 lambda-deep%47)
   (1 lambda-deep%48)
   (1 lambda-deep%49)
   (1 lambda-deep%50)
   (1 lambda-deep%51)
   (1 lambda-deep%52)
   (1 lambda-deep%53)
   (2 lambda-deep%54)
   (1 lambda-deep%55)
   (2 lambda-deep%56)
   (2 lambda-deep%57)
   (2 lambda-deep%58)
   (1 lambda-deep%59)
   (1 lambda-deep%60)
   (2 lambda-deep%61)
   (3 lambda-deep%62)
   (2 lambda-deep%63)
   (1 lambda-deep%64)
   (1 lambda-deep%65)
   (1 lambda-deep%66)
   (1 lambda-deep%67)
   (1 lambda-deep%68)
   (1 lambda-deep%69)
   (1 lambda-deep%70)
   (-1 lambda-deep%71)
   (1 lambda-deep%72)
   (1 lambda-deep%73)
   (1 lambda-deep%74)
   (1 lambda-deep%75)
   (1 lambda-deep%76)
   (1 lambda-deep%77)
   (1 lambda-deep%78)
   (2 lambda-deep%79)
   (2 lambda-deep%80)
   (-1 lambda-deep%81)
   (3 lambda-deep%82)
   (3 lambda-deep%83)
   (3 lambda-deep%84)
   (3 lambda-deep%85)
   (3 lambda-deep%86)
   (3 lambda-deep%87)
   (3 lambda-deep%88)
   (2 lambda-deep%89)
   (2 lambda-deep%90)
   (3 lambda-deep%91)
   (-1 lambda-deep%92)
   (2 lambda-deep%93)
   (-1 lambda-deep%94)
   (2 lambda-deep%95)
   (-1 lambda-deep%96)
   (1 lambda-deep%97)
   (-1 lambda-deep%98)
   (3 lambda-deep%99)
   (2 lambda-deep%100)
   (2 lambda-deep%101)
   (1 lambda-deep%102)
   (1 lambda-deep%103)
   (3 lambda-deep%104)
   (3 lambda-deep%105)
   (2 lambda-deep%106)
   (1 lambda-deep%107)
   (3 lambda-deep%108)
   (3 lambda-deep%109)
   (5 lambda-deep%110)
   (1 lambda-deep%111)
   (0 lambda-deep%112)
   (1 lambda-flat%113)
   (2 lambda-flat%114)
   (1 lambda-deep%115)
   (1 lambda-flat%116)
   (2 lambda-deep%117)
   (3 lambda-deep%118)
   (1 lambda-deep%119)
   (2 lambda-deep%120)
   (2 lambda-deep%121)
   (2 lambda-deep%122)
   (2 lambda-deep%123)
   (2 lambda-deep%124)
   (1 lambda-deep%125)
   (1 lambda-deep%126)
   (1 lambda-flat%127)
   (1 lambda-deep%128)
   (1 lambda-deep%129)
   (1 lambda-deep%130)
   (1 lambda-deep%131)
   (1 lambda-deep%132)
   (1 lambda-deep%133)
   (1 lambda-deep%134)
   (1 lambda-deep%135)
   (1 lambda-deep%136)
   (2 lambda-deep%137)
   (1 lambda-deep%138)
   (2 lambda-deep%139)
   (1 lambda-deep%140)
   (2 lambda-deep%141)
   (1 lambda-deep%142)
   (1 lambda-flat%143)
   (1 lambda-flat%144)
   (1 lambda-deep%145)
   (2 lambda-deep%146)
   (1 lambda-deep%147)
   (1 lambda-deep%148)
   (1 lambda-deep%149)
   (2 lambda-deep%150)
   (2 lambda-deep%151)
   (1 lambda-deep%152)
   (1 lambda-deep%153)
   (2 lambda-deep%154)
   (1 lambda-deep%155)
   (1 lambda-deep%156)
   (1 lambda-deep%157)
   (2 lambda-deep%158)
   (1 lambda-deep%159)
   (1 lambda-deep%160)
   (0 lambda-deep%161)
   (0 lambda-deep%162)
   (1 lambda-flat%163)
   (1 lambda-flat%164)
   (1 lambda-flat%165)
   (1 lambda-deep%166)
   (1 lambda-flat%167)
   (1 lambda-flat%168)
   (1 lambda-deep%169)
   (1 lambda-deep%170)
   (1 lambda-deep%171)
   (1 lambda-flat%172)
   (1 lambda-deep%173)
   (1 lambda-flat%174)
   (1 lambda-flat%175)
   (1 lambda-deep%176)
   (-1 lambda-flat%177)
   (1 lambda-deep%178)
   (1 lambda-deep%179)
   (2 lambda-flat%180)
   (1 lambda-flat%181)
   (1 lambda-deep%182)
   (1 lambda-deep%183)
   (1 lambda-flat%184)
   (1 lambda-flat%185)
   (1 lambda-flat%186)
   (1 lambda-flat%187)
   (1 lambda-flat%188)
   (1 lambda-flat%189)
   (1 lambda-flat%190)
   (1 lambda-flat%191)
   (1 lambda-flat%192)
   (1 lambda-flat%193)
   (1 lambda-flat%194)
   (1 lambda-flat%195)
   (1 lambda-flat%196)
   (1 lambda-flat%197)
   (1 lambda-deep%198)
   (2 lambda-deep%199)
   (1 lambda-deep%200)
   (1 lambda-deep%201)
   (1 lambda-deep%202)
   (1 lambda-deep%203)
   (1 lambda-deep%204)
   (1 lambda-deep%205)
   (2 lambda-deep%206)
   (1 lambda-flat%207)
   (1 lambda-flat%208)
   (1 lambda-flat%209)
   (1 lambda-flat%210)
   (1 lambda-flat%211)
   (1 lambda-flat%212)
   (1 lambda-flat%213)
   (1 lambda-flat%214)
   (1 lambda-flat%215)
   (1 lambda-flat%216)
   (1 lambda-flat%217)
   (1 lambda-flat%218)
   (1 lambda-flat%219)
   (1 lambda-flat%220)
   (1 lambda-flat%221)
   (1 lambda-flat%222)
   (1 lambda-flat%223)
   (1 lambda-flat%224)
   (1 lambda-flat%225)
   (1 lambda-deep%226)
   (1 lambda-flat%227)
   (1 lambda-flat%228)
   (1 lambda-deep%229)
   (2 lambda-flat%230)
   (-1 lambda-flat%231)
   (-1 lambda-flat%232)
   (1 lambda-deep%233)
   (1 lambda-deep%234)
   (1 lambda-flat%235)
   (1 lambda-flat%236)
   (1 lambda-flat%237)
   (1 lambda-flat%238)
   (1 lambda-flat%239)
   (1 lambda-flat%240)
   (1 lambda-flat%241)
   (1 lambda-flat%242)
   (1 lambda-flat%243)
   (1 lambda-flat%244)
   (1 lambda-flat%245)
   (1 lambda-flat%246)
   (1 lambda-flat%247)
   (1 lambda-flat%248)
   (1 lambda-flat%249)
   (1 lambda-flat%250)
   (1 lambda-flat%251)
   (1 lambda-flat%252)
   (1 lambda-flat%253)
   (1 lambda-flat%254)
   (1 lambda-flat%255)
   (1 lambda-flat%256)
   (1 lambda-flat%257)
   (1 lambda-flat%258)
   (1 lambda-flat%259)
   (1 lambda-flat%260)
   (1 lambda-flat%261)
   (2 lambda-deep%262)
   (1 lambda-deep%263)
   (1 lambda-deep%264)
   (1 lambda-flat%265)
   (1 lambda-flat%266)
   (1 lambda-flat%267)
   (1 lambda-flat%268)
   (1 lambda-flat%269)
   (1 lambda-flat%270)
   (1 lambda-deep%271)
   (1 lambda-flat%272)
   (1 lambda-flat%273)
   (1 lambda-flat%274)
   (1 lambda-flat%275)
   (1 lambda-flat%276)
   (1 lambda-flat%277)
   (1 lambda-flat%278)
   (1 lambda-deep%279)
   (1 lambda-flat%280)
   (1 lambda-flat%281)
   (1 lambda-flat%282)
   (1 lambda-flat%283)
   (1 lambda-flat%284)
   (1 lambda-flat%285))
  ((load close-deep 0 glo 0)
   (load close-deep 1 glo 1)
   (load close-deep 2 glo 2)
   (load close-deep 3 glo 3)
   (load close-deep 4 glo 4)
   (load close-deep 5 glo 5)
   (load close-deep 6 glo 6)
   (load close-deep 7 glo 7)
   (load close-deep 8 glo 8)
   (load close-deep 9 glo 9)
   (load close-deep 10 glo 10)
   (load close-deep 11 glo 11)
   (load close-deep 12 glo 12)
   (load close-deep 13 glo 13)
   (load close-deep 14 glo 14)
   (load close-deep 15 glo 15)
   (load close-deep 16 glo 16)
   (load close-deep 17 glo 17)
   (load close-deep 18 glo 18)
   (load close-deep 19 glo 19)
   (load close-deep 20 glo 20)
   (load close-deep 21 glo 21)
   (load close-deep 22 glo 22)
   (load close-deep 23 glo 23)
   (load close-deep 24 glo 24)
   (load close-deep 25 glo 25)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 22 vec 1)
   (call glo 2 0)
   (move res 0 glo 26)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 22 vec 1)
   (call glo 2 0)
   (move res 0 glo 27)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 24 vec 1)
   (call glo 2 0)
   (move res 0 glo 28)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 24 vec 1)
   (call glo 2 0)
   (move res 0 glo 29)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 23 vec 1)
   (call glo 2 0)
   (move res 0 glo 30)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 23 vec 1)
   (call glo 2 0)
   (move res 0 glo 31)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 25 vec 1)
   (call glo 2 0)
   (move res 0 glo 32)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 25 vec 1)
   (call glo 2 0)
   (move res 0 glo 33)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 33 vec 1)
   (call glo 2 0)
   (move res 0 glo 34)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 33 vec 1)
   (call glo 2 0)
   (move res 0 glo 35)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 35 vec 1)
   (call glo 2 0)
   (move res 0 glo 36)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 35 vec 1)
   (call glo 2 0)
   (move res 0 glo 37)
   (load close-deep 26 glo 38)
   (load close-deep 27 glo 39)
   (load close-deep 28 glo 40)
   (load close-deep 29 glo 41)
   (load close-deep 30 glo 42)
   (load close-deep 31 glo 43)
   (load close-deep 32 glo 44)
   (load close-deep 33 glo 45)
   (load close-deep 34 glo 46)
   (load close-deep 35 glo 47)
   (load close-deep 36 glo 48)
   (load close-deep 37 glo 49)
   (load close-deep 38 glo 50)
   (load close-deep 39 glo 51)
   (load close-deep 40 glo 52)
   (load close-deep 41 glo 53)
   (load close-deep 42 glo 54)
   (load close-deep 43 glo 55)
   (load close-deep 44 glo 56)
   (load close-deep 45 glo 57)
   (load close-deep 46 glo 58)
   (load close-deep 47 glo 59)
   (move glo 59 glo 60)
   (load close-deep 48 glo 61)
   (move glo 61 glo 62)
   (load close-deep 49 glo 63)
   (load close-deep 50 glo 64)
   (load close-deep 51 glo 65)
   (load close-deep 52 glo 66)
   (load close-deep 53 glo 67)
   (load close-deep 54 glo 68)
   (load close-deep 55 glo 69)
   (load close-deep 56 glo 70)
   (load close-deep 57 glo 71)
   (load close-deep 58 glo 72)
   (new-vec 1)
   (load int 9 vec 0)
   (call lib 15 0)
   (move res 0 glo 73)
   (new-vec 1)
   (load int 10 vec 0)
   (call lib 15 0)
   (move res 0 glo 74)
   (new-vec 1)
   (load int 32 vec 0)
   (call lib 15 0)
   (move res 0 glo 75)
   (load close-deep 59 glo 76)
   (load close-deep 60 glo 77)
   (load close-deep 61 glo 78)
   (load close-deep 62 glo 79)
   (load close-deep 63 glo 80)
   (load close-deep 64 glo 81)
   (load close-deep 65 glo 82)
   (load close-deep 66 glo 83)
   (load close-deep 67 glo 84)
   (load close-deep 68 glo 85)
   (load close-deep 69 glo 86)
   (load close-deep 70 glo 87)
   (load close-deep 71 glo 88)
   (load close-deep 72 glo 89)
   (load close-deep 73 glo 90)
   (load close-deep 74 glo 91)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load char 57 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 75 glo 92)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 76 glo 93)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 77 glo 94)
   (load close-deep 78 glo 95)
   (load close-deep 79 glo 96)
   (load close-deep 80 glo 97)
   (load close-deep 81 glo 98)
   (load close-deep 82 glo 99)
   (load close-deep 83 glo 100)
   (load close-deep 84 glo 101)
   (load close-deep 85 glo 102)
   (load close-deep 86 glo 103)
   (load close-deep 87 glo 104)
   (load close-deep 88 glo 105)
   (load close-deep 89 glo 106)
   (load close-deep 90 glo 107)
   (load close-deep 91 glo 108)
   (load close-deep 92 glo 109)
   (load close-deep 93 glo 110)
   (load close-deep 94 glo 111)
   (load close-deep 95 glo 112)
   (load close-deep 96 glo 113)
   (load close-deep 97 glo 114)
   (load close-deep 98 glo 115)
   (load close-deep 99 glo 116)
   (load close-deep 100 glo 117)
   (move lib 41 glo 118)
   (load close-deep 101 glo 119)
   (load close-deep 102 glo 120)
   (load close-deep 103 glo 121)
   (new-vec 1)
   (move lib 40 vec 0)
   (call glo 121 0)
   (move res 0 glo 122)
   (new-vec 1)
   (move glo 4 vec 0)
   (call glo 121 0)
   (move res 0 glo 123)
   (load close-deep 104 glo 124)
   (load close-deep 105 glo 125)
   (load close-deep 106 glo 126)
   (load close-deep 107 glo 127)
   (load close-deep 108 glo 128)
   (load close-deep 109 glo 129)
   (load close-deep 110 glo 130)
   (load close-deep 111 glo 131)
   (load close-deep 112 glo 132)
   (new-vec 0)
   (tail-call glo 132)

   (label lambda-deep%0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%1)
   (jump-if-false 0 0 else%506)
   (load bool 0 res 0)
   (return)
   (label else%506)
   (load bool 1 res 0)
   (return)

   (label lambda-deep%2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 113 res 0)
   (return)

   (label lambda-deep%3)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 114 res 0)
   (return)

   (label lambda-deep%4)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%507)
   (load bool 1 res 0)
   (return)
   (label else%507)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%508)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%509)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 21)
   (label else%509)
   (load bool 0 res 0)
   (return)
   (label else%508)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%510)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%511)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%512)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%513)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 4)
   (label else%513)
   (load bool 0 res 0)
   (return)
   (label else%512)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%514)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 4)
   (label else%514)
   (load bool 0 res 0)
   (return)
   (label else%511)
   (load bool 0 res 0)
   (return)
   (label else%510)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%515)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%516)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%517)
   (new-vec 1)
   (extend)
   (load close-deep 115 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%517)
   (load bool 0 res 0)
   (return)
   (label else%516)
   (load bool 0 res 0)
   (return)
   (label else%515)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%5)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 116 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 41)

   (label lambda-deep%6)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%7)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%518)
   (move 0 0 res 0)
   (return)
   (label else%518)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%8)
   (new-vec 1)
   (extend)
   (load close-deep 117 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%519)
   (move 0 0 res 0)
   (return)
   (label else%519)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%520)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%520)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%9)
   (new-vec 1)
   (extend)
   (load close-deep 118 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 0 vec 1)
   (load int 1 vec 2)
   (tail-call 1 0)

   (label lambda-deep%10)
   (new-vec 1)
   (extend)
   (load close-deep 119 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%11)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%521)
   (load nil _ res 0)
   (return)
   (label else%521)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%522)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 27)
   (label else%522)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%523)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 23 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 10)
   (label else%523)
   (new-vec 3)
   (move glo 10 vec 0)
   (load nil _ vec 1)
   (move 1 0 vec 2)
   (tail-call glo 49)

   (label lambda-deep%12)
   (new-vec 3)
   (move lib 26 vec 0)
   (load nil _ vec 1)
   (move 0 0 vec 2)
   (tail-call glo 50)

   (label lambda-deep%13)
   (new-vec 1)
   (extend)
   (load close-deep 120 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%14)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%524)
   (new-vec 1)
   (extend)
   (load close-deep 121 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 0 0)
   (label else%524)
   (new-vec 3)
   (load sym last-pair vec 0)
   (load str "not a non-empty list: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%15)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%525)
   (new-vec 3)
   (load sym list-ref vec 0)
   (load str "negative offset: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 115)
   (label else%525)
   (new-vec 1)
   (extend)
   (load close-deep 122 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%16)
   (new-vec 1)
   (extend)
   (load close-deep 123 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%17)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%526)
   (new-vec 3)
   (load sym list-set! vec 0)
   (load str "negative offset: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 115)
   (label else%526)
   (new-vec 1)
   (extend)
   (load close-deep 124 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%18)
   (new-vec 1)
   (extend)
   (load close-deep 125 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%19)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%20)
   (new-vec 1)
   (extend)
   (load close-deep 126 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%21)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%22)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%23)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%24)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%25)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%26)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 127 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 43)

   (label lambda-deep%27)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 41)

   (label lambda-deep%28)
   (new-vec 2)
   (move lib 28 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 41)

   (label lambda-deep%29)
   (new-vec 1)
   (extend)
   (load close-deep 128 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%30)
   (new-vec 1)
   (extend)
   (load close-deep 129 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%31)
   (new-vec 1)
   (extend)
   (load close-deep 130 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%32)
   (new-vec 1)
   (extend)
   (load close-deep 131 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%33)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%527)
   (new-vec 2)
   (load sym map vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 115)
   (label else%527)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%528)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 41)
   (label else%528)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%529)
   (new-vec 1)
   (extend)
   (load close-deep 132 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%529)
   (new-vec 2)
   (load sym map vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 115)

   (label lambda-deep%34)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%530)
   (new-vec 2)
   (load sym map-append vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 115)
   (label else%530)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%531)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 42)
   (label else%531)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%532)
   (new-vec 1)
   (extend)
   (load close-deep 133 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%532)
   (new-vec 2)
   (load sym map-append vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 115)

   (label lambda-deep%35)
   (new-vec 1)
   (extend)
   (load close-deep 134 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%36)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%533)
   (new-vec 2)
   (load sym for-each vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 115)
   (label else%533)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%534)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 47)
   (label else%534)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%535)
   (new-vec 1)
   (extend)
   (load close-deep 135 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%535)
   (new-vec 2)
   (load sym for-each vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 115)

   (label lambda-deep%37)
   (new-vec 1)
   (extend)
   (load close-deep 136 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%38)
   (new-vec 1)
   (extend)
   (load close-deep 137 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%39)
   (new-vec 1)
   (extend)
   (load close-deep 138 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%40)
   (new-vec 1)
   (extend)
   (load close-deep 139 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%41)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%536)
   (new-vec 2)
   (load sym right-fold vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 115)
   (label else%536)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 23 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 25 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%537)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 51)
   (label else%537)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%538)
   (new-vec 1)
   (extend)
   (load close-deep 140 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)
   (label else%538)
   (new-vec 2)
   (load sym variadic-right-fold vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 115)

   (label lambda-deep%42)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%539)
   (new-vec 2)
   (load sym left-fold vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 115)
   (label else%539)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 23 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 25 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%540)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 52)
   (label else%540)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%541)
   (new-vec 1)
   (extend)
   (load close-deep 141 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)
   (label else%541)
   (new-vec 2)
   (load sym variadic-left-fold vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 115)

   (label lambda-deep%43)
   (new-vec 1)
   (extend)
   (load close-deep 142 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%44)
   (new-vec 0)
   (load close-flat 143 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 55)

   (label lambda-deep%45)
   (new-vec 2)
   (move glo 1 vec 0)
   (move 0 0 vec 1)
   (call glo 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 55)

   (label lambda-deep%46)
   (new-vec 0)
   (load close-flat 144 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 57)

   (label lambda-deep%47)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 1)

   (label lambda-deep%48)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 2)

   (label lambda-deep%49)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 6)

   (label lambda-deep%50)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%51)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 10)

   (label lambda-deep%52)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%53)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 1)

   (label lambda-deep%54)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 63 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%542)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 63 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%543)
   (move 0 0 res 0)
   (return)
   (label else%543)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 1)
   (label else%542)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 63 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%544)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 1)
   (label else%544)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%55)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%545)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 2)
   (label else%545)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%56)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%546)
   (move 0 0 res 0)
   (return)
   (label else%546)
   (move 0 1 res 0)
   (return)

   (label lambda-deep%57)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%547)
   (move 0 1 res 0)
   (return)
   (label else%547)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%58)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 8)

   (label lambda-deep%59)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%548)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 32 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%549)
   (load bool 1 res 0)
   (return)
   (label else%549)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 10 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%550)
   (load bool 1 res 0)
   (return)
   (label else%550)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 9 vec 1)
   (tail-call lib 8)
   (label else%548)
   (new-vec 3)
   (load sym char:whitespace? vec 0)
   (load str "not a char: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%60)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 76 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%551)
   (load bool 1 res 0)
   (return)
   (label else%551)
   (load close-deep 145 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 40 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%552)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%552)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%553)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%553)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 91 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%554)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%554)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%555)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%555)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 39 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%556)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%556)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 96 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%557)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%557)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 44 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%558)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%558)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 59 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%61)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 146 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%62)
   (new-vec 1)
   (extend)
   (load close-deep 147 0 0)
   (load close-deep 148 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 1 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%559)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%560)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 2 vec 0)
   (move tmp 1 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%560)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%559)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%63)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%561)
   (new-vec 3)
   (load sym string-suffix? vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)
   (label else%561)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%562)
   (new-vec 3)
   (load sym string-suffix? vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 115)
   (label else%562)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%563)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (call glo 79 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 21)
   (label else%563)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%64)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%564)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 149 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%564)
   (new-vec 3)
   (load sym string->list vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%65)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 81 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 34 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 34 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%66)
   (new-vec 1)
   (extend)
   (load close-deep 150 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 63 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%565)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 45 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%565)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (tail-call 0 0)

   (label lambda-deep%67)
   (new-vec 1)
   (extend)
   (load close-deep 151 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%566)
   (new-vec 2)
   (load char 40 vec 0)
   (load char 41 vec 1)
   (tail-call glo 6)
   (label else%566)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%567)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 40 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%567)
   (new-vec 3)
   (load sym list-of-values->list-of-chars vec 0)
   (load str "not a list: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%68)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 83 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (extend)
   (load close-deep 152 0 0)
   (load close-deep 153 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%568)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%568)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 86 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 1 vec 0)
   (call 0 0 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%69)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%569)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 84)
   (label else%569)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%570)
   (jump-if-false 0 0 else%571)
   (new-vec 1)
   (load str "#t" vec 0)
   (tail-call glo 81)
   (label else%571)
   (new-vec 1)
   (load str "#f" vec 0)
   (tail-call glo 81)
   (label else%570)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%572)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 83)
   (label else%572)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%573)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)
   (label else%573)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%574)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 82)
   (label else%574)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%575)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 81)
   (label else%575)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%576)
   (new-vec 1)
   (load str "#<procedure>" vec 0)
   (tail-call glo 81)
   (label else%576)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%577)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 85)
   (label else%577)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 44 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%578)
   (new-vec 1)
   (load str "#<input-port>" vec 0)
   (tail-call glo 81)
   (label else%578)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 51 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%579)
   (new-vec 1)
   (load str "#<output-port>" vec 0)
   (tail-call glo 81)
   (label else%579)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%580)
   (new-vec 1)
   (load str "#<eof-object>" vec 0)
   (tail-call glo 81)
   (label else%580)
   (new-vec 3)
   (load sym value->list-of-chars vec 0)
   (load str "unrecognized value: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%70)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 86 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%71)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%581)
   (load str "" res 0)
   (return)
   (label else%581)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%582)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (extend)
   (load close-deep 154 0 0)
   (load close-deep 155 0 1)
   (load close-deep 156 0 2)
   (new-vec 2)
   (load int 0 vec 0)
   (move 2 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)
   (label else%582)
   (new-vec 3)
   (load sym format vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%72)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 157 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%73)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 158 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 3 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%74)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 83 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%75)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%583)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%584)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 7)
   (label else%584)
   (load bool 0 res 0)
   (return)
   (label else%583)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%76)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 92 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%585)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 2)
   (label else%585)
   (new-vec 3)
   (load sym digit->integer vec 0)
   (load str "not a digit: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%77)
   (load close-deep 159 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%586)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 9 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%586)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%78)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%587)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 160 tmp 0)
   (jump-if-false 0 0 else%588)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%588)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load char 45 vec 1)
   (call glo 72 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%589)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%589)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%587)
   (new-vec 3)
   (load sym string->integer vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%79)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 43 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 45 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%80)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 52 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%81)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%590)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 10 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 54)
   (label else%590)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%591)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 51 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%592)
   (new-vec 2)
   (load char 10 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 54)
   (label else%592)
   (new-vec 3)
   (load sym newline vec 0)
   (load str "not a port: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)
   (label else%591)
   (new-vec 3)
   (load sym newline vec 0)
   (load str "Too many arguments: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%82)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%593)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 2)
   (label else%593)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%83)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%594)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 2)
   (label else%594)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%84)
   (new-vec 1)
   (extend)
   (load close-deep 161 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%85)
   (new-vec 1)
   (extend)
   (load close-deep 162 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%86)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 163 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 102)

   (label lambda-deep%87)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (load close-flat 164 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 2 vec 1)
   (load close-flat 165 tmp 1)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)

   (label lambda-deep%88)
   (new-vec 1)
   (extend)
   (load close-deep 166 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%89)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 167 tmp 0)
   (new-vec 0)
   (load close-flat 168 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)

   (label lambda-deep%90)
   (new-vec 1)
   (extend)
   (load close-deep 169 0 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 0 0)

   (label lambda-deep%91)
   (new-vec 2)
   (extend)
   (load close-deep 170 0 0)
   (load close-deep 171 0 1)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (move 1 0 vec 3)
   (load close-flat 172 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 1 2 vec 2)
   (tail-call glo 103)

   (label lambda-deep%92)
   (load close-deep 173 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%595)
   (new-vec 0)
   (call lib 46 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%595)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%93)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 174 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 86 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 48)

   (label lambda-deep%94)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%596)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 110)
   (label else%596)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%597)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 23 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 110)
   (label else%597)
   (new-vec 3)
   (load sym write vec 0)
   (load str "wrong arity: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%95)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 175 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 86 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 48)

   (label lambda-deep%96)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%598)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 112)
   (label else%598)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%599)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 23 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 112)
   (label else%599)
   (new-vec 3)
   (load sym display vec 0)
   (load str "wrong arity: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%97)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%600)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 176 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%600)
   (new-vec 3)
   (load sym extract-directory-name vec 0)
   (load str "not a file name: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%98)
   (new-vec 0)
   (load close-flat 177 tmp 0)
   (move tmp 0 glo 115)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "DAIMI-Scheme error -- " vec 0)
   (move tmp 0 vec 1)
   (call glo 113 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%601)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 1)
   (load int 1 vec 0)
   (tail-call lib 42)
   (label else%601)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 178 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%602)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%602)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%99)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%603)
   (move 0 2 res 0)
   (return)
   (label else%603)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%604)
   (move 0 1 res 0)
   (return)
   (label else%604)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%605)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (move 0 2 vec 2)
   (call glo 116 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%605)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 1 vec 2)
   (call glo 116 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%100)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 179 tmp 0)
   (jump-if-false 0 0 else%606)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%606)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%101)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%102)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%103)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 180 res 0)
   (return)

   (label lambda-deep%104)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%607)
   (move 0 0 res 0)
   (return)
   (label else%607)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%608)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 125)
   (label else%608)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%609)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym quote vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%610)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 23 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call glo 128)
   (label else%610)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lambda vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%611)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 32 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move 1 1 vec 2)
   (tail-call glo 129)
   (label else%611)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym if vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%612)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 32 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 34 2)
   (move res 0 tmp 2)
   (new-vec 5)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move 1 1 vec 3)
   (move 1 2 vec 4)
   (tail-call glo 130)
   (label else%612)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 124 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (call tmp 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (load close-flat 181 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 45 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 39)
   (label else%609)
   (new-vec 1)
   (move glo 115 vec 0)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym _eval vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call tmp 0)

   (label lambda-deep%105)
   (new-vec 1)
   (extend)
   (load close-deep 182 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%106)
   (new-vec 1)
   (extend)
   (load close-deep 183 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%107)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym car vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%613)
   (new-vec 0)
   (load close-flat 184 res 0)
   (return)
   (label else%613)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym cdr vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%614)
   (new-vec 0)
   (load close-flat 185 res 0)
   (return)
   (label else%614)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym cons vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%615)
   (new-vec 0)
   (load close-flat 186 res 0)
   (return)
   (label else%615)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym null? vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%616)
   (new-vec 0)
   (load close-flat 187 res 0)
   (return)
   (label else%616)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym pair? vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%617)
   (new-vec 0)
   (load close-flat 188 res 0)
   (return)
   (label else%617)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym eqv? vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%618)
   (new-vec 0)
   (load close-flat 189 res 0)
   (return)
   (label else%618)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym equal? vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%619)
   (new-vec 0)
   (load close-flat 190 res 0)
   (return)
   (label else%619)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym apply vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%620)
   (new-vec 0)
   (load close-flat 191 res 0)
   (return)
   (label else%620)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym = vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%621)
   (new-vec 0)
   (load close-flat 192 res 0)
   (return)
   (label else%621)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym + vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%622)
   (new-vec 0)
   (load close-flat 193 res 0)
   (return)
   (label else%622)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym - vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%623)
   (new-vec 0)
   (load close-flat 194 res 0)
   (return)
   (label else%623)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym * vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%624)
   (new-vec 0)
   (load close-flat 195 res 0)
   (return)
   (label else%624)
   (new-vec 1)
   (move glo 115 vec 0)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym lookup vec 0)
   (load str "Unbound variable: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call tmp 0)

   (label lambda-deep%108)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%109)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%625)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (move 0 2 vec 2)
   (load close-flat 196 res 0)
   (return)
   (label else%625)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 0 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 197 res 0)
   (return)

   (label lambda-deep%110)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 3 vec 1)
   (move 0 4 vec 2)
   (call glo 124 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%626)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 0 3 vec 1)
   (move 0 4 vec 2)
   (tail-call glo 124)
   (label else%626)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 0 3 vec 1)
   (move 0 4 vec 2)
   (tail-call glo 124)

   (label lambda-deep%111)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 113 0)
   (new-vec 0)
   (tail-call glo 109)

   (label lambda-deep%112)
   (new-vec 1)
   (extend)
   (load close-deep 198 0 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 1)
   (load str "Hello world." vec 0)
   (call glo 113 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 0 0)

   (label lambda-flat%113)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%114)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%115)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%627)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 4)
   (label else%627)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%628)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%628)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%116)
   (new-vec 1)
   (extend)
   (load close-deep 199 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%117)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%629)
   (move 0 0 res 0)
   (return)
   (label else%629)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%630)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%631)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%632)
   (move 0 0 res 0)
   (return)
   (label else%632)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%633)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%633)
   (load bool 0 res 0)
   (return)
   (label else%631)
   (load bool 0 res 0)
   (return)
   (label else%630)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%118)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 2 0 vec 1)
   (call lib 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%634)
   (move 0 0 res 0)
   (return)
   (label else%634)
   (new-vec 1)
   (extend)
   (load close-deep 200 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%635)
   (new-vec 3)
   (load sym test-proper-list? vec 0)
   (load str "length ~s, cycle 0" vec 1)
   (move 2 2 vec 2)
   (tail-call glo 115)
   (label else%635)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%119)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%636)
   (move 2 1 res 0)
   (return)
   (label else%636)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%120)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%637)
   (move 0 1 res 0)
   (return)
   (label else%637)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%121)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%638)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%638)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%122)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%639)
   (new-vec 4)
   (load sym list-ref vec 0)
   (load str "offset ~s is out of range for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 115)
   (label else%639)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%640)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call lib 27)
   (label else%640)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%123)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%641)
   (new-vec 4)
   (load sym ref-list vec 0)
   (load str "~s is not in ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 115)
   (label else%641)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%642)
   (move 0 1 res 0)
   (return)
   (label else%642)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%124)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%643)
   (new-vec 4)
   (load sym list-set! vec 0)
   (load str "offset ~s is out of range for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 115)
   (label else%643)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%644)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 3 2 vec 1)
   (call lib 29 0)
   (move 0 0 res 0)
   (return)
   (label else%644)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%125)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%645)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%646)
   (move 0 0 res 0)
   (return)
   (label else%646)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%645)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%126)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%647)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 4 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%648)
   (move 0 0 res 0)
   (return)
   (label else%648)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%647)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%127)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%128)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%649)
   (load nil _ res 0)
   (return)
   (label else%649)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%129)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%650)
   (load nil _ res 0)
   (return)
   (label else%650)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)

   (label lambda-deep%130)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%651)
   (load bool 1 res 0)
   (return)
   (label else%651)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%652)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%652)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%131)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%653)
   (load bool 0 res 0)
   (return)
   (label else%653)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%654)
   (move 0 0 res 0)
   (return)
   (label else%654)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%132)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%655)
   (load nil _ res 0)
   (return)
   (label else%655)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 39 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%133)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%656)
   (load nil _ res 0)
   (return)
   (label else%656)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 39 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)

   (label lambda-deep%134)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%657)
   (load nil _ res 0)
   (return)
   (label else%657)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%135)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%658)
   (load nil _ res 0)
   (return)
   (label else%658)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 39 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%136)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%659)
   (move 2 1 res 0)
   (return)
   (label else%659)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%137)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%660)
   (move 0 1 res 0)
   (return)
   (label else%660)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%138)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%661)
   (move 2 1 res 0)
   (return)
   (label else%661)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%139)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%662)
   (move 0 1 res 0)
   (return)
   (label else%662)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%140)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%663)
   (move 2 1 res 0)
   (return)
   (label else%663)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 39 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%141)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%664)
   (move 0 1 res 0)
   (return)
   (label else%664)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 39 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 39 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%142)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%665)
   (load nil _ res 0)
   (return)
   (label else%665)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%666)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%666)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%143)
   (move 0 0 res 0)
   (return)

   (label lambda-flat%144)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%145)
   (jump-if-false 0 0 else%667)
   (load bool 1 res 0)
   (return)
   (label else%667)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%146)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 2 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%668)
   (load bool 0 res 0)
   (return)
   (label else%668)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%669)
   (load bool 1 res 0)
   (return)
   (label else%669)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 1 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%670)
   (load bool 1 res 0)
   (return)
   (label else%670)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 10 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%671)
   (load bool 0 res 0)
   (return)
   (label else%671)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%147)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%672)
   (load nil _ res 0)
   (return)
   (label else%672)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%148)
   (jump-if-false 0 0 else%673)
   (new-vec 1)
   (move 2 1 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)
   (label else%673)
   (new-vec 5)
   (load sym substring vec 0)
   (load str "~s and ~s are not valid start/end indices for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 2 vec 3)
   (move 2 0 vec 4)
   (tail-call glo 115)

   (label lambda-deep%149)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%674)
   (load nil _ res 0)
   (return)
   (label else%674)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%675)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%675)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%150)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 10 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "0123456789" vec 0)
   (move tmp 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 10 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%676)
   (move 0 0 res 0)
   (return)
   (label else%676)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 10 vec 1)
   (call lib 4 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 2 0)

   (label lambda-deep%151)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 86 0)
   (move res 0 tmp 0)
   (load close-deep 201 tmp 1)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%677)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%677)
   (load close-deep 202 tmp 2)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%678)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call 1 0 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%678)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 86 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move glo 75 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load char 46 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)

   (label lambda-deep%152)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%679)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)
   (label else%679)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 86 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 75 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%153)
   (new-vec 2)
   (load char 40 vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 35 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%154)
   (new-vec 3)
   (extend)
   (load close-deep 203 0 0)
   (load close-deep 204 0 1)
   (load close-deep 205 0 2)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%680)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 2 1)
   (label else%680)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%155)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%681)
   (load nil _ res 0)
   (return)
   (label else%681)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 126 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%682)
   (new-vec 3)
   (load sym format vec 0)
   (load str "too many arguments for ~s" vec 1)
   (move 4 0 vec 2)
   (tail-call glo 115)
   (label else%682)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%683)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 2)
   (label else%683)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%156)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%684)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 115)
   (label else%684)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%157)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%685)
   (load nil _ res 0)
   (return)
   (label else%685)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%158)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%686)
   (move 2 0 res 0)
   (return)
   (label else%686)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%159)
   (jump-if-false 0 0 else%687)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 0 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 15)
   (label else%687)
   (new-vec 3)
   (load sym integer->digit vec 0)
   (load str "non-digitable integer: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%160)
   (jump-if-false 0 0 else%688)
   (new-vec 3)
   (load sym string->integer vec 0)
   (load str "invalid string: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 115)
   (label else%688)
   (new-vec 1)
   (extend)
   (load close-deep 206 0 0)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 45 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%689)
   (new-vec 2)
   (load int 1 vec 0)
   (load int 0 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 2)
   (label else%689)
   (new-vec 2)
   (load int 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%161)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 1 0 vec 1)
   (load close-flat 207 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 99)

   (label lambda-deep%162)
   (new-vec 4)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (move 2 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 208 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 100)

   (label lambda-flat%163)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%164)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 92 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%690)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (load int 10 vec 0)
   (move 1 1 vec 1)
   (call lib 3 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 93 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 104)
   (label else%690)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%691)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 1 0)
   (label else%691)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 209 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)

   (label lambda-flat%165)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%166)
   (new-vec 4)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 210 tmp 0)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 211 tmp 1)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)

   (label lambda-flat%167)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 110 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%692)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%693)
   (new-vec 1)
   (load char 110 vec 0)
   (tail-call 2 1)
   (label else%693)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%694)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 212 tmp 0)
   (new-vec 0)
   (load close-flat 213 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%694)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\n~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)
   (label else%692)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 115 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%695)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%696)
   (new-vec 1)
   (load char 115 vec 0)
   (tail-call 2 1)
   (label else%696)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 112 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%697)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 214 tmp 0)
   (new-vec 0)
   (load close-flat 215 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%697)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\s~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)
   (label else%695)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 116 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%698)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%699)
   (new-vec 1)
   (load char 116 vec 0)
   (tail-call 2 1)
   (label else%699)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 97 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%700)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 216 tmp 0)
   (new-vec 0)
   (load close-flat 217 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%700)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\t~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)
   (label else%698)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 218 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 219 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)

   (label lambda-flat%168)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-deep%169)
   (new-vec 4)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (move 1 0 vec 2)
   (move 0 0 vec 3)
   (load close-flat 220 tmp 0)
   (new-vec 0)
   (load close-flat 221 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)

   (label lambda-deep%170)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (load close-flat 222 tmp 0)
   (new-vec 0)
   (load close-flat 223 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 102)

   (label lambda-deep%171)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 224 tmp 0)
   (new-vec 0)
   (load close-flat 225 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 102)

   (label lambda-flat%172)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 40 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%701)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 1 0)
   (label else%701)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 91 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%702)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 1 1)
   (label else%702)
   (load close-deep 226 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%703)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%703)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%173)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 227 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 41)

   (label lambda-flat%174)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 54)

   (label lambda-flat%175)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 34 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%704)
   (load nil _ res 0)
   (return)
   (label else%704)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 54)

   (label lambda-deep%176)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 63 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%705)
   (load str "" res 0)
   (return)
   (label else%705)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 47 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%706)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 79)
   (label else%706)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%177)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "DAIMI-Scheme: error in error." vec 0)
   (move tmp 0 vec 1)
   (call glo 113 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 1)
   (load int 3 vec 0)
   (tail-call lib 42)

   (label lambda-deep%178)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 113 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str " -- " vec 0)
   (move tmp 0 vec 1)
   (call glo 113 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 88 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 113 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 1)
   (load int 2 vec 0)
   (tail-call lib 42)

   (label lambda-deep%179)
   (jump-if-false 0 0 else%707)
   (move 2 1 res 0)
   (return)
   (label else%707)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (load close-flat 228 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 56 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 117 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 58 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 117 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (call glo 116 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 4 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 116)

   (label lambda-flat%180)
   (new-vec 1)
   (extend)
   (load close-deep 229 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-flat%181)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 124)

   (label lambda-deep%182)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%708)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 2 vec 1)
   (tail-call glo 126)
   (label else%708)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%709)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)
   (label else%709)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%183)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%710)
   (new-vec 1)
   (move 2 0 vec 0)
   (tail-call glo 127)
   (label else%710)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%711)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)
   (label else%711)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%184)
   (move lib 27 res 0)
   (return)

   (label lambda-flat%185)
   (move lib 28 res 0)
   (return)

   (label lambda-flat%186)
   (move lib 26 res 0)
   (return)

   (label lambda-flat%187)
   (move lib 31 res 0)
   (return)

   (label lambda-flat%188)
   (move lib 25 res 0)
   (return)

   (label lambda-flat%189)
   (move lib 40 res 0)
   (return)

   (label lambda-flat%190)
   (move glo 4 res 0)
   (return)

   (label lambda-flat%191)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 230 res 0)
   (return)

   (label lambda-flat%192)
   (move lib 8 res 0)
   (return)

   (label lambda-flat%193)
   (move lib 1 res 0)
   (return)

   (label lambda-flat%194)
   (move lib 2 res 0)
   (return)

   (label lambda-flat%195)
   (move lib 3 res 0)
   (return)

   (label lambda-flat%196)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (load close-flat 231 res 0)
   (return)

   (label lambda-flat%197)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (load close-flat 232 res 0)
   (return)

   (label lambda-deep%198)
   (new-vec 1)
   (load str ">>> " vec 0)
   (call glo 131 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%712)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (load str "Nice when it stops" res 0)
   (return)
   (label else%712)
   (load close-deep 233 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%713)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load sym exit vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%713)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%199)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%714)
   (load bool 1 res 0)
   (return)
   (label else%714)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%715)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%716)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%717)
   (load bool 1 res 0)
   (return)
   (label else%717)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%716)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%715)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%718)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%719)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%720)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%721)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%721)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%720)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%722)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%722)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 1 0 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%719)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%718)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%723)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%724)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%725)
   (new-vec 1)
   (extend)
   (load close-deep 234 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%725)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 3 0)
   (label else%724)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%723)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%200)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%726)
   (new-vec 2)
   (move 3 2 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 2 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 3 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call 4 0)
   (label else%726)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call glo 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%727)
   (new-vec 4)
   (load sym test-proper-list? vec 0)
   (load str "length ~s, cycle ~s" vec 1)
   (move 3 2 vec 2)
   (move 0 0 vec 3)
   (tail-call glo 115)
   (label else%727)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%201)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 11)

   (label lambda-deep%202)
   (new-vec 2)
   (move glo 75 vec 0)
   (move 0 0 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%203)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%728)
   (load nil _ res 0)
   (return)
   (label else%728)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 126 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%729)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 1)
   (label else%729)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%730)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 2)
   (label else%730)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%204)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%731)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 5 0 vec 2)
   (tail-call glo 115)
   (label else%731)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 115 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%732)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%733)
   (new-vec 3)
   (load sym format vec 0)
   (load str "too few arguments for ~s" vec 1)
   (move 6 0 vec 2)
   (tail-call glo 115)
   (label else%733)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 86 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 4 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)
   (label else%732)
   (new-vec 3)
   (load sym format vec 0)
   (load str "illegal control character: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-deep%205)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%734)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 5 0 vec 2)
   (tail-call glo 115)
   (label else%734)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%206)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%735)
   (move 0 1 res 0)
   (return)
   (label else%735)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 93 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load int 10 vec 0)
   (move 0 1 vec 1)
   (call lib 3 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%207)
   (new-vec 2)
   (move 0 0 vec 0)
   (move glo 74 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%736)
   (new-vec 0)
   (tail-call 1 0)
   (label else%736)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-flat%208)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 76 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%737)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (new-vec 0)
   (tail-call 1 1)
   (label else%737)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 59 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%738)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 101)
   (label else%738)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 3)

   (label lambda-flat%209)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 91 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%210)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%739)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 12 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%739)
   (new-vec 1)
   (move 1 3 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%211)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 12 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%212)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 119 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%740)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 235 tmp 0)
   (new-vec 0)
   (load close-flat 236 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%740)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\ne~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%213)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\ne" vec 1)
   (tail-call glo 115)

   (label lambda-flat%214)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 97 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%741)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 237 tmp 0)
   (new-vec 0)
   (load close-flat 238 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%741)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\sp~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%215)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\sp" vec 1)
   (tail-call glo 115)

   (label lambda-flat%216)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 98 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%742)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 239 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 240 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)
   (label else%742)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\ta~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%217)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\ta" vec 1)
   (tail-call glo 115)

   (label lambda-flat%218)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%743)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 1 0)
   (label else%743)
   (new-vec 4)
   (load sym read vec 0)
   (load str "Invalid character name #\\~s~s" vec 1)
   (move 1 1 vec 2)
   (move 0 0 vec 3)
   (tail-call glo 115)

   (label lambda-flat%219)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%220)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 34 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%744)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 12 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%744)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%745)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 3 vec 1)
   (load close-flat 241 tmp 0)
   (new-vec 0)
   (load close-flat 242 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%745)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 3 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 2)

   (label lambda-flat%221)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%222)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%746)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 1 2)
   (label else%746)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (load close-flat 243 tmp 0)
   (new-vec 0)
   (load close-flat 244 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 108)

   (label lambda-flat%223)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%224)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%747)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 1 2)
   (label else%747)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (load close-flat 245 tmp 0)
   (new-vec 0)
   (load close-flat 246 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 108)

   (label lambda-flat%225)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-deep%226)
   (jump-if-false 0 0 else%748)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unexpected ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 115)
   (label else%748)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 39 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%749)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 247 tmp 0)
   (new-vec 0)
   (load close-flat 248 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 108)
   (label else%749)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 96 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%750)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 249 tmp 0)
   (new-vec 0)
   (load close-flat 250 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 108)
   (label else%750)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 44 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%751)
   (new-vec 1)
   (move 2 3 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 64 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%752)
   (new-vec 1)
   (move 2 3 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 251 tmp 0)
   (new-vec 0)
   (load close-flat 252 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 108)
   (label else%752)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 253 tmp 0)
   (new-vec 0)
   (load close-flat 254 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 108)
   (label else%751)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 35 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%753)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 255 tmp 0)
   (new-vec 0)
   (load close-flat 256 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%753)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 34 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%754)
   (new-vec 2)
   (move 2 3 vec 0)
   (move 2 2 vec 1)
   (tail-call glo 107)
   (label else%754)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 45 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%755)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 257 tmp 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 258 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)
   (label else%755)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 43 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%756)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 259 tmp 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 260 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)
   (label else%756)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 92 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%757)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 104)
   (label else%757)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 105)

   (label lambda-flat%227)
   (new-vec 0)
   (load close-flat 261 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (tail-call glo 108)

   (label lambda-flat%228)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 1 1)

   (label lambda-deep%229)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%758)
   (load bool 0 res 0)
   (return)
   (label else%758)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (move tmp 0 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%759)
   (move 0 0 res 0)
   (return)
   (label else%759)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)

   (label lambda-flat%230)
   (new-vec 1)
   (move 1 0 vec 0)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 39)

   (label lambda-flat%231)
   (new-vec 1)
   (extend)
   (load close-deep 262 0 0)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move 2 0 vec 2)
   (tail-call glo 124)

   (label lambda-flat%232)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 124)

   (label lambda-deep%233)
   (jump-if-false 0 0 else%760)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%761)
   (load str "Nice when it stops" res 0)
   (return)
   (label else%761)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 263 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%762)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%762)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%760)
   (load close-deep 264 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%763)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load sym define vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%763)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%234)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%764)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%764)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 4 0 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%235)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 108 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%765)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 265 tmp 0)
   (new-vec 0)
   (load close-flat 266 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%765)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\new~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%236)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\new" vec 1)
   (tail-call glo 115)

   (label lambda-flat%237)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 99 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%766)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 267 tmp 0)
   (new-vec 0)
   (load close-flat 268 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%766)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%238)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa" vec 1)
   (tail-call glo 115)

   (label lambda-flat%239)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%767)
   (new-vec 1)
   (move glo 73 vec 0)
   (tail-call 1 0)
   (label else%767)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\tab~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%240)
   (new-vec 1)
   (move glo 73 vec 0)
   (tail-call 1 0)

   (label lambda-flat%241)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%242)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%243)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 269 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%244)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%245)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 270 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%246)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%247)
   (new-vec 2)
   (load sym quote vec 0)
   (move 0 0 vec 1)
   (call glo 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%248)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%249)
   (new-vec 2)
   (load sym quasiquote vec 0)
   (move 0 0 vec 1)
   (call glo 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%250)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%251)
   (new-vec 2)
   (load sym unquote-splicing vec 0)
   (move 0 0 vec 1)
   (call glo 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%252)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%253)
   (new-vec 2)
   (load sym unquote vec 0)
   (move 0 0 vec 1)
   (call glo 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%254)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%255)
   (load close-deep 271 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 116 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%768)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%768)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 84 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%256)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 115)

   (label lambda-flat%257)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 92 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%769)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (load close-flat 272 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%769)
   (new-vec 3)
   (load char 45 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 105)

   (label lambda-flat%258)
   (new-vec 1)
   (load sym - vec 0)
   (tail-call 1 0)

   (label lambda-flat%259)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 92 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%770)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 93 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 104)
   (label else%770)
   (new-vec 3)
   (load char 43 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 105)

   (label lambda-flat%260)
   (new-vec 1)
   (load sym + vec 0)
   (tail-call 1 0)

   (label lambda-flat%261)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%262)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%771)
   (move 3 3 res 0)
   (return)
   (label else%771)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%263)
   (jump-if-false 0 0 else%772)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 27)
   (label else%772)
   (move 1 0 res 0)
   (return)

   (label lambda-deep%264)
   (jump-if-false 0 0 else%773)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (move 3 0 vec 2)
   (call glo 124 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 4 0)
   (label else%773)
   (new-vec 3)
   (move 2 0 vec 0)
   (load nil _ vec 1)
   (move 3 0 vec 2)
   (call glo 124 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 111 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (tail-call 4 0)

   (label lambda-flat%265)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 105 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%774)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 273 tmp 0)
   (new-vec 0)
   (load close-flat 274 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%774)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newl~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%266)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newl" vec 1)
   (tail-call glo 115)

   (label lambda-flat%267)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%775)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 275 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 276 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%775)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%268)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa" vec 1)
   (tail-call glo 115)

   (label lambda-flat%269)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%270)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%271)
   (jump-if-false 0 0 else%776)
   (new-vec 1)
   (move 2 0 vec 0)
   (load close-flat 277 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (load close-flat 278 tmp 1)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)
   (label else%776)
   (load close-deep 279 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 102 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%777)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%777)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 70 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%272)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%778)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%778)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "-" vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 23)

   (label lambda-flat%273)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 110 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%779)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 280 tmp 0)
   (new-vec 0)
   (load close-flat 281 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%779)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newli~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%274)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newli" vec 1)
   (tail-call glo 115)

   (label lambda-flat%275)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%780)
   (new-vec 1)
   (move glo 75 vec 0)
   (tail-call 1 0)
   (label else%780)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\space~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%276)
   (new-vec 1)
   (move glo 75 vec 0)
   (tail-call 1 0)

   (label lambda-flat%277)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%781)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call 1 0)
   (label else%781)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown #t~s sequence" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%278)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call 1 0)

   (label lambda-deep%279)
   (jump-if-false 0 0 else%782)
   (new-vec 1)
   (move 3 0 vec 0)
   (load close-flat 282 tmp 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (load close-flat 283 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 100)
   (label else%782)
   (new-vec 2)
   (move 2 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%783)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 3 0 vec 1)
   (tail-call glo 106)
   (label else%783)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown # code: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%280)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 72 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%784)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 284 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 285 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 99)
   (label else%784)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newlin~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%281)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newlin" vec 1)
   (tail-call glo 115)

   (label lambda-flat%282)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%785)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 1 0)
   (label else%785)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown #f~s sequence" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%283)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%284)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%786)
   (new-vec 1)
   (move glo 74 vec 0)
   (tail-call 1 0)
   (label else%786)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newline~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 115)

   (label lambda-flat%285)
   (new-vec 1)
   (move glo 74 vec 0)
   (tail-call 1 0))
  "DAIMI-Scheme compiler, 03-10-22")
