(DAIMI-SchemeE03
  (15 5 1)
  ((1 lambda-deep%0)
   (1 lambda-deep%1)
   (1 lambda-deep%2)
   (6 lambda-deep%3)
   (0 lambda-deep%4)
   (0 lambda-deep%5)
   (0 lambda-deep%6)
   (0 lambda-flat%7)
   (0 lambda-flat%8)
   (0 lambda-flat%9)
   (0 lambda-flat%10)
   (0 lambda-flat%11)
   (0 lambda-flat%12)
   (0 lambda-flat%13)
   (0 lambda-flat%14)
   (0 lambda-flat%15)
   (0 lambda-flat%16)
   (0 lambda-flat%17)
   (0 lambda-flat%18)
   (0 lambda-flat%19)
   (-1 lambda-flat%20)
   (0 lambda-flat%21)
   (1 lambda-deep%22)
   (0 lambda-flat%23)
   (0 lambda-flat%24))
  ((new-vec 2)
   (load int 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 0)
   (new-vec 2)
   (load int 4 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (new-vec 2)
   (load int 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 2)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 3)
   (new-vec 2)
   (load int 4 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 4)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 5)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 6)
   (new-vec 2)
   (load int 3 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 7)
   (load close-deep 0 glo 8)
   (load close-deep 1 glo 9)
   (load close-deep 2 glo 10)
   (load close-deep 3 glo 11)
   (load close-deep 4 glo 12)
   (load close-deep 5 glo 13)
   (load close-deep 6 glo 14)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 9 0)
   (new-vec 1)
   (load str "Type       Same Iden Comp Proc Diff" vec 0)
   (call glo 8 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 9 0)
   (new-vec 2)
   (load int 21 vec 0)
   (load int 21 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 7 tmp 1)
   (new-vec 6)
   (load str "Integer    " vec 0)
   (load int 42 vec 1)
   (load int 42 vec 2)
   (move tmp 0 vec 3)
   (load int 36 vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 1)
   (load int 42 vec 0)
   (call lib 15 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 8 tmp 1)
   (new-vec 6)
   (load str "Character  " vec 0)
   (load char 42 vec 1)
   (load char 42 vec 2)
   (move tmp 0 vec 3)
   (load char 36 vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 2)
   (load int 42 vec 0)
   (load int 42 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 9 tmp 1)
   (new-vec 6)
   (load str "Boolean    " vec 0)
   (load bool 1 vec 1)
   (load bool 1 vec 2)
   (move tmp 0 vec 3)
   (load bool 0 vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 1)
   (load char 42 vec 0)
   (call lib 16 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 10 tmp 1)
   (new-vec 6)
   (load str "String     " vec 0)
   (load str "*" vec 1)
   (load str "*" vec 2)
   (move tmp 0 vec 3)
   (load str "$" vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 0)
   (call lib 16 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 11 tmp 1)
   (new-vec 6)
   (load str "(empty)    " vec 0)
   (load str "" vec 1)
   (load str "" vec 2)
   (move tmp 0 vec 3)
   (load str "$" vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 1)
   (load str "a" vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 12 tmp 1)
   (new-vec 6)
   (load str "Symbol     " vec 0)
   (load sym a vec 1)
   (load sym a vec 2)
   (move tmp 0 vec 3)
   (load sym b vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move glo 5 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 13 tmp 1)
   (new-vec 6)
   (load str "List       " vec 0)
   (move glo 7 vec 1)
   (move glo 6 vec 2)
   (move tmp 0 vec 3)
   (move glo 4 vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 1)
   (move glo 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 14 tmp 1)
   (new-vec 6)
   (load str "(empty)    " vec 0)
   (load nil _ vec 1)
   (load nil _ vec 2)
   (move tmp 0 vec 3)
   (move glo 1 vec 4)
   (move tmp 1 vec 5)
   (call glo 11 0)
   (new-vec 2)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call glo 13 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load int 4 vec 0)
   (load int 4 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 0)
   (load close-flat 15 tmp 4)
   (new-vec 6)
   (load str "Pair       " vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (move tmp 3 vec 4)
   (move tmp 4 vec 5)
   (call glo 11 0)
   (new-vec 3)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (call lib 32 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call glo 12 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 4 vec 0)
   (call lib 32 3)
   (move res 0 tmp 3)
   (new-vec 0)
   (load close-flat 16 tmp 4)
   (new-vec 6)
   (load str "Vector     " vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (move tmp 3 vec 4)
   (move tmp 4 vec 5)
   (call glo 11 0)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 32 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load int 0 vec 0)
   (load sym bla vec 1)
   (call lib 33 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 4 vec 0)
   (call lib 32 3)
   (move res 0 tmp 3)
   (new-vec 0)
   (load close-flat 17 tmp 4)
   (new-vec 6)
   (load str "(empty)    " vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (move tmp 3 vec 4)
   (move tmp 4 vec 5)
   (call glo 11 0)
   (new-vec 0)
   (load close-flat 18 tmp 0)
   (new-vec 0)
   (load close-flat 19 tmp 1)
   (new-vec 0)
   (call glo 14 2)
   (move res 0 tmp 2)
   (new-vec 0)
   (load close-flat 20 tmp 3)
   (new-vec 0)
   (load close-flat 21 tmp 4)
   (new-vec 6)
   (load str "Procedure  " vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (move tmp 3 vec 4)
   (move tmp 4 vec 5)
   (tail-call glo 11)

   (label lambda-deep%0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 22 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%1)
   (new-vec 2)
   (load char 10 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 54)

   (label lambda-deep%2)
   (jump-if-false 0 0 else%23)
   (load str "yes  " res 0)
   (return)
   (label else%23)
   (load str "no   " res 0)
   (return)

   (label lambda-deep%3)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 8 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 3 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (new-vec 0)
   (call 0 5 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 0 5 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 4 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 8 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 9)

   (label lambda-deep%4)
   (new-vec 2)
   (load int 3 vec 0)
   (load int 1 vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (load int 2 vec 2)
   (call lib 37 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (call lib 37 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%5)
   (new-vec 1)
   (move glo 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 30 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%6)
   (new-vec 0)
   (load close-flat 23 res 0)
   (return)

   (label lambda-flat%7)
   (load int 42 res 0)
   (return)

   (label lambda-flat%8)
   (load char 42 res 0)
   (return)

   (label lambda-flat%9)
   (load bool 1 res 0)
   (return)

   (label lambda-flat%10)
   (load str "*" res 0)
   (return)

   (label lambda-flat%11)
   (load str "" res 0)
   (return)

   (label lambda-flat%12)
   (load sym a res 0)
   (return)

   (label lambda-flat%13)
   (move glo 3 res 0)
   (return)

   (label lambda-flat%14)
   (load nil _ res 0)
   (return)

   (label lambda-flat%15)
   (new-vec 2)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (tail-call lib 26)

   (label lambda-flat%16)
   (new-vec 3)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (tail-call lib 32)

   (label lambda-flat%17)
   (new-vec 0)
   (tail-call lib 32)

   (label lambda-flat%18)
   (load int 42 res 0)
   (return)

   (label lambda-flat%19)
   (load int 42 res 0)
   (return)

   (label lambda-flat%20)
   (move 0 0 res 0)
   (return)

   (label lambda-flat%21)
   (new-vec 0)
   (load close-flat 24 res 0)
   (return)

   (label lambda-deep%22)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%24)
   (load sym done res 0)
   (return)
   (label else%24)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%23)
   (load int 42 res 0)
   (return)

   (label lambda-flat%24)
   (load int 42 res 0)
   (return))
  "DAIMI-Scheme compiler, 03-10-22")
