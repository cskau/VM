(DAIMI-SchemeE03
  (1 2 1)
  ((2 lambda-deep%0)
   (1 lambda-deep%1)
   (1 lambda-deep%2)
   (1 lambda-deep%3)
   (1 lambda-deep%4)
   (1 lambda-deep%5)
   (1 lambda-deep%6)
   (1 lambda-deep%7)
   (1 lambda-deep%8))
  ((load close-deep 0 glo 0)
   (new-vec 3)
   (load int 3 vec 0)
   (load int 4 vec 1)
   (load char 97 vec 2)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load int 3 vec 0)
   (load int 4 vec 1)
   (load char 97 vec 2)
   (call lib 32 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load int 2 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 1 vec 1)
   (call lib 32 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 0)

   (label lambda-deep%0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%17)
   (move 0 0 res 0)
   (return)
   (label else%17)
   (load close-deep 1 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 0 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%18)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 0 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%18)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%1)
   (jump-if-false 0 0 else%19)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 8)
   (label else%19)
   (load close-deep 2 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 13 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%20)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 13 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%20)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%2)
   (jump-if-false 0 0 else%21)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 8)
   (label else%21)
   (load close-deep 3 tmp 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 18 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%22)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 18 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%22)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%3)
   (jump-if-false 0 0 else%23)
   (new-vec 1)
   (move 4 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 5 1 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%24)
   (new-vec 1)
   (extend)
   (load close-deep 4 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%24)
   (load bool 0 res 0)
   (return)
   (label else%23)
   (load close-deep 5 tmp 0)
   (new-vec 1)
   (move 4 0 vec 0)
   (call lib 34 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%25)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 34 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%25)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%4)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%26)
   (move 0 0 res 0)
   (return)
   (label else%26)
   (new-vec 2)
   (move 8 0 vec 0)
   (move 1 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 8 1 vec 0)
   (move 1 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%27)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)
   (label else%27)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%5)
   (jump-if-false 0 0 else%28)
   (new-vec 1)
   (move 5 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 6 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%29)
   (new-vec 1)
   (extend)
   (load close-deep 6 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%29)
   (load bool 0 res 0)
   (return)
   (label else%28)
   (load close-deep 7 tmp 0)
   (new-vec 1)
   (move 5 0 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%30)
   (new-vec 1)
   (move 5 1 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%30)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%6)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%31)
   (move 0 0 res 0)
   (return)
   (label else%31)
   (new-vec 2)
   (move 9 0 vec 0)
   (move 1 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 9 1 vec 0)
   (move 1 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%32)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)
   (label else%32)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%7)
   (jump-if-false 0 0 else%33)
   (load close-deep 8 tmp 0)
   (new-vec 1)
   (move 6 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%34)
   (new-vec 1)
   (move 6 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%34)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%33)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%8)
   (jump-if-false 0 0 else%35)
   (new-vec 1)
   (move 7 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 7 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 0)
   (label else%35)
   (new-vec 1)
   (move 7 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 7 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%36)
   (new-vec 1)
   (move 7 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 7 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 0)
   (label else%36)
   (load bool 0 res 0)
   (return))
  "DAIMI-Scheme compiler, 03-10-22")
