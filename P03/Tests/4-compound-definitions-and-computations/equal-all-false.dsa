(DAIMI-SchemeE03
  (4 12 1)
  ((2 lambda-deep%0)
   (2 lambda-flat%1)
   (1 lambda-deep%2)
   (1 lambda-deep%3)
   (1 lambda-deep%4)
   (1 lambda-deep%5)
   (1 lambda-deep%6)
   (1 lambda-deep%7)
   (1 lambda-deep%8))
  ((new-vec 2)
   (load sym c vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym b vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym e vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym a vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 0)
   (new-vec 2)
   (load sym c vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym b vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym d vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym a vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (new-vec 2)
   (load nil _ vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym quote vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 2)
   (load close-deep 0 glo 3)
   (new-vec 2)
   (load nil _ vec 0)
   (move glo 2 vec 1)
   (call glo 3 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 42 vec 0)
   (load int 44 vec 1)
   (call glo 3 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load bool 1 vec 0)
   (load bool 0 vec 1)
   (call glo 3 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load str "foo" vec 0)
   (load str "bar" vec 1)
   (call glo 3 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load sym bar vec 0)
   (load sym baz vec 1)
   (call glo 3 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (load str "buz" vec 0)
   (call lib 23 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (load sym baz vec 0)
   (move tmp 5 vec 1)
   (call glo 3 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (move lib 27 vec 0)
   (move lib 28 vec 1)
   (call glo 3 6)
   (move res 0 tmp 6)
   (new-vec 0)
   (load close-flat 1 tmp 7)
   (new-vec 2)
   (move glo 3 vec 0)
   (move tmp 7 vec 1)
   (call glo 3 7)
   (move res 0 tmp 7)
   (new-vec 2)
   (move glo 1 vec 0)
   (move glo 0 vec 1)
   (call glo 3 8)
   (move res 0 tmp 8)
   (new-vec 4)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (load int 4 vec 3)
   (call lib 32 9)
   (move res 0 tmp 9)
   (new-vec 3)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (call lib 32 10)
   (move res 0 tmp 10)
   (new-vec 2)
   (move tmp 9 vec 0)
   (move tmp 10 vec 1)
   (call glo 3 9)
   (move res 0 tmp 9)
   (new-vec 5)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (load int 4 vec 3)
   (load int 5 vec 4)
   (call lib 32 10)
   (move res 0 tmp 10)
   (new-vec 5)
   (load int 1 vec 0)
   (load int 2 vec 1)
   (load int 3 vec 2)
   (load int 4 vec 3)
   (load int 6 vec 4)
   (call lib 32 11)
   (move res 0 tmp 11)
   (new-vec 2)
   (move tmp 10 vec 0)
   (move tmp 11 vec 1)
   (call glo 3 10)
   (move res 0 tmp 10)
   (new-vec 2)
   (load str "hello world" vec 0)
   (load str "hello world!" vec 1)
   (call glo 3 11)
   (move res 0 tmp 11)
   (new-vec 12)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (move tmp 4 vec 4)
   (move tmp 5 vec 5)
   (move tmp 6 vec 6)
   (move tmp 7 vec 7)
   (move tmp 8 vec 8)
   (move tmp 9 vec 9)
   (move tmp 10 vec 10)
   (move tmp 11 vec 11)
   (tail-call lib 32)

   (label lambda-deep%0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%21)
   (move 0 0 res 0)
   (return)
   (label else%21)
   (load close-deep 2 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 0 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%22)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 0 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%22)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 3)

   (label lambda-deep%2)
   (jump-if-false 0 0 else%23)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 8)
   (label else%23)
   (load close-deep 3 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 13 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%24)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 13 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%24)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%3)
   (jump-if-false 0 0 else%25)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 8)
   (label else%25)
   (load close-deep 4 tmp 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 18 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%26)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 18 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%26)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%4)
   (jump-if-false 0 0 else%27)
   (new-vec 1)
   (move 4 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 5 1 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%28)
   (new-vec 1)
   (extend)
   (load close-deep 5 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%28)
   (load bool 0 res 0)
   (return)
   (label else%27)
   (load close-deep 6 tmp 0)
   (new-vec 1)
   (move 4 0 vec 0)
   (call lib 34 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%29)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 34 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%29)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%5)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%30)
   (move 0 0 res 0)
   (return)
   (label else%30)
   (new-vec 2)
   (move 8 0 vec 0)
   (move 1 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 8 1 vec 0)
   (move 1 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 3 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%31)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)
   (label else%31)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%6)
   (jump-if-false 0 0 else%32)
   (new-vec 1)
   (move 5 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 6 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%33)
   (new-vec 1)
   (extend)
   (load close-deep 7 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%33)
   (load bool 0 res 0)
   (return)
   (label else%32)
   (load close-deep 8 tmp 0)
   (new-vec 1)
   (move 5 0 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%34)
   (new-vec 1)
   (move 5 1 vec 0)
   (call lib 25 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%34)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%7)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%35)
   (move 0 0 res 0)
   (return)
   (label else%35)
   (new-vec 2)
   (move 9 0 vec 0)
   (move 1 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 9 1 vec 0)
   (move 1 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 3 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%36)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)
   (label else%36)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%8)
   (jump-if-false 0 0 else%37)
   (new-vec 1)
   (move 6 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 6 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 3 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%38)
   (new-vec 1)
   (move 6 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 6 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 3)
   (label else%38)
   (load bool 0 res 0)
   (return)
   (label else%37)
   (load bool 0 res 0)
   (return))
  "DAIMI-Scheme compiler, 03-10-22")
