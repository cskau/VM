(DAIMI-SchemeE03
  (1 1 1)
  ((1 lambda-deep%0))
  ((load close-deep 0 glo 0)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%7)
   (move 0 0 res 0)
   (return)
   (label else%7)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 1 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%8)
   (move 0 0 res 0)
   (return)
   (label else%8)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%9)
   (move 0 0 res 0)
   (return)
   (label else%9)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%10)
   (move 0 0 res 0)
   (return)
   (label else%10)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 2 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%11)
   (move 0 0 res 0)
   (return)
   (label else%11)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 3 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%12)
   (move 0 0 res 0)
   (return)
   (label else%12)
   (new-vec 2)
   (load int 2 vec 0)
   (load int 3 vec 1)
   (tail-call lib 10)

   (label lambda-deep%0)
   (jump-if-false 0 0 else%13)
   (load bool 0 res 0)
   (return)
   (label else%13)
   (load bool 1 res 0)
   (return))
  "DAIMI-Scheme compiler, 03-10-22")
