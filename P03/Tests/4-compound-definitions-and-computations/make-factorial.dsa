(DAIMI-SchemeE03
  (2 3 1)
  ((-1 lambda-deep%0)
   (1 lambda-deep%1))
  ((load close-deep 0 glo 0)
   (load close-deep 1 glo 1)
   (new-vec 1)
   (load sym x vec 0)
   (tail-call glo 1)

   (label lambda-deep%0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym zero? vec 0)
   (move 0 0 vec 1)
   (call glo 0 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load sym - vec 0)
   (move 0 0 vec 1)
   (load int 1 vec 2)
   (call glo 0 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load sym factorial vec 0)
   (move tmp 2 vec 1)
   (call glo 0 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (load sym * vec 0)
   (move 0 0 vec 1)
   (move tmp 2 vec 2)
   (call glo 0 2)
   (move res 0 tmp 2)
   (new-vec 4)
   (load sym if vec 0)
   (move tmp 1 vec 1)
   (load int 1 vec 2)
   (move tmp 2 vec 3)
   (call glo 0 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load sym lambda vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (call glo 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym define vec 0)
   (load sym factorial vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 0))
  "DAIMI-Scheme compiler, 03-10-22")
