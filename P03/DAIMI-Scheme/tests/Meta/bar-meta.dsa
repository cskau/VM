(DAIMI-SchemeE03
  (510 55 1)
  ((1 lambda-deep%0)
   (2 lambda-deep%1)
   (2 lambda-deep%2)
   (2 lambda-deep%3)
   (2 lambda-deep%4)
   (-1 lambda-deep%5)
   (1 lambda-deep%6)
   (1 lambda-deep%7)
   (1 lambda-deep%8)
   (2 lambda-deep%9)
   (-1 lambda-deep%10)
   (1 lambda-deep%11)
   (1 lambda-deep%12)
   (1 lambda-deep%13)
   (2 lambda-deep%14)
   (2 lambda-deep%15)
   (3 lambda-deep%16)
   (2 lambda-deep%17)
   (2 lambda-deep%18)
   (2 lambda-deep%19)
   (2 lambda-deep%20)
   (1 lambda-deep%21)
   (1 lambda-deep%22)
   (1 lambda-deep%23)
   (1 lambda-deep%24)
   (1 lambda-deep%25)
   (1 lambda-deep%26)
   (1 lambda-deep%27)
   (2 lambda-deep%28)
   (2 lambda-deep%29)
   (2 lambda-deep%30)
   (2 lambda-deep%31)
   (-1 lambda-deep%32)
   (-1 lambda-deep%33)
   (2 lambda-deep%34)
   (-1 lambda-deep%35)
   (3 lambda-deep%36)
   (3 lambda-deep%37)
   (3 lambda-deep%38)
   (3 lambda-deep%39)
   (-1 lambda-deep%40)
   (-1 lambda-deep%41)
   (3 lambda-deep%42)
   (2 lambda-deep%43)
   (3 lambda-deep%44)
   (2 lambda-deep%45)
   (1 lambda-deep%46)
   (1 lambda-deep%47)
   (1 lambda-deep%48)
   (1 lambda-deep%49)
   (1 lambda-deep%50)
   (1 lambda-deep%51)
   (1 lambda-deep%52)
   (2 lambda-deep%53)
   (1 lambda-deep%54)
   (2 lambda-deep%55)
   (2 lambda-deep%56)
   (2 lambda-deep%57)
   (1 lambda-deep%58)
   (1 lambda-deep%59)
   (2 lambda-deep%60)
   (3 lambda-deep%61)
   (2 lambda-deep%62)
   (1 lambda-deep%63)
   (1 lambda-deep%64)
   (1 lambda-deep%65)
   (1 lambda-deep%66)
   (1 lambda-deep%67)
   (1 lambda-deep%68)
   (1 lambda-deep%69)
   (-1 lambda-deep%70)
   (1 lambda-deep%71)
   (1 lambda-deep%72)
   (1 lambda-deep%73)
   (1 lambda-deep%74)
   (1 lambda-deep%75)
   (1 lambda-deep%76)
   (1 lambda-deep%77)
   (2 lambda-deep%78)
   (2 lambda-deep%79)
   (-1 lambda-deep%80)
   (3 lambda-deep%81)
   (3 lambda-deep%82)
   (3 lambda-deep%83)
   (3 lambda-deep%84)
   (3 lambda-deep%85)
   (3 lambda-deep%86)
   (3 lambda-deep%87)
   (2 lambda-deep%88)
   (2 lambda-deep%89)
   (3 lambda-deep%90)
   (-1 lambda-deep%91)
   (2 lambda-deep%92)
   (-1 lambda-deep%93)
   (2 lambda-deep%94)
   (-1 lambda-deep%95)
   (1 lambda-deep%96)
   (-1 lambda-deep%97)
   (3 lambda-deep%98)
   (2 lambda-deep%99)
   (2 lambda-deep%100)
   (1 lambda-deep%101)
   (1 lambda-deep%102)
   (0 lambda-deep%103)
   (1 lambda-deep%104)
   (1 lambda-deep%105)
   (1 lambda-deep%106)
   (2 lambda-deep%107)
   (1 lambda-deep%108)
   (2 lambda-deep%109)
   (1 lambda-deep%110)
   (2 lambda-deep%111)
   (1 lambda-deep%112)
   (1 lambda-deep%113)
   (1 lambda-deep%114)
   (1 lambda-deep%115)
   (1 lambda-deep%116)
   (2 lambda-deep%117)
   (1 lambda-deep%118)
   (3 lambda-deep%119)
   (1 lambda-deep%120)
   (2 lambda-deep%121)
   (1 lambda-deep%122)
   (2 lambda-deep%123)
   (1 lambda-deep%124)
   (2 lambda-deep%125)
   (1 lambda-deep%126)
   (3 lambda-deep%127)
   (1 lambda-deep%128)
   (3 lambda-deep%129)
   (1 lambda-deep%130)
   (1 lambda-deep%131)
   (1 lambda-deep%132)
   (1 lambda-deep%133)
   (1 lambda-deep%134)
   (3 lambda-deep%135)
   (1 lambda-deep%136)
   (3 lambda-deep%137)
   (1 lambda-deep%138)
   (3 lambda-deep%139)
   (1 lambda-deep%140)
   (1 lambda-deep%141)
   (1 lambda-deep%142)
   (1 lambda-deep%143)
   (1 lambda-deep%144)
   (1 lambda-deep%145)
   (1 lambda-deep%146)
   (1 lambda-deep%147)
   (1 lambda-deep%148)
   (1 lambda-deep%149)
   (1 lambda-deep%150)
   (1 lambda-deep%151)
   (1 lambda-deep%152)
   (1 lambda-deep%153)
   (1 lambda-deep%154)
   (1 lambda-deep%155)
   (1 lambda-deep%156)
   (1 lambda-deep%157)
   (1 lambda-deep%158)
   (0 lambda-deep%159)
   (1 lambda-deep%160)
   (0 lambda-deep%161)
   (1 lambda-deep%162)
   (1 lambda-deep%163)
   (1 lambda-deep%164)
   (1 lambda-deep%165)
   (1 lambda-deep%166)
   (2 lambda-deep%167)
   (1 lambda-deep%168)
   (1 lambda-deep%169)
   (1 lambda-deep%170)
   (1 lambda-deep%171)
   (1 lambda-deep%172)
   (1 lambda-deep%173)
   (1 lambda-deep%174)
   (1 lambda-deep%175)
   (1 lambda-deep%176)
   (1 lambda-deep%177)
   (1 lambda-deep%178)
   (1 lambda-deep%179)
   (1 lambda-deep%180)
   (1 lambda-deep%181)
   (1 lambda-deep%182)
   (1 lambda-deep%183)
   (1 lambda-deep%184)
   (1 lambda-deep%185)
   (1 lambda-deep%186)
   (1 lambda-deep%187)
   (1 lambda-deep%188)
   (1 lambda-deep%189)
   (3 lambda-deep%190)
   (1 lambda-deep%191)
   (2 lambda-deep%192)
   (1 lambda-deep%193)
   (2 lambda-deep%194)
   (1 lambda-deep%195)
   (1 lambda-deep%196)
   (1 lambda-deep%197)
   (1 lambda-deep%198)
   (2 lambda-deep%199)
   (1 lambda-deep%200)
   (3 lambda-deep%201)
   (1 lambda-deep%202)
   (3 lambda-deep%203)
   (2 lambda-deep%204)
   (1 lambda-deep%205)
   (1 lambda-deep%206)
   (1 lambda-deep%207)
   (2 lambda-deep%208)
   (1 lambda-deep%209)
   (3 lambda-deep%210)
   (1 lambda-deep%211)
   (1 lambda-deep%212)
   (1 lambda-deep%213)
   (4 lambda-deep%214)
   (1 lambda-deep%215)
   (1 lambda-deep%216)
   (1 lambda-deep%217)
   (1 lambda-deep%218)
   (1 lambda-deep%219)
   (2 lambda-deep%220)
   (2 lambda-deep%221)
   (2 lambda-deep%222)
   (1 lambda-deep%223)
   (2 lambda-deep%224)
   (1 lambda-deep%225)
   (2 lambda-deep%226)
   (1 lambda-deep%227)
   (1 lambda-deep%228)
   (1 lambda-deep%229)
   (1 lambda-deep%230)
   (1 lambda-deep%231)
   (1 lambda-deep%232)
   (1 lambda-deep%233)
   (1 lambda-deep%234)
   (1 lambda-deep%235)
   (2 lambda-deep%236)
   (1 lambda-deep%237)
   (3 lambda-deep%238)
   (1 lambda-deep%239)
   (2 lambda-deep%240)
   (1 lambda-deep%241)
   (3 lambda-deep%242)
   (1 lambda-deep%243)
   (2 lambda-deep%244)
   (1 lambda-deep%245)
   (2 lambda-deep%246)
   (1 lambda-deep%247)
   (2 lambda-deep%248)
   (1 lambda-deep%249)
   (3 lambda-deep%250)
   (1 lambda-deep%251)
   (3 lambda-deep%252)
   (1 lambda-deep%253)
   (1 lambda-deep%254)
   (1 lambda-deep%255)
   (3 lambda-deep%256)
   (1 lambda-deep%257)
   (3 lambda-deep%258)
   (1 lambda-deep%259)
   (1 lambda-deep%260)
   (2 lambda-deep%261)
   (3 lambda-deep%262)
   (4 lambda-deep%263)
   (3 lambda-deep%264)
   (3 lambda-deep%265)
   (4 lambda-deep%266)
   (4 lambda-deep%267)
   (5 lambda-deep%268)
   (3 lambda-deep%269)
   (1 lambda-deep%270)
   (2 lambda-deep%271)
   (1 lambda-deep%272)
   (2 lambda-deep%273)
   (1 lambda-deep%274)
   (2 lambda-deep%275)
   (1 lambda-deep%276)
   (1 lambda-deep%277)
   (1 lambda-deep%278)
   (3 lambda-deep%279)
   (1 lambda-deep%280)
   (1 lambda-deep%281)
   (1 lambda-deep%282)
   (1 lambda-deep%283)
   (1 lambda-deep%284)
   (2 lambda-deep%285)
   (1 lambda-deep%286)
   (3 lambda-deep%287)
   (1 lambda-deep%288)
   (3 lambda-deep%289)
   (1 lambda-deep%290)
   (2 lambda-deep%291)
   (1 lambda-deep%292)
   (3 lambda-deep%293)
   (1 lambda-deep%294)
   (2 lambda-deep%295)
   (1 lambda-deep%296)
   (2 lambda-deep%297)
   (1 lambda-deep%298)
   (2 lambda-deep%299)
   (1 lambda-deep%300)
   (3 lambda-deep%301)
   (1 lambda-deep%302)
   (3 lambda-deep%303)
   (1 lambda-deep%304)
   (1 lambda-deep%305)
   (1 lambda-deep%306)
   (3 lambda-deep%307)
   (1 lambda-deep%308)
   (3 lambda-deep%309)
   (1 lambda-deep%310)
   (3 lambda-deep%311)
   (2 lambda-deep%312)
   (2 lambda-deep%313)
   (3 lambda-deep%314)
   (3 lambda-deep%315)
   (3 lambda-deep%316)
   (4 lambda-deep%317)
   (3 lambda-deep%318)
   (1 lambda-deep%319)
   (4 lambda-deep%320)
   (1 lambda-deep%321)
   (2 lambda-deep%322)
   (1 lambda-deep%323)
   (1 lambda-deep%324)
   (1 lambda-deep%325)
   (3 lambda-deep%326)
   (1 lambda-deep%327)
   (1 lambda-deep%328)
   (1 lambda-deep%329)
   (1 lambda-deep%330)
   (1 lambda-deep%331)
   (2 lambda-deep%332)
   (1 lambda-deep%333)
   (1 lambda-deep%334)
   (1 lambda-deep%335)
   (2 lambda-deep%336)
   (1 lambda-deep%337)
   (3 lambda-deep%338)
   (1 lambda-deep%339)
   (2 lambda-deep%340)
   (1 lambda-deep%341)
   (3 lambda-deep%342)
   (1 lambda-deep%343)
   (2 lambda-deep%344)
   (1 lambda-deep%345)
   (2 lambda-deep%346)
   (1 lambda-deep%347)
   (2 lambda-deep%348)
   (1 lambda-deep%349)
   (3 lambda-deep%350)
   (1 lambda-deep%351)
   (3 lambda-deep%352)
   (1 lambda-deep%353)
   (1 lambda-deep%354)
   (1 lambda-deep%355)
   (3 lambda-deep%356)
   (1 lambda-deep%357)
   (3 lambda-deep%358)
   (1 lambda-deep%359)
   (1 lambda-deep%360)
   (1 lambda-deep%361)
   (1 lambda-deep%362)
   (1 lambda-deep%363)
   (1 lambda-deep%364)
   (1 lambda-deep%365)
   (1 lambda-deep%366)
   (1 lambda-deep%367)
   (1 lambda-deep%368)
   (1 lambda-deep%369)
   (0 lambda-deep%370)
   (1 lambda-deep%371)
   (0 lambda-deep%372)
   (1 lambda-deep%373)
   (4 lambda-deep%374)
   (4 lambda-deep%375)
   (4 lambda-deep%376)
   (4 lambda-deep%377)
   (4 lambda-deep%378)
   (3 lambda-deep%379)
   (1 lambda-deep%380)
   (6 lambda-deep%381)
   (1 lambda-deep%382)
   (2 lambda-deep%383)
   (2 lambda-deep%384)
   (2 lambda-deep%385)
   (1 lambda-deep%386)
   (2 lambda-deep%387)
   (3 lambda-deep%388)
   (1 lambda-deep%389)
   (1 lambda-deep%390)
   (1 lambda-deep%391)
   (1 lambda-deep%392)
   (2 lambda-deep%393)
   (0 lambda-deep%394)
   (1 lambda-deep%395)
   (0 lambda-deep%396)
   (1 lambda-deep%397)
   (0 lambda-deep%398)
   (1 lambda-deep%399)
   (1 lambda-deep%400)
   (1 lambda-deep%401)
   (1 lambda-deep%402)
   (1 lambda-deep%403)
   (1 lambda-deep%404)
   (1 lambda-deep%405)
   (1 lambda-deep%406)
   (1 lambda-deep%407)
   (3 lambda-deep%408)
   (1 lambda-deep%409)
   (3 lambda-deep%410)
   (1 lambda-deep%411)
   (1 lambda-deep%412)
   (1 lambda-deep%413)
   (2 lambda-deep%414)
   (1 lambda-deep%415)
   (1 lambda-deep%416)
   (1 lambda-deep%417)
   (1 lambda-deep%418)
   (1 lambda-deep%419)
   (1 lambda-deep%420)
   (1 lambda-deep%421)
   (0 lambda-deep%422)
   (1 lambda-deep%423)
   (0 lambda-deep%424)
   (1 lambda-deep%425)
   (0 lambda-deep%426)
   (1 lambda-deep%427)
   (1 lambda-deep%428)
   (3 lambda-deep%429)
   (4 lambda-deep%430)
   (3 lambda-deep%431)
   (3 lambda-deep%432)
   (3 lambda-deep%433)
   (1 lambda-deep%434)
   (2 lambda-deep%435)
   (1 lambda-deep%436)
   (1 lambda-deep%437)
   (1 lambda-deep%438)
   (1 lambda-deep%439)
   (1 lambda-deep%440)
   (1 lambda-deep%441)
   (1 lambda-deep%442)
   (1 lambda-deep%443)
   (2 lambda-flat%444)
   (2 lambda-flat%445)
   (2 lambda-flat%446)
   (2 lambda-flat%447)
   (2 lambda-flat%448)
   (2 lambda-flat%449)
   (2 lambda-flat%450)
   (2 lambda-flat%451)
   (2 lambda-flat%452)
   (2 lambda-flat%453)
   (2 lambda-flat%454)
   (2 lambda-flat%455)
   (2 lambda-flat%456)
   (2 lambda-flat%457)
   (2 lambda-flat%458)
   (2 lambda-flat%459)
   (2 lambda-flat%460)
   (2 lambda-flat%461)
   (2 lambda-flat%462)
   (2 lambda-flat%463)
   (2 lambda-flat%464)
   (2 lambda-flat%465)
   (2 lambda-flat%466)
   (2 lambda-flat%467)
   (2 lambda-flat%468)
   (2 lambda-flat%469)
   (2 lambda-flat%470)
   (2 lambda-flat%471)
   (2 lambda-flat%472)
   (2 lambda-flat%473)
   (2 lambda-flat%474)
   (2 lambda-flat%475)
   (2 lambda-flat%476)
   (2 lambda-flat%477)
   (2 lambda-flat%478)
   (2 lambda-flat%479)
   (2 lambda-flat%480)
   (2 lambda-flat%481)
   (2 lambda-flat%482)
   (2 lambda-flat%483)
   (2 lambda-flat%484)
   (2 lambda-flat%485)
   (2 lambda-flat%486)
   (2 lambda-flat%487)
   (2 lambda-flat%488)
   (2 lambda-flat%489)
   (2 lambda-flat%490)
   (2 lambda-flat%491)
   (2 lambda-flat%492)
   (2 lambda-flat%493)
   (2 lambda-flat%494)
   (2 lambda-flat%495)
   (2 lambda-flat%496)
   (3 lambda-deep%497)
   (1 lambda-deep%498)
   (2 lambda-deep%499)
   (2 lambda-deep%500)
   (2 lambda-deep%501)
   (0 lambda-deep%502)
   (4 lambda-deep%503)
   (1 lambda-deep%504)
   (0 lambda-deep%505)
   (1 lambda-deep%506)
   (0 lambda-deep%507)
   (1 lambda-deep%508)
   (1 lambda-deep%509)
   (1 lambda-deep%510)
   (1 lambda-deep%511)
   (1 lambda-deep%512)
   (1 lambda-deep%513)
   (1 lambda-deep%514)
   (1 lambda-flat%515)
   (2 lambda-flat%516)
   (1 lambda-deep%517)
   (1 lambda-flat%518)
   (2 lambda-deep%519)
   (3 lambda-deep%520)
   (1 lambda-deep%521)
   (2 lambda-deep%522)
   (2 lambda-deep%523)
   (2 lambda-deep%524)
   (2 lambda-deep%525)
   (2 lambda-deep%526)
   (1 lambda-deep%527)
   (1 lambda-deep%528)
   (1 lambda-flat%529)
   (1 lambda-deep%530)
   (1 lambda-deep%531)
   (1 lambda-deep%532)
   (1 lambda-deep%533)
   (1 lambda-deep%534)
   (1 lambda-deep%535)
   (1 lambda-deep%536)
   (1 lambda-deep%537)
   (1 lambda-deep%538)
   (2 lambda-deep%539)
   (1 lambda-deep%540)
   (2 lambda-deep%541)
   (1 lambda-deep%542)
   (2 lambda-deep%543)
   (1 lambda-deep%544)
   (1 lambda-flat%545)
   (1 lambda-flat%546)
   (1 lambda-deep%547)
   (2 lambda-deep%548)
   (1 lambda-deep%549)
   (1 lambda-deep%550)
   (1 lambda-deep%551)
   (2 lambda-deep%552)
   (2 lambda-deep%553)
   (1 lambda-deep%554)
   (1 lambda-deep%555)
   (2 lambda-deep%556)
   (1 lambda-deep%557)
   (1 lambda-deep%558)
   (1 lambda-deep%559)
   (2 lambda-deep%560)
   (1 lambda-deep%561)
   (1 lambda-deep%562)
   (0 lambda-deep%563)
   (0 lambda-deep%564)
   (1 lambda-flat%565)
   (1 lambda-flat%566)
   (1 lambda-flat%567)
   (1 lambda-deep%568)
   (1 lambda-flat%569)
   (1 lambda-flat%570)
   (1 lambda-deep%571)
   (1 lambda-deep%572)
   (1 lambda-deep%573)
   (1 lambda-flat%574)
   (1 lambda-deep%575)
   (1 lambda-flat%576)
   (1 lambda-flat%577)
   (1 lambda-deep%578)
   (-1 lambda-flat%579)
   (1 lambda-deep%580)
   (1 lambda-deep%581)
   (2 lambda-flat%582)
   (2 lambda-deep%583)
   (1 lambda-flat%584)
   (1 lambda-flat%585)
   (1 lambda-flat%586)
   (1 lambda-flat%587)
   (1 lambda-flat%588)
   (1 lambda-flat%589)
   (1 lambda-deep%590)
   (2 lambda-deep%591)
   (1 lambda-flat%592)
   (3 lambda-flat%593)
   (2 lambda-deep%594)
   (1 lambda-deep%595)
   (1 lambda-deep%596)
   (1 lambda-flat%597)
   (1 lambda-deep%598)
   (1 lambda-flat%599)
   (4 lambda-deep%600)
   (4 lambda-deep%601)
   (4 lambda-deep%602)
   (2 lambda-flat%603)
   (2 lambda-deep%604)
   (2 lambda-deep%605)
   (3 lambda-deep%606)
   (3 lambda-deep%607)
   (1 lambda-deep%608)
   (1 lambda-flat%609)
   (0 lambda-flat%610)
   (0 lambda-flat%611)
   (2 lambda-flat%612)
   (2 lambda-flat%613)
   (1 lambda-flat%614)
   (2 lambda-flat%615)
   (0 lambda-flat%616)
   (0 lambda-flat%617)
   (0 lambda-flat%618)
   (2 lambda-flat%619)
   (2 lambda-flat%620)
   (1 lambda-flat%621)
   (2 lambda-flat%622)
   (2 lambda-deep%623)
   (0 lambda-flat%624)
   (0 lambda-flat%625)
   (2 lambda-flat%626)
   (2 lambda-flat%627)
   (1 lambda-flat%628)
   (2 lambda-flat%629)
   (2 lambda-flat%630)
   (2 lambda-deep%631)
   (0 lambda-flat%632)
   (0 lambda-flat%633)
   (2 lambda-flat%634)
   (2 lambda-flat%635)
   (1 lambda-flat%636)
   (2 lambda-flat%637)
   (2 lambda-deep%638)
   (0 lambda-flat%639)
   (0 lambda-flat%640)
   (2 lambda-flat%641)
   (2 lambda-flat%642)
   (2 lambda-deep%643)
   (1 lambda-flat%644)
   (2 lambda-flat%645)
   (1 lambda-deep%646)
   (0 lambda-flat%647)
   (0 lambda-flat%648)
   (2 lambda-flat%649)
   (2 lambda-flat%650)
   (2 lambda-deep%651)
   (1 lambda-flat%652)
   (2 lambda-flat%653)
   (3 lambda-deep%654)
   (3 lambda-deep%655)
   (3 lambda-deep%656)
   (3 lambda-deep%657)
   (3 lambda-deep%658)
   (1 lambda-deep%659)
   (2 lambda-deep%660)
   (2 lambda-deep%661)
   (1 lambda-deep%662)
   (1 lambda-flat%663)
   (1 lambda-flat%664)
   (1 lambda-deep%665)
   (1 lambda-deep%666)
   (1 lambda-deep%667)
   (1 lambda-flat%668)
   (1 lambda-deep%669)
   (1 lambda-deep%670)
   (2 lambda-deep%671)
   (1 lambda-flat%672)
   (3 lambda-flat%673)
   (3 lambda-flat%674)
   (3 lambda-flat%675)
   (2 lambda-deep%676)
   (3 lambda-flat%677)
   (3 lambda-flat%678)
   (3 lambda-flat%679)
   (3 lambda-flat%680)
   (3 lambda-flat%681)
   (3 lambda-flat%682)
   (3 lambda-flat%683)
   (3 lambda-flat%684)
   (3 lambda-flat%685)
   (3 lambda-flat%686)
   (3 lambda-flat%687)
   (3 lambda-flat%688)
   (4 lambda-deep%689)
   (6 lambda-deep%690)
   (3 lambda-flat%691)
   (2 lambda-deep%692)
   (2 lambda-deep%693)
   (2 lambda-deep%694)
   (3 lambda-flat%695)
   (1 lambda-deep%696)
   (3 lambda-flat%697)
   (3 lambda-flat%698)
   (3 lambda-flat%699)
   (3 lambda-flat%700)
   (3 lambda-flat%701)
   (3 lambda-flat%702)
   (3 lambda-flat%703)
   (3 lambda-flat%704)
   (1 lambda-deep%705)
   (3 lambda-flat%706)
   (3 lambda-flat%707)
   (1 lambda-flat%708)
   (1 lambda-flat%709)
   (2 lambda-deep%710)
   (1 lambda-deep%711)
   (1 lambda-flat%712)
   (1 lambda-deep%713)
   (1 lambda-deep%714)
   (1 lambda-deep%715)
   (1 lambda-deep%716)
   (1 lambda-deep%717)
   (1 lambda-deep%718)
   (2 lambda-deep%719)
   (2 lambda-deep%720)
   (1 lambda-deep%721)
   (1 lambda-deep%722)
   (1 lambda-deep%723)
   (1 lambda-deep%724)
   (1 lambda-deep%725)
   (1 lambda-deep%726)
   (1 lambda-deep%727)
   (1 lambda-deep%728)
   (1 lambda-deep%729)
   (1 lambda-flat%730)
   (1 lambda-deep%731)
   (1 lambda-deep%732)
   (1 lambda-deep%733)
   (1 lambda-deep%734)
   (1 lambda-deep%735)
   (1 lambda-deep%736)
   (1 lambda-deep%737)
   (1 lambda-deep%738)
   (1 lambda-deep%739)
   (1 lambda-deep%740)
   (1 lambda-deep%741)
   (1 lambda-deep%742)
   (1 lambda-deep%743)
   (1 lambda-deep%744)
   (1 lambda-deep%745)
   (1 lambda-deep%746)
   (1 lambda-deep%747)
   (1 lambda-deep%748)
   (2 lambda-deep%749)
   (1 lambda-deep%750)
   (1 lambda-deep%751)
   (1 lambda-deep%752)
   (2 lambda-flat%753)
   (2 lambda-deep%754)
   (1 lambda-flat%755)
   (2 lambda-deep%756)
   (4 lambda-deep%757)
   (3 lambda-deep%758)
   (1 lambda-deep%759)
   (2 lambda-deep%760)
   (1 lambda-flat%761)
   (1 lambda-flat%762)
   (1 lambda-deep%763)
   (1 lambda-flat%764)
   (2 lambda-deep%765)
   (1 lambda-deep%766)
   (1 lambda-deep%767)
   (1 lambda-deep%768)
   (1 lambda-deep%769)
   (1 lambda-deep%770)
   (1 lambda-deep%771)
   (2 lambda-deep%772)
   (1 lambda-flat%773)
   (1 lambda-flat%774)
   (1 lambda-flat%775)
   (1 lambda-flat%776)
   (1 lambda-flat%777)
   (1 lambda-flat%778)
   (1 lambda-flat%779)
   (1 lambda-flat%780)
   (1 lambda-flat%781)
   (1 lambda-flat%782)
   (1 lambda-flat%783)
   (1 lambda-flat%784)
   (1 lambda-flat%785)
   (1 lambda-flat%786)
   (1 lambda-flat%787)
   (1 lambda-flat%788)
   (1 lambda-flat%789)
   (1 lambda-flat%790)
   (1 lambda-flat%791)
   (1 lambda-deep%792)
   (1 lambda-flat%793)
   (1 lambda-flat%794)
   (1 lambda-deep%795)
   (1 lambda-flat%796)
   (0 lambda-deep%797)
   (1 lambda-deep%798)
   (1 lambda-flat%799)
   (0 lambda-flat%800)
   (0 lambda-flat%801)
   (1 lambda-flat%802)
   (2 lambda-deep%803)
   (1 lambda-flat%804)
   (1 lambda-flat%805)
   (1 lambda-deep%806)
   (1 lambda-deep%807)
   (1 lambda-flat%808)
   (1 lambda-flat%809)
   (3 lambda-deep%810)
   (1 lambda-flat%811)
   (1 lambda-flat%812)
   (2 lambda-deep%813)
   (1 lambda-deep%814)
   (1 lambda-deep%815)
   (1 lambda-deep%816)
   (1 lambda-deep%817)
   (1 lambda-deep%818)
   (1 lambda-deep%819)
   (1 lambda-deep%820)
   (2 lambda-flat%821)
   (1 lambda-deep%822)
   (2 lambda-flat%823)
   (2 lambda-flat%824)
   (2 lambda-flat%825)
   (2 lambda-flat%826)
   (2 lambda-flat%827)
   (2 lambda-deep%828)
   (1 lambda-flat%829)
   (1 lambda-deep%830)
   (1 lambda-deep%831)
   (1 lambda-flat%832)
   (1 lambda-flat%833)
   (2 lambda-flat%834)
   (2 lambda-deep%835)
   (2 lambda-flat%836)
   (1 lambda-deep%837)
   (1 lambda-deep%838)
   (2 lambda-flat%839)
   (1 lambda-deep%840)
   (1 lambda-deep%841)
   (0 lambda-flat%842)
   (2 lambda-flat%843)
   (1 lambda-deep%844)
   (1 lambda-deep%845)
   (2 lambda-flat%846)
   (0 lambda-flat%847)
   (2 lambda-flat%848)
   (1 lambda-deep%849)
   (1 lambda-deep%850)
   (0 lambda-flat%851)
   (2 lambda-flat%852)
   (0 lambda-flat%853)
   (1 lambda-deep%854)
   (1 lambda-deep%855)
   (2 lambda-flat%856)
   (0 lambda-flat%857)
   (1 lambda-deep%858)
   (1 lambda-deep%859)
   (1 lambda-flat%860)
   (1 lambda-flat%861)
   (1 lambda-deep%862)
   (1 lambda-deep%863)
   (1 lambda-deep%864)
   (1 lambda-flat%865)
   (1 lambda-deep%866)
   (1 lambda-deep%867)
   (1 lambda-flat%868)
   (1 lambda-deep%869)
   (1 lambda-deep%870)
   (3 lambda-flat%871)
   (3 lambda-flat%872)
   (3 lambda-flat%873)
   (2 lambda-deep%874)
   (3 lambda-flat%875)
   (3 lambda-flat%876)
   (3 lambda-flat%877)
   (3 lambda-flat%878)
   (3 lambda-flat%879)
   (3 lambda-flat%880)
   (3 lambda-flat%881)
   (3 lambda-flat%882)
   (3 lambda-flat%883)
   (1 lambda-deep%884)
   (3 lambda-flat%885)
   (1 lambda-deep%886)
   (1 lambda-deep%887)
   (1 lambda-deep%888)
   (1 lambda-deep%889)
   (1 lambda-flat%890)
   (2 lambda-deep%891)
   (1 lambda-deep%892)
   (1 lambda-deep%893)
   (1 lambda-deep%894)
   (1 lambda-deep%895)
   (1 lambda-deep%896)
   (0 lambda-flat%897)
   (1 lambda-flat%898)
   (1 lambda-deep%899)
   (3 lambda-flat%900)
   (1 lambda-deep%901)
   (1 lambda-flat%902)
   (1 lambda-flat%903)
   (1 lambda-flat%904)
   (1 lambda-flat%905)
   (1 lambda-flat%906)
   (1 lambda-flat%907)
   (1 lambda-flat%908)
   (1 lambda-flat%909)
   (1 lambda-flat%910)
   (1 lambda-flat%911)
   (1 lambda-flat%912)
   (1 lambda-flat%913)
   (1 lambda-flat%914)
   (1 lambda-flat%915)
   (1 lambda-flat%916)
   (1 lambda-flat%917)
   (1 lambda-flat%918)
   (1 lambda-flat%919)
   (1 lambda-flat%920)
   (1 lambda-flat%921)
   (1 lambda-flat%922)
   (1 lambda-flat%923)
   (1 lambda-flat%924)
   (1 lambda-flat%925)
   (1 lambda-flat%926)
   (1 lambda-flat%927)
   (1 lambda-flat%928)
   (1 lambda-deep%929)
   (1 lambda-deep%930)
   (0 lambda-flat%931)
   (0 lambda-flat%932)
   (2 lambda-deep%933)
   (2 lambda-deep%934)
   (0 lambda-flat%935)
   (0 lambda-flat%936)
   (0 lambda-flat%937)
   (0 lambda-flat%938)
   (1 lambda-flat%939)
   (1 lambda-flat%940)
   (1 lambda-flat%941)
   (1 lambda-flat%942)
   (2 lambda-flat%943)
   (2 lambda-flat%944)
   (2 lambda-flat%945)
   (2 lambda-flat%946)
   (2 lambda-flat%947)
   (2 lambda-flat%948)
   (1 lambda-deep%949)
   (1 lambda-flat%950)
   (1 lambda-deep%951)
   (1 lambda-deep%952)
   (1 lambda-deep%953)
   (3 lambda-flat%954)
   (1 lambda-deep%955)
   (1 lambda-deep%956)
   (3 lambda-flat%957)
   (1 lambda-deep%958)
   (1 lambda-deep%959)
   (1 lambda-deep%960)
   (1 lambda-deep%961)
   (1 lambda-deep%962)
   (1 lambda-deep%963)
   (1 lambda-deep%964)
   (1 lambda-deep%965)
   (1 lambda-deep%966)
   (1 lambda-flat%967)
   (1 lambda-flat%968)
   (1 lambda-flat%969)
   (1 lambda-flat%970)
   (1 lambda-flat%971)
   (1 lambda-flat%972)
   (1 lambda-flat%973)
   (1 lambda-deep%974)
   (1 lambda-flat%975)
   (1 lambda-deep%976)
   (1 lambda-flat%977)
   (2 lambda-deep%978)
   (2 lambda-flat%979)
   (1 lambda-deep%980)
   (1 lambda-deep%981)
   (1 lambda-deep%982)
   (1 lambda-flat%983)
   (1 lambda-flat%984)
   (1 lambda-flat%985)
   (1 lambda-flat%986)
   (1 lambda-flat%987)
   (1 lambda-flat%988)
   (1 lambda-deep%989)
   (1 lambda-flat%990)
   (1 lambda-flat%991)
   (1 lambda-flat%992)
   (1 lambda-flat%993)
   (1 lambda-flat%994)
   (1 lambda-flat%995))
  ((new-vec 2)
   (load sym extend vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 0)
   (new-vec 2)
   (load sym extend vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 1)
   (new-vec 2)
   (load sym return vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 glo 2)
   (new-vec 2)
   (load int 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 3)
   (new-vec 2)
   (load sym quote vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym case-record vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym define-record vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym suspend vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym delay vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym begin vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym or vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym and vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym else vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym case vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym cond vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym letrec vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym let* vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym let vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym set! vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym if vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym lambda vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym define vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 4)
   (new-vec 2)
   (load sym write-char vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym current-output-port vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym close-output-port vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym output-port? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym open-output-file vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym eof-object? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym peek-char vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym read-char vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym current-input-port vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym close-input-port vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym input-port? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym open-input-file vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym exit vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym call/cc vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym eqv? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym apply vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym procedure? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym vector-set! vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym vector-ref vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym vector-length vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym vector? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym make-vector vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym vector vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym null? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym set-cdr! vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym set-car! vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym cdr vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym car vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym cons vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym pair? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym symbol->string vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string->symbol vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string-ref vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string=? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string-append vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string-length vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym make-string vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym string vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym integer->char vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym char->integer vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym char? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym symbol? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym boolean? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym > vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym >= vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym = vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym <= vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym < vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym remainder vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym quotient vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym * vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym - vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym + vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym integer? vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 glo 5)
   (load close-deep 0 glo 6)
   (load close-deep 1 glo 7)
   (load close-deep 2 glo 8)
   (load close-deep 3 glo 9)
   (load close-deep 4 glo 10)
   (load close-deep 5 glo 11)
   (load close-deep 6 glo 12)
   (load close-deep 7 glo 13)
   (load close-deep 8 glo 14)
   (load close-deep 9 glo 15)
   (load close-deep 10 glo 16)
   (load close-deep 11 glo 17)
   (load close-deep 12 glo 18)
   (load close-deep 13 glo 19)
   (load close-deep 14 glo 20)
   (load close-deep 15 glo 21)
   (load close-deep 16 glo 22)
   (load close-deep 17 glo 23)
   (load close-deep 18 glo 24)
   (load close-deep 19 glo 25)
   (load close-deep 20 glo 26)
   (load close-deep 21 glo 27)
   (load close-deep 22 glo 28)
   (load close-deep 23 glo 29)
   (load close-deep 24 glo 30)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 27 vec 1)
   (call glo 7 0)
   (move res 0 glo 31)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 27 vec 1)
   (call glo 7 0)
   (move res 0 glo 32)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 29 vec 1)
   (call glo 7 0)
   (move res 0 glo 33)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 29 vec 1)
   (call glo 7 0)
   (move res 0 glo 34)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 28 vec 1)
   (call glo 7 0)
   (move res 0 glo 35)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 28 vec 1)
   (call glo 7 0)
   (move res 0 glo 36)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 30 vec 1)
   (call glo 7 0)
   (move res 0 glo 37)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 30 vec 1)
   (call glo 7 0)
   (move res 0 glo 38)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 38 vec 1)
   (call glo 7 0)
   (move res 0 glo 39)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 38 vec 1)
   (call glo 7 0)
   (move res 0 glo 40)
   (new-vec 2)
   (move lib 27 vec 0)
   (move glo 40 vec 1)
   (call glo 7 0)
   (move res 0 glo 41)
   (new-vec 2)
   (move lib 28 vec 0)
   (move glo 40 vec 1)
   (call glo 7 0)
   (move res 0 glo 42)
   (load close-deep 25 glo 43)
   (load close-deep 26 glo 44)
   (load close-deep 27 glo 45)
   (load close-deep 28 glo 46)
   (load close-deep 29 glo 47)
   (load close-deep 30 glo 48)
   (load close-deep 31 glo 49)
   (load close-deep 32 glo 50)
   (load close-deep 33 glo 51)
   (load close-deep 34 glo 52)
   (load close-deep 35 glo 53)
   (load close-deep 36 glo 54)
   (load close-deep 37 glo 55)
   (load close-deep 38 glo 56)
   (load close-deep 39 glo 57)
   (load close-deep 40 glo 58)
   (load close-deep 41 glo 59)
   (load close-deep 42 glo 60)
   (load close-deep 43 glo 61)
   (load close-deep 44 glo 62)
   (load close-deep 45 glo 63)
   (load close-deep 46 glo 64)
   (move glo 64 glo 65)
   (load close-deep 47 glo 66)
   (move glo 66 glo 67)
   (load close-deep 48 glo 68)
   (load close-deep 49 glo 69)
   (load close-deep 50 glo 70)
   (load close-deep 51 glo 71)
   (load close-deep 52 glo 72)
   (load close-deep 53 glo 73)
   (load close-deep 54 glo 74)
   (load close-deep 55 glo 75)
   (load close-deep 56 glo 76)
   (load close-deep 57 glo 77)
   (new-vec 1)
   (load int 9 vec 0)
   (call lib 15 0)
   (move res 0 glo 78)
   (new-vec 1)
   (load int 10 vec 0)
   (call lib 15 0)
   (move res 0 glo 79)
   (new-vec 1)
   (load int 32 vec 0)
   (call lib 15 0)
   (move res 0 glo 80)
   (load close-deep 58 glo 81)
   (load close-deep 59 glo 82)
   (load close-deep 60 glo 83)
   (load close-deep 61 glo 84)
   (load close-deep 62 glo 85)
   (load close-deep 63 glo 86)
   (load close-deep 64 glo 87)
   (load close-deep 65 glo 88)
   (load close-deep 66 glo 89)
   (load close-deep 67 glo 90)
   (load close-deep 68 glo 91)
   (load close-deep 69 glo 92)
   (load close-deep 70 glo 93)
   (load close-deep 71 glo 94)
   (load close-deep 72 glo 95)
   (load close-deep 73 glo 96)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load char 57 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 74 glo 97)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 75 glo 98)
   (new-vec 1)
   (load char 48 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 76 glo 99)
   (load close-deep 77 glo 100)
   (load close-deep 78 glo 101)
   (load close-deep 79 glo 102)
   (load close-deep 80 glo 103)
   (load close-deep 81 glo 104)
   (load close-deep 82 glo 105)
   (load close-deep 83 glo 106)
   (load close-deep 84 glo 107)
   (load close-deep 85 glo 108)
   (load close-deep 86 glo 109)
   (load close-deep 87 glo 110)
   (load close-deep 88 glo 111)
   (load close-deep 89 glo 112)
   (load close-deep 90 glo 113)
   (load close-deep 91 glo 114)
   (load close-deep 92 glo 115)
   (load close-deep 93 glo 116)
   (load close-deep 94 glo 117)
   (load close-deep 95 glo 118)
   (load close-deep 96 glo 119)
   (load close-deep 97 glo 120)
   (load close-deep 98 glo 121)
   (load close-deep 99 glo 122)
   (move lib 41 glo 123)
   (load close-deep 100 glo 124)
   (load close-deep 101 glo 125)
   (load close-deep 102 glo 126)
   (new-vec 1)
   (move lib 40 vec 0)
   (call glo 126 0)
   (move res 0 glo 127)
   (new-vec 1)
   (move glo 9 vec 0)
   (call glo 126 0)
   (move res 0 glo 128)
   (load str "DAIMI-Scheme compiler, 03-10-12" glo 129)
   (move glo 5 glo 130)
   (load int -1 glo 131)
   (load close-deep 103 glo 132)
   (load close-deep 104 glo 133)
   (load close-deep 105 glo 134)
   (load close-deep 106 glo 135)
   (load close-deep 107 glo 136)
   (load close-deep 108 glo 137)
   (load close-deep 109 glo 138)
   (load close-deep 110 glo 139)
   (load close-deep 111 glo 140)
   (load close-deep 112 glo 141)
   (load close-deep 113 glo 142)
   (load close-deep 114 glo 143)
   (load close-deep 115 glo 144)
   (load close-deep 116 glo 145)
   (load close-deep 117 glo 146)
   (load close-deep 118 glo 147)
   (load close-deep 119 glo 148)
   (load close-deep 120 glo 149)
   (load close-deep 121 glo 150)
   (load close-deep 122 glo 151)
   (load close-deep 123 glo 152)
   (load close-deep 124 glo 153)
   (load close-deep 125 glo 154)
   (load close-deep 126 glo 155)
   (load close-deep 127 glo 156)
   (load close-deep 128 glo 157)
   (load close-deep 129 glo 158)
   (load close-deep 130 glo 159)
   (load close-deep 131 glo 160)
   (load close-deep 132 glo 161)
   (load close-deep 133 glo 162)
   (load close-deep 134 glo 163)
   (load close-deep 135 glo 164)
   (load close-deep 136 glo 165)
   (load close-deep 137 glo 166)
   (load close-deep 138 glo 167)
   (load close-deep 139 glo 168)
   (load close-deep 140 glo 169)
   (load close-deep 141 glo 170)
   (load close-deep 142 glo 171)
   (load close-deep 143 glo 172)
   (load close-deep 144 glo 173)
   (load close-deep 145 glo 174)
   (load close-deep 146 glo 175)
   (load close-deep 147 glo 176)
   (load close-deep 148 glo 177)
   (load close-deep 149 glo 178)
   (load close-deep 150 glo 179)
   (load close-deep 151 glo 180)
   (load close-deep 152 glo 181)
   (load close-deep 153 glo 182)
   (load close-deep 154 glo 183)
   (load close-deep 155 glo 184)
   (load close-deep 156 glo 185)
   (load close-deep 157 glo 186)
   (load close-deep 158 glo 187)
   (load close-deep 159 glo 188)
   (load close-deep 160 glo 189)
   (load close-deep 161 glo 190)
   (load close-deep 162 glo 191)
   (load close-deep 163 glo 192)
   (load close-deep 164 glo 193)
   (load close-deep 165 glo 194)
   (load close-deep 166 glo 195)
   (load close-deep 167 glo 196)
   (load close-deep 168 glo 197)
   (load close-deep 169 glo 198)
   (load close-deep 170 glo 199)
   (load close-deep 171 glo 200)
   (load close-deep 172 glo 201)
   (load close-deep 173 glo 202)
   (load close-deep 174 glo 203)
   (load close-deep 175 glo 204)
   (load close-deep 176 glo 205)
   (move glo 205 glo 206)
   (load close-deep 177 glo 207)
   (load close-deep 178 glo 208)
   (load close-deep 179 glo 209)
   (load close-deep 180 glo 210)
   (load close-deep 181 glo 211)
   (load close-deep 182 glo 212)
   (load close-deep 183 glo 213)
   (load close-deep 184 glo 214)
   (load close-deep 185 glo 215)
   (load close-deep 186 glo 216)
   (load close-deep 187 glo 217)
   (load close-deep 188 glo 218)
   (load close-deep 189 glo 219)
   (new-vec 1)
   (extend)
   (load close-deep 190 0 0)
   (load close-deep 191 glo 220)
   (load close-deep 192 glo 221)
   (load close-deep 193 glo 222)
   (load close-deep 194 glo 223)
   (load close-deep 195 glo 224)
   (load close-deep 196 glo 225)
   (load close-deep 197 glo 226)
   (load close-deep 198 glo 227)
   (load nil _ glo 228)
   (load close-deep 199 glo 229)
   (load close-deep 200 glo 230)
   (load close-deep 201 glo 231)
   (load close-deep 202 glo 232)
   (load close-deep 203 glo 233)
   (load close-deep 204 glo 234)
   (load close-deep 205 glo 235)
   (load close-deep 206 glo 236)
   (load close-deep 207 glo 237)
   (load close-deep 208 glo 238)
   (load close-deep 209 glo 239)
   (load close-deep 210 glo 240)
   (load close-deep 211 glo 241)
   (load close-deep 212 glo 242)
   (load close-deep 213 glo 243)
   (load close-deep 214 glo 244)
   (load close-deep 215 glo 245)
   (load close-deep 216 glo 246)
   (load close-deep 217 glo 247)
   (load close-deep 218 glo 248)
   (load close-deep 219 glo 249)
   (load close-deep 220 glo 250)
   (load close-deep 221 glo 251)
   (load close-deep 222 glo 252)
   (load close-deep 223 glo 253)
   (load close-deep 224 glo 254)
   (load close-deep 225 glo 255)
   (load close-deep 226 glo 256)
   (load close-deep 227 glo 257)
   (load close-deep 228 glo 258)
   (load close-deep 229 glo 259)
   (load close-deep 230 glo 260)
   (load close-deep 231 glo 261)
   (load close-deep 232 glo 262)
   (load close-deep 233 glo 263)
   (load close-deep 234 glo 264)
   (load close-deep 235 glo 265)
   (load close-deep 236 glo 266)
   (load close-deep 237 glo 267)
   (load close-deep 238 glo 268)
   (load close-deep 239 glo 269)
   (load close-deep 240 glo 270)
   (load close-deep 241 glo 271)
   (load close-deep 242 glo 272)
   (load close-deep 243 glo 273)
   (load close-deep 244 glo 274)
   (load close-deep 245 glo 275)
   (load close-deep 246 glo 276)
   (load close-deep 247 glo 277)
   (load close-deep 248 glo 278)
   (load close-deep 249 glo 279)
   (load close-deep 250 glo 280)
   (load close-deep 251 glo 281)
   (load close-deep 252 glo 282)
   (load close-deep 253 glo 283)
   (load close-deep 254 glo 284)
   (load close-deep 255 glo 285)
   (load close-deep 256 glo 286)
   (load close-deep 257 glo 287)
   (load close-deep 258 glo 288)
   (load close-deep 259 glo 289)
   (load close-deep 260 glo 290)
   (load close-deep 261 glo 291)
   (load close-deep 262 glo 292)
   (load close-deep 263 glo 293)
   (load close-deep 264 glo 294)
   (load close-deep 265 glo 295)
   (load close-deep 266 glo 296)
   (load close-deep 267 glo 297)
   (load close-deep 268 glo 298)
   (load close-deep 269 glo 299)
   (load close-deep 270 glo 300)
   (load close-deep 271 glo 301)
   (load close-deep 272 glo 302)
   (load close-deep 273 glo 303)
   (load close-deep 274 glo 304)
   (load close-deep 275 glo 305)
   (load close-deep 276 glo 306)
   (load close-deep 277 glo 307)
   (load close-deep 278 glo 308)
   (load close-deep 279 glo 309)
   (load close-deep 280 glo 310)
   (load close-deep 281 glo 311)
   (load close-deep 282 glo 312)
   (load close-deep 283 glo 313)
   (load close-deep 284 glo 314)
   (load close-deep 285 glo 315)
   (load close-deep 286 glo 316)
   (load close-deep 287 glo 317)
   (load close-deep 288 glo 318)
   (load close-deep 289 glo 319)
   (load close-deep 290 glo 320)
   (load close-deep 291 glo 321)
   (load close-deep 292 glo 322)
   (load close-deep 293 glo 323)
   (load close-deep 294 glo 324)
   (load close-deep 295 glo 325)
   (load close-deep 296 glo 326)
   (load close-deep 297 glo 327)
   (load close-deep 298 glo 328)
   (load close-deep 299 glo 329)
   (load close-deep 300 glo 330)
   (load close-deep 301 glo 331)
   (load close-deep 302 glo 332)
   (load close-deep 303 glo 333)
   (load close-deep 304 glo 334)
   (load close-deep 305 glo 335)
   (load close-deep 306 glo 336)
   (load close-deep 307 glo 337)
   (load close-deep 308 glo 338)
   (load close-deep 309 glo 339)
   (load close-deep 310 glo 340)
   (load close-deep 311 glo 341)
   (load close-deep 312 glo 342)
   (load close-deep 313 glo 343)
   (load close-deep 314 glo 344)
   (load close-deep 315 glo 345)
   (load close-deep 316 glo 346)
   (load close-deep 317 glo 347)
   (load close-deep 318 glo 348)
   (load close-deep 319 glo 349)
   (load close-deep 320 glo 350)
   (load close-deep 321 glo 351)
   (load close-deep 322 glo 352)
   (load close-deep 323 glo 353)
   (load close-deep 324 glo 354)
   (load close-deep 325 glo 355)
   (load close-deep 326 glo 356)
   (load close-deep 327 glo 357)
   (load close-deep 328 glo 358)
   (load close-deep 329 glo 359)
   (load close-deep 330 glo 360)
   (load close-deep 331 glo 361)
   (load close-deep 332 glo 362)
   (load close-deep 333 glo 363)
   (load close-deep 334 glo 364)
   (load close-deep 335 glo 365)
   (load close-deep 336 glo 366)
   (load close-deep 337 glo 367)
   (load close-deep 338 glo 368)
   (load close-deep 339 glo 369)
   (load close-deep 340 glo 370)
   (load close-deep 341 glo 371)
   (load close-deep 342 glo 372)
   (load close-deep 343 glo 373)
   (load close-deep 344 glo 374)
   (load close-deep 345 glo 375)
   (load close-deep 346 glo 376)
   (load close-deep 347 glo 377)
   (load close-deep 348 glo 378)
   (load close-deep 349 glo 379)
   (load close-deep 350 glo 380)
   (load close-deep 351 glo 381)
   (load close-deep 352 glo 382)
   (load close-deep 353 glo 383)
   (load close-deep 354 glo 384)
   (load close-deep 355 glo 385)
   (load close-deep 356 glo 386)
   (load close-deep 357 glo 387)
   (load close-deep 358 glo 388)
   (load close-deep 359 glo 389)
   (load close-deep 360 glo 390)
   (load close-deep 361 glo 391)
   (load close-deep 362 glo 392)
   (load close-deep 363 glo 393)
   (load close-deep 364 glo 394)
   (load close-deep 365 glo 395)
   (load close-deep 366 glo 396)
   (load close-deep 367 glo 397)
   (load close-deep 368 glo 398)
   (load close-deep 369 glo 399)
   (load close-deep 370 glo 400)
   (load close-deep 371 glo 401)
   (load close-deep 372 glo 402)
   (load close-deep 373 glo 403)
   (load close-deep 374 glo 404)
   (load close-deep 375 glo 405)
   (load close-deep 376 glo 406)
   (load close-deep 377 glo 407)
   (load close-deep 378 glo 408)
   (load close-deep 379 glo 409)
   (load close-deep 380 glo 410)
   (load close-deep 381 glo 411)
   (load close-deep 382 glo 412)
   (load close-deep 383 glo 413)
   (load close-deep 384 glo 414)
   (load close-deep 385 glo 415)
   (load close-deep 386 glo 416)
   (load close-deep 387 glo 417)
   (load close-deep 388 glo 418)
   (load close-deep 389 glo 419)
   (load close-deep 390 glo 420)
   (load close-deep 391 glo 421)
   (load close-deep 392 glo 422)
   (load close-deep 393 glo 423)
   (load close-deep 394 glo 424)
   (load close-deep 395 glo 425)
   (load close-deep 396 glo 426)
   (load close-deep 397 glo 427)
   (load close-deep 398 glo 428)
   (load close-deep 399 glo 429)
   (load close-deep 400 glo 430)
   (load close-deep 401 glo 431)
   (load close-deep 402 glo 432)
   (load close-deep 403 glo 433)
   (load close-deep 404 glo 434)
   (load close-deep 405 glo 435)
   (load close-deep 406 glo 436)
   (load close-deep 407 glo 437)
   (load close-deep 408 glo 438)
   (load close-deep 409 glo 439)
   (load close-deep 410 glo 440)
   (load close-deep 411 glo 441)
   (load close-deep 412 glo 442)
   (load close-deep 413 glo 443)
   (load close-deep 414 glo 444)
   (load close-deep 415 glo 445)
   (load close-deep 416 glo 446)
   (load close-deep 417 glo 447)
   (load close-deep 418 glo 448)
   (load close-deep 419 glo 449)
   (load close-deep 420 glo 450)
   (load close-deep 421 glo 451)
   (load close-deep 422 glo 452)
   (load close-deep 423 glo 453)
   (load close-deep 424 glo 454)
   (load close-deep 425 glo 455)
   (load close-deep 426 glo 456)
   (load close-deep 427 glo 457)
   (new-vec 0)
   (call glo 424 0)
   (move res 0 glo 458)
   (new-vec 0)
   (call glo 426 0)
   (move res 0 glo 459)
   (new-vec 0)
   (call glo 428 0)
   (move res 0 glo 460)
   (new-vec 0)
   (call glo 454 0)
   (move res 0 glo 461)
   (new-vec 0)
   (call glo 456 0)
   (move res 0 glo 462)
   (load close-deep 428 glo 463)
   (load close-deep 429 glo 464)
   (load close-deep 430 glo 465)
   (load close-deep 431 glo 466)
   (load close-deep 432 glo 467)
   (load close-deep 433 glo 468)
   (load close-deep 434 glo 469)
   (load close-deep 435 glo 470)
   (load close-deep 436 glo 471)
   (load close-deep 437 glo 472)
   (load close-deep 438 glo 473)
   (load close-deep 439 glo 474)
   (load close-deep 440 glo 475)
   (load close-deep 441 glo 476)
   (load close-deep 442 glo 477)
   (load close-deep 443 glo 478)
   (new-vec 0)
   (load close-flat 444 tmp 0)
   (new-vec 3)
   (load sym integer? vec 0)
   (load int 1 vec 1)
   (move tmp 0 vec 2)
   (call glo 440 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 445 tmp 1)
   (new-vec 3)
   (load sym + vec 0)
   (load int -1 vec 1)
   (move tmp 1 vec 2)
   (call glo 440 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (load close-flat 446 tmp 2)
   (new-vec 3)
   (load sym - vec 0)
   (load int 2 vec 1)
   (move tmp 2 vec 2)
   (call glo 440 2)
   (move res 0 tmp 2)
   (new-vec 0)
   (load close-flat 447 tmp 3)
   (new-vec 3)
   (load sym * vec 0)
   (load int -1 vec 1)
   (move tmp 3 vec 2)
   (call glo 440 3)
   (move res 0 tmp 3)
   (new-vec 0)
   (load close-flat 448 tmp 4)
   (new-vec 3)
   (load sym quotient vec 0)
   (load int 2 vec 1)
   (move tmp 4 vec 2)
   (call glo 440 4)
   (move res 0 tmp 4)
   (new-vec 0)
   (load close-flat 449 tmp 5)
   (new-vec 3)
   (load sym remainder vec 0)
   (load int 2 vec 1)
   (move tmp 5 vec 2)
   (call glo 440 5)
   (move res 0 tmp 5)
   (new-vec 0)
   (load close-flat 450 tmp 6)
   (new-vec 3)
   (load sym < vec 0)
   (load int 2 vec 1)
   (move tmp 6 vec 2)
   (call glo 440 6)
   (move res 0 tmp 6)
   (new-vec 0)
   (load close-flat 451 tmp 7)
   (new-vec 3)
   (load sym <= vec 0)
   (load int 2 vec 1)
   (move tmp 7 vec 2)
   (call glo 440 7)
   (move res 0 tmp 7)
   (new-vec 0)
   (load close-flat 452 tmp 8)
   (new-vec 3)
   (load sym = vec 0)
   (load int 2 vec 1)
   (move tmp 8 vec 2)
   (call glo 440 8)
   (move res 0 tmp 8)
   (new-vec 0)
   (load close-flat 453 tmp 9)
   (new-vec 3)
   (load sym >= vec 0)
   (load int 2 vec 1)
   (move tmp 9 vec 2)
   (call glo 440 9)
   (move res 0 tmp 9)
   (new-vec 0)
   (load close-flat 454 tmp 10)
   (new-vec 3)
   (load sym > vec 0)
   (load int 2 vec 1)
   (move tmp 10 vec 2)
   (call glo 440 10)
   (move res 0 tmp 10)
   (new-vec 0)
   (load close-flat 455 tmp 11)
   (new-vec 3)
   (load sym boolean? vec 0)
   (load int 1 vec 1)
   (move tmp 11 vec 2)
   (call glo 440 11)
   (move res 0 tmp 11)
   (new-vec 0)
   (load close-flat 456 tmp 12)
   (new-vec 3)
   (load sym symbol? vec 0)
   (load int 1 vec 1)
   (move tmp 12 vec 2)
   (call glo 440 12)
   (move res 0 tmp 12)
   (new-vec 0)
   (load close-flat 457 tmp 13)
   (new-vec 3)
   (load sym char? vec 0)
   (load int 1 vec 1)
   (move tmp 13 vec 2)
   (call glo 440 13)
   (move res 0 tmp 13)
   (new-vec 0)
   (load close-flat 458 tmp 14)
   (new-vec 3)
   (load sym char->integer vec 0)
   (load int 1 vec 1)
   (move tmp 14 vec 2)
   (call glo 440 14)
   (move res 0 tmp 14)
   (new-vec 0)
   (load close-flat 459 tmp 15)
   (new-vec 3)
   (load sym integer->char vec 0)
   (load int 1 vec 1)
   (move tmp 15 vec 2)
   (call glo 440 15)
   (move res 0 tmp 15)
   (new-vec 0)
   (load close-flat 460 tmp 16)
   (new-vec 3)
   (load sym string vec 0)
   (load int -1 vec 1)
   (move tmp 16 vec 2)
   (call glo 440 16)
   (move res 0 tmp 16)
   (new-vec 0)
   (load close-flat 461 tmp 17)
   (new-vec 3)
   (load sym make-string vec 0)
   (load int 2 vec 1)
   (move tmp 17 vec 2)
   (call glo 440 17)
   (move res 0 tmp 17)
   (new-vec 0)
   (load close-flat 462 tmp 18)
   (new-vec 3)
   (load sym string? vec 0)
   (load int 1 vec 1)
   (move tmp 18 vec 2)
   (call glo 440 18)
   (move res 0 tmp 18)
   (new-vec 0)
   (load close-flat 463 tmp 19)
   (new-vec 3)
   (load sym string-length vec 0)
   (load int 1 vec 1)
   (move tmp 19 vec 2)
   (call glo 440 19)
   (move res 0 tmp 19)
   (new-vec 0)
   (load close-flat 464 tmp 20)
   (new-vec 3)
   (load sym string-append vec 0)
   (load int 2 vec 1)
   (move tmp 20 vec 2)
   (call glo 440 20)
   (move res 0 tmp 20)
   (new-vec 0)
   (load close-flat 465 tmp 21)
   (new-vec 3)
   (load sym string=? vec 0)
   (load int 2 vec 1)
   (move tmp 21 vec 2)
   (call glo 440 21)
   (move res 0 tmp 21)
   (new-vec 0)
   (load close-flat 466 tmp 22)
   (new-vec 3)
   (load sym string-ref vec 0)
   (load int 2 vec 1)
   (move tmp 22 vec 2)
   (call glo 440 22)
   (move res 0 tmp 22)
   (new-vec 0)
   (load close-flat 467 tmp 23)
   (new-vec 3)
   (load sym string->symbol vec 0)
   (load int 1 vec 1)
   (move tmp 23 vec 2)
   (call glo 440 23)
   (move res 0 tmp 23)
   (new-vec 0)
   (load close-flat 468 tmp 24)
   (new-vec 3)
   (load sym symbol->string vec 0)
   (load int 1 vec 1)
   (move tmp 24 vec 2)
   (call glo 440 24)
   (move res 0 tmp 24)
   (new-vec 0)
   (load close-flat 469 tmp 25)
   (new-vec 3)
   (load sym pair? vec 0)
   (load int 1 vec 1)
   (move tmp 25 vec 2)
   (call glo 440 25)
   (move res 0 tmp 25)
   (new-vec 0)
   (load close-flat 470 tmp 26)
   (new-vec 3)
   (load sym cons vec 0)
   (load int 2 vec 1)
   (move tmp 26 vec 2)
   (call glo 440 26)
   (move res 0 tmp 26)
   (new-vec 0)
   (load close-flat 471 tmp 27)
   (new-vec 3)
   (load sym car vec 0)
   (load int 1 vec 1)
   (move tmp 27 vec 2)
   (call glo 440 27)
   (move res 0 tmp 27)
   (new-vec 0)
   (load close-flat 472 tmp 28)
   (new-vec 3)
   (load sym cdr vec 0)
   (load int 1 vec 1)
   (move tmp 28 vec 2)
   (call glo 440 28)
   (move res 0 tmp 28)
   (new-vec 0)
   (load close-flat 473 tmp 29)
   (new-vec 3)
   (load sym set-car! vec 0)
   (load int 2 vec 1)
   (move tmp 29 vec 2)
   (call glo 440 29)
   (move res 0 tmp 29)
   (new-vec 0)
   (load close-flat 474 tmp 30)
   (new-vec 3)
   (load sym set-cdr! vec 0)
   (load int 2 vec 1)
   (move tmp 30 vec 2)
   (call glo 440 30)
   (move res 0 tmp 30)
   (new-vec 0)
   (load close-flat 475 tmp 31)
   (new-vec 3)
   (load sym null? vec 0)
   (load int 1 vec 1)
   (move tmp 31 vec 2)
   (call glo 440 31)
   (move res 0 tmp 31)
   (new-vec 0)
   (load close-flat 476 tmp 32)
   (new-vec 3)
   (load sym vector vec 0)
   (load int -1 vec 1)
   (move tmp 32 vec 2)
   (call glo 440 32)
   (move res 0 tmp 32)
   (new-vec 0)
   (load close-flat 477 tmp 33)
   (new-vec 3)
   (load sym make-vector vec 0)
   (load int 2 vec 1)
   (move tmp 33 vec 2)
   (call glo 440 33)
   (move res 0 tmp 33)
   (new-vec 0)
   (load close-flat 478 tmp 34)
   (new-vec 3)
   (load sym vector? vec 0)
   (load int 1 vec 1)
   (move tmp 34 vec 2)
   (call glo 440 34)
   (move res 0 tmp 34)
   (new-vec 0)
   (load close-flat 479 tmp 35)
   (new-vec 3)
   (load sym vector-length vec 0)
   (load int 1 vec 1)
   (move tmp 35 vec 2)
   (call glo 440 35)
   (move res 0 tmp 35)
   (new-vec 0)
   (load close-flat 480 tmp 36)
   (new-vec 3)
   (load sym vector-ref vec 0)
   (load int 2 vec 1)
   (move tmp 36 vec 2)
   (call glo 440 36)
   (move res 0 tmp 36)
   (new-vec 0)
   (load close-flat 481 tmp 37)
   (new-vec 3)
   (load sym vector-set! vec 0)
   (load int 3 vec 1)
   (move tmp 37 vec 2)
   (call glo 440 37)
   (move res 0 tmp 37)
   (new-vec 0)
   (load close-flat 482 tmp 38)
   (new-vec 3)
   (load sym procedure? vec 0)
   (load int 1 vec 1)
   (move tmp 38 vec 2)
   (call glo 440 38)
   (move res 0 tmp 38)
   (new-vec 3)
   (load sym apply vec 0)
   (load int 2 vec 1)
   (load sym apply vec 2)
   (call glo 440 39)
   (move res 0 tmp 39)
   (new-vec 0)
   (load close-flat 483 tmp 40)
   (new-vec 3)
   (load sym eqv? vec 0)
   (load int 2 vec 1)
   (move tmp 40 vec 2)
   (call glo 440 40)
   (move res 0 tmp 40)
   (new-vec 3)
   (load sym call/cc vec 0)
   (load int 1 vec 1)
   (load sym call/cc vec 2)
   (call glo 440 41)
   (move res 0 tmp 41)
   (new-vec 0)
   (load close-flat 484 tmp 42)
   (new-vec 3)
   (load sym exit vec 0)
   (load int 1 vec 1)
   (move tmp 42 vec 2)
   (call glo 440 42)
   (move res 0 tmp 42)
   (new-vec 0)
   (load close-flat 485 tmp 43)
   (new-vec 3)
   (load sym open-input-file vec 0)
   (load int 1 vec 1)
   (move tmp 43 vec 2)
   (call glo 440 43)
   (move res 0 tmp 43)
   (new-vec 0)
   (load close-flat 486 tmp 44)
   (new-vec 3)
   (load sym input-port? vec 0)
   (load int 1 vec 1)
   (move tmp 44 vec 2)
   (call glo 440 44)
   (move res 0 tmp 44)
   (new-vec 0)
   (load close-flat 487 tmp 45)
   (new-vec 3)
   (load sym close-input-port vec 0)
   (load int 1 vec 1)
   (move tmp 45 vec 2)
   (call glo 440 45)
   (move res 0 tmp 45)
   (new-vec 0)
   (load close-flat 488 tmp 46)
   (new-vec 3)
   (load sym current-input-port vec 0)
   (load int 0 vec 1)
   (move tmp 46 vec 2)
   (call glo 440 46)
   (move res 0 tmp 46)
   (new-vec 0)
   (load close-flat 489 tmp 47)
   (new-vec 3)
   (load sym read-char vec 0)
   (load int 1 vec 1)
   (move tmp 47 vec 2)
   (call glo 440 47)
   (move res 0 tmp 47)
   (new-vec 0)
   (load close-flat 490 tmp 48)
   (new-vec 3)
   (load sym peek-char vec 0)
   (load int 1 vec 1)
   (move tmp 48 vec 2)
   (call glo 440 48)
   (move res 0 tmp 48)
   (new-vec 0)
   (load close-flat 491 tmp 49)
   (new-vec 3)
   (load sym eof-object? vec 0)
   (load int 1 vec 1)
   (move tmp 49 vec 2)
   (call glo 440 49)
   (move res 0 tmp 49)
   (new-vec 0)
   (load close-flat 492 tmp 50)
   (new-vec 3)
   (load sym open-output-file vec 0)
   (load int 1 vec 1)
   (move tmp 50 vec 2)
   (call glo 440 50)
   (move res 0 tmp 50)
   (new-vec 0)
   (load close-flat 493 tmp 51)
   (new-vec 3)
   (load sym output-port? vec 0)
   (load int 1 vec 1)
   (move tmp 51 vec 2)
   (call glo 440 51)
   (move res 0 tmp 51)
   (new-vec 0)
   (load close-flat 494 tmp 52)
   (new-vec 3)
   (load sym close-output-port vec 0)
   (load int 1 vec 1)
   (move tmp 52 vec 2)
   (call glo 440 52)
   (move res 0 tmp 52)
   (new-vec 0)
   (load close-flat 495 tmp 53)
   (new-vec 3)
   (load sym current-output-port vec 0)
   (load int 0 vec 1)
   (move tmp 53 vec 2)
   (call glo 440 53)
   (move res 0 tmp 53)
   (new-vec 0)
   (load close-flat 496 tmp 54)
   (new-vec 3)
   (load sym write-char vec 0)
   (load int 2 vec 1)
   (move tmp 54 vec 2)
   (call glo 440 54)
   (move res 0 tmp 54)
   (new-vec 55)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (move tmp 4 vec 4)
   (move tmp 5 vec 5)
   (move tmp 6 vec 6)
   (move tmp 7 vec 7)
   (move tmp 8 vec 8)
   (move tmp 9 vec 9)
   (move tmp 10 vec 10)
   (move tmp 11 vec 11)
   (move tmp 12 vec 12)
   (move tmp 13 vec 13)
   (move tmp 14 vec 14)
   (move tmp 15 vec 15)
   (move tmp 16 vec 16)
   (move tmp 17 vec 17)
   (move tmp 18 vec 18)
   (move tmp 19 vec 19)
   (move tmp 20 vec 20)
   (move tmp 21 vec 21)
   (move tmp 22 vec 22)
   (move tmp 23 vec 23)
   (move tmp 24 vec 24)
   (move tmp 25 vec 25)
   (move tmp 26 vec 26)
   (move tmp 27 vec 27)
   (move tmp 28 vec 28)
   (move tmp 29 vec 29)
   (move tmp 30 vec 30)
   (move tmp 31 vec 31)
   (move tmp 32 vec 32)
   (move tmp 33 vec 33)
   (move tmp 34 vec 34)
   (move tmp 35 vec 35)
   (move tmp 36 vec 36)
   (move tmp 37 vec 37)
   (move tmp 38 vec 38)
   (move tmp 39 vec 39)
   (move tmp 40 vec 40)
   (move tmp 41 vec 41)
   (move tmp 42 vec 42)
   (move tmp 43 vec 43)
   (move tmp 44 vec 44)
   (move tmp 45 vec 45)
   (move tmp 46 vec 46)
   (move tmp 47 vec 47)
   (move tmp 48 vec 48)
   (move tmp 49 vec 49)
   (move tmp 50 vec 50)
   (move tmp 51 vec 51)
   (move tmp 52 vec 52)
   (move tmp 53 vec 53)
   (move tmp 54 vec 54)
   (call lib 32 0)
   (move res 0 glo 479)
   (load close-deep 497 glo 480)
   (load close-deep 498 glo 481)
   (load close-deep 499 glo 482)
   (load close-deep 500 glo 483)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 484)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 485)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 486)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 487)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 488)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 489)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 490)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 glo 491)
   (load close-deep 501 glo 492)
   (load int 0 glo 493)
   (load close-deep 502 glo 494)
   (load close-deep 503 glo 495)
   (load close-deep 504 glo 496)
   (load close-deep 505 glo 497)
   (load close-deep 506 glo 498)
   (load close-deep 507 glo 499)
   (load close-deep 508 glo 500)
   (load int 0 glo 501)
   (load bool 1 glo 502)
   (load bool 1 glo 503)
   (load close-deep 509 glo 504)
   (load close-deep 510 glo 505)
   (load close-deep 511 glo 506)
   (load close-deep 512 glo 507)
   (load close-deep 513 glo 508)
   (load close-deep 514 glo 509)
   (new-vec 1)
   (load str "tests/Meta/bar.scm" vec 0)
   (tail-call glo 508)

   (label lambda-deep%0)
   (jump-if-false 0 0 else%2263)
   (load bool 0 res 0)
   (return)
   (label else%2263)
   (load bool 1 res 0)
   (return)

   (label lambda-deep%1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 515 res 0)
   (return)

   (label lambda-deep%2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 516 res 0)
   (return)

   (label lambda-deep%3)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2264)
   (load bool 1 res 0)
   (return)
   (label else%2264)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2265)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2266)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 21)
   (label else%2266)
   (load bool 0 res 0)
   (return)
   (label else%2265)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2267)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2268)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2269)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2270)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 9)
   (label else%2270)
   (load bool 0 res 0)
   (return)
   (label else%2269)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2271)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 9)
   (label else%2271)
   (load bool 0 res 0)
   (return)
   (label else%2268)
   (load bool 0 res 0)
   (return)
   (label else%2267)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2272)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2273)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2274)
   (new-vec 1)
   (extend)
   (load close-deep 517 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%2274)
   (load bool 0 res 0)
   (return)
   (label else%2273)
   (load bool 0 res 0)
   (return)
   (label else%2272)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%4)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 518 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 41)

   (label lambda-deep%5)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%6)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2275)
   (move 0 0 res 0)
   (return)
   (label else%2275)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%7)
   (new-vec 1)
   (extend)
   (load close-deep 519 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2276)
   (move 0 0 res 0)
   (return)
   (label else%2276)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2277)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%2277)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%8)
   (new-vec 1)
   (extend)
   (load close-deep 520 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 0 vec 1)
   (load int 1 vec 2)
   (tail-call 1 0)

   (label lambda-deep%9)
   (new-vec 1)
   (extend)
   (load close-deep 521 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%10)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2278)
   (load nil _ res 0)
   (return)
   (label else%2278)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2279)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call lib 27)
   (label else%2279)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2280)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 15)
   (label else%2280)
   (new-vec 3)
   (move glo 15 vec 0)
   (load nil _ vec 1)
   (move 1 0 vec 2)
   (tail-call glo 54)

   (label lambda-deep%11)
   (new-vec 3)
   (move lib 26 vec 0)
   (load nil _ vec 1)
   (move 0 0 vec 2)
   (tail-call glo 55)

   (label lambda-deep%12)
   (new-vec 1)
   (extend)
   (load close-deep 522 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%13)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2281)
   (new-vec 1)
   (extend)
   (load close-deep 523 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 0 0)
   (label else%2281)
   (new-vec 3)
   (load sym last-pair vec 0)
   (load str "not a non-empty list: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%14)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2282)
   (new-vec 3)
   (load sym list-ref vec 0)
   (load str "negative offset: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)
   (label else%2282)
   (new-vec 1)
   (extend)
   (load close-deep 524 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%15)
   (new-vec 1)
   (extend)
   (load close-deep 525 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%16)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2283)
   (new-vec 3)
   (load sym list-set! vec 0)
   (load str "negative offset: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)
   (label else%2283)
   (new-vec 1)
   (extend)
   (load close-deep 526 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%17)
   (new-vec 1)
   (extend)
   (load close-deep 527 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%18)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%19)
   (new-vec 1)
   (extend)
   (load close-deep 528 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%20)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 25)

   (label lambda-deep%21)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%22)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 27)

   (label lambda-deep%23)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%24)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)

   (label lambda-deep%25)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 529 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 48)

   (label lambda-deep%26)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 46)

   (label lambda-deep%27)
   (new-vec 2)
   (move lib 28 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 46)

   (label lambda-deep%28)
   (new-vec 1)
   (extend)
   (load close-deep 530 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%29)
   (new-vec 1)
   (extend)
   (load close-deep 531 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%30)
   (new-vec 1)
   (extend)
   (load close-deep 532 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%31)
   (new-vec 1)
   (extend)
   (load close-deep 533 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%32)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2284)
   (new-vec 2)
   (load sym map vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 120)
   (label else%2284)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2285)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 46)
   (label else%2285)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 43 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2286)
   (new-vec 1)
   (extend)
   (load close-deep 534 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%2286)
   (new-vec 2)
   (load sym map vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 120)

   (label lambda-deep%33)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2287)
   (new-vec 2)
   (load sym map-append vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 120)
   (label else%2287)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2288)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 47)
   (label else%2288)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 43 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2289)
   (new-vec 1)
   (extend)
   (load close-deep 535 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%2289)
   (new-vec 2)
   (load sym map-append vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 120)

   (label lambda-deep%34)
   (new-vec 1)
   (extend)
   (load close-deep 536 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%35)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2290)
   (new-vec 2)
   (load sym for-each vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 120)
   (label else%2290)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2291)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 52)
   (label else%2291)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 43 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2292)
   (new-vec 1)
   (extend)
   (load close-deep 537 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)
   (label else%2292)
   (new-vec 2)
   (load sym for-each vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 120)

   (label lambda-deep%36)
   (new-vec 1)
   (extend)
   (load close-deep 538 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%37)
   (new-vec 1)
   (extend)
   (load close-deep 539 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%38)
   (new-vec 1)
   (extend)
   (load close-deep 540 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%39)
   (new-vec 1)
   (extend)
   (load close-deep 541 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%40)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2293)
   (new-vec 2)
   (load sym right-fold vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 120)
   (label else%2293)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2294)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 56)
   (label else%2294)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 43 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2295)
   (new-vec 1)
   (extend)
   (load close-deep 542 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)
   (label else%2295)
   (new-vec 2)
   (load sym variadic-right-fold vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 120)

   (label lambda-deep%41)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2296)
   (new-vec 2)
   (load sym left-fold vec 0)
   (load str "missing list(s)" vec 1)
   (tail-call glo 120)
   (label else%2296)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2297)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 57)
   (label else%2297)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 43 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2298)
   (new-vec 1)
   (extend)
   (load close-deep 543 0 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)
   (label else%2298)
   (new-vec 2)
   (load sym variadic-left-fold vec 0)
   (load str "mismatching lists" vec 1)
   (tail-call glo 120)

   (label lambda-deep%42)
   (new-vec 1)
   (extend)
   (load close-deep 544 0 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 0 0)

   (label lambda-deep%43)
   (new-vec 0)
   (load close-flat 545 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 60)

   (label lambda-deep%44)
   (new-vec 2)
   (move glo 6 vec 0)
   (move 0 0 vec 1)
   (call glo 7 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 60)

   (label lambda-deep%45)
   (new-vec 0)
   (load close-flat 546 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 1 vec 2)
   (tail-call glo 62)

   (label lambda-deep%46)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 1)

   (label lambda-deep%47)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 2)

   (label lambda-deep%48)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 6)

   (label lambda-deep%49)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%50)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 10)

   (label lambda-deep%51)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%52)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 6)

   (label lambda-deep%53)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2299)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2300)
   (move 0 0 res 0)
   (return)
   (label else%2300)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 1)
   (label else%2299)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2301)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 1)
   (label else%2301)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%54)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2302)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 2)
   (label else%2302)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%55)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2303)
   (move 0 0 res 0)
   (return)
   (label else%2303)
   (move 0 1 res 0)
   (return)

   (label lambda-deep%56)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2304)
   (move 0 1 res 0)
   (return)
   (label else%2304)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%57)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 8)

   (label lambda-deep%58)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2305)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 32 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2306)
   (load bool 1 res 0)
   (return)
   (label else%2306)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 10 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2307)
   (load bool 1 res 0)
   (return)
   (label else%2307)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 9 vec 1)
   (tail-call lib 8)
   (label else%2305)
   (new-vec 3)
   (load sym char:whitespace? vec 0)
   (load str "not a char: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%59)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 81 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2308)
   (load bool 1 res 0)
   (return)
   (label else%2308)
   (load close-deep 547 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 40 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2309)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2309)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2310)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2310)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 91 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2311)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2311)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2312)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2312)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 39 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2313)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2313)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 96 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2314)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2314)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 44 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2315)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%2315)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 59 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%60)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 548 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%61)
   (new-vec 1)
   (extend)
   (load close-deep 549 0 0)
   (load close-deep 550 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 1 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2316)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2317)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 2 vec 0)
   (move tmp 1 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2317)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%2316)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%62)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2318)
   (new-vec 3)
   (load sym string-suffix? vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%2318)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2319)
   (new-vec 3)
   (load sym string-suffix? vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)
   (label else%2319)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 19 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2320)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (call glo 84 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (tail-call lib 21)
   (label else%2320)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%63)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2321)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 551 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)
   (label else%2321)
   (new-vec 3)
   (load sym string->list vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%64)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 86 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 34 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 16 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 34 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%65)
   (new-vec 1)
   (extend)
   (load close-deep 552 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2322)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 45 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%2322)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (tail-call 0 0)

   (label lambda-deep%66)
   (new-vec 1)
   (extend)
   (load close-deep 553 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2323)
   (new-vec 2)
   (load char 40 vec 0)
   (load char 41 vec 1)
   (tail-call glo 11)
   (label else%2323)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2324)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 40 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%2324)
   (new-vec 3)
   (load sym list-of-values->list-of-chars vec 0)
   (load str "not a list: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%67)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 88 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (extend)
   (load close-deep 554 0 0)
   (load close-deep 555 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2325)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2325)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 91 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 1 vec 0)
   (call 0 0 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 16 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%68)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2326)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 89)
   (label else%2326)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2327)
   (jump-if-false 0 0 else%2328)
   (new-vec 1)
   (load str "#t" vec 0)
   (tail-call glo 86)
   (label else%2328)
   (new-vec 1)
   (load str "#f" vec 0)
   (tail-call glo 86)
   (label else%2327)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2329)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 88)
   (label else%2329)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2330)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)
   (label else%2330)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2331)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 87)
   (label else%2331)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2332)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 86)
   (label else%2332)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 38 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2333)
   (new-vec 1)
   (load str "#<procedure>" vec 0)
   (tail-call glo 86)
   (label else%2333)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2334)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 90)
   (label else%2334)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 44 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2335)
   (new-vec 1)
   (load str "#<input-port>" vec 0)
   (tail-call glo 86)
   (label else%2335)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 51 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2336)
   (new-vec 1)
   (load str "#<output-port>" vec 0)
   (tail-call glo 86)
   (label else%2336)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2337)
   (new-vec 1)
   (load str "#<eof-object>" vec 0)
   (tail-call glo 86)
   (label else%2337)
   (new-vec 3)
   (load sym value->list-of-chars vec 0)
   (load str "unrecognized value: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%69)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 91 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%70)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2338)
   (load str "" res 0)
   (return)
   (label else%2338)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2339)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (extend)
   (load close-deep 556 0 0)
   (load close-deep 557 0 1)
   (load close-deep 558 0 2)
   (new-vec 2)
   (load int 0 vec 0)
   (move 2 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)
   (label else%2339)
   (new-vec 3)
   (load sym format vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%71)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 559 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%72)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 560 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 3 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%73)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 88 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%74)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2340)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (call lib 7 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2341)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 7)
   (label else%2341)
   (load bool 0 res 0)
   (return)
   (label else%2340)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%75)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 97 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2342)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 2)
   (label else%2342)
   (new-vec 3)
   (load sym digit->integer vec 0)
   (load str "not a digit: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%76)
   (load close-deep 561 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2343)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 9 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2343)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%77)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2344)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 562 tmp 0)
   (jump-if-false 0 0 else%2345)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%2345)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load char 45 vec 1)
   (call glo 77 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2346)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2346)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%2344)
   (new-vec 3)
   (load sym string->integer vec 0)
   (load str "not a string: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%78)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 43 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 45 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%79)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 52 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%80)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2347)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 10 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 54)
   (label else%2347)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2348)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 51 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2349)
   (new-vec 2)
   (load char 10 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 54)
   (label else%2349)
   (new-vec 3)
   (load sym newline vec 0)
   (load str "not a port: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%2348)
   (new-vec 3)
   (load sym newline vec 0)
   (load str "Too many arguments: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%81)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2350)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 2)
   (label else%2350)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%82)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2351)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 2)
   (label else%2351)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%83)
   (new-vec 1)
   (extend)
   (load close-deep 563 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%84)
   (new-vec 1)
   (extend)
   (load close-deep 564 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%85)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 565 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 2 vec 2)
   (tail-call glo 107)

   (label lambda-deep%86)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (load close-flat 566 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 2 vec 1)
   (load close-flat 567 tmp 1)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)

   (label lambda-deep%87)
   (new-vec 1)
   (extend)
   (load close-deep 568 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%88)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 569 tmp 0)
   (new-vec 0)
   (load close-flat 570 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)

   (label lambda-deep%89)
   (new-vec 1)
   (extend)
   (load close-deep 571 0 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 0 0)

   (label lambda-deep%90)
   (new-vec 2)
   (extend)
   (load close-deep 572 0 0)
   (load close-deep 573 0 1)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (move 1 0 vec 3)
   (load close-flat 574 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 1 2 vec 2)
   (tail-call glo 108)

   (label lambda-deep%91)
   (load close-deep 575 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2352)
   (new-vec 0)
   (call lib 46 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2352)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%92)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 576 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 91 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 53)

   (label lambda-deep%93)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2353)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 115)
   (label else%2353)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2354)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 115)
   (label else%2354)
   (new-vec 3)
   (load sym write vec 0)
   (load str "wrong arity: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%94)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 577 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 91 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 53)

   (label lambda-deep%95)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2355)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 117)
   (label else%2355)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2356)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 117)
   (label else%2356)
   (new-vec 3)
   (load sym display vec 0)
   (load str "wrong arity: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%96)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2357)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 578 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%2357)
   (new-vec 3)
   (load sym extract-directory-name vec 0)
   (load str "not a file name: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%97)
   (new-vec 0)
   (load close-flat 579 tmp 0)
   (move tmp 0 glo 120)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 103 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "DAIMI-Scheme error -- " vec 0)
   (move tmp 0 vec 1)
   (call glo 118 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2358)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 103 0)
   (new-vec 1)
   (load int 1 vec 0)
   (tail-call lib 42)
   (label else%2358)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 580 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2359)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2359)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%98)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2360)
   (move 0 2 res 0)
   (return)
   (label else%2360)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2361)
   (move 0 1 res 0)
   (return)
   (label else%2361)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2362)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (move 0 2 vec 2)
   (call glo 121 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2362)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 1 vec 2)
   (call glo 121 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%99)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 581 tmp 0)
   (jump-if-false 0 0 else%2363)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%2363)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%100)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%101)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-deep%102)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 582 res 0)
   (return)

   (label lambda-deep%103)
   (load int -1 glo 131)
   (load void _ res 0)
   (return)

   (label lambda-deep%104)
   (new-vec 2)
   (move glo 131 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 glo 131)
   (new-vec 1)
   (move glo 131 vec 0)
   (call glo 96 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 23)

   (label lambda-deep%105)
   (jump-if-false glo 502 else%2364)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 118)
   (label else%2364)
   (load str "Shhh!" res 0)
   (return)

   (label lambda-deep%106)
   (jump-if-false glo 502 else%2365)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 118 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 103)
   (label else%2365)
   (load str "Shhh!" res 0)
   (return)

   (label lambda-deep%107)
   (new-vec 3)
   (load sym Parsed-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%108)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2366)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2367)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Parsed-Program vec 1)
   (tail-call lib 40)
   (label else%2367)
   (load bool 0 res 0)
   (return)
   (label else%2366)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%109)
   (new-vec 3)
   (load sym DefRec vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%110)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2368)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2369)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DefRec vec 1)
   (tail-call lib 40)
   (label else%2369)
   (load bool 0 res 0)
   (return)
   (label else%2368)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%111)
   (new-vec 3)
   (load sym DefExp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%112)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2370)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2371)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DefExp vec 1)
   (tail-call lib 40)
   (label else%2371)
   (load bool 0 res 0)
   (return)
   (label else%2370)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%113)
   (new-vec 2)
   (load sym Literal vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%114)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2372)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2373)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Literal vec 1)
   (tail-call lib 40)
   (label else%2373)
   (load bool 0 res 0)
   (return)
   (label else%2372)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%115)
   (new-vec 2)
   (load sym Variable vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%116)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2374)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2375)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Variable vec 1)
   (tail-call lib 40)
   (label else%2375)
   (load bool 0 res 0)
   (return)
   (label else%2374)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%117)
   (new-vec 3)
   (load sym Abstraction vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%118)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2376)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2377)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Abstraction vec 1)
   (tail-call lib 40)
   (label else%2377)
   (load bool 0 res 0)
   (return)
   (label else%2376)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%119)
   (new-vec 4)
   (load sym IfThenElse vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%120)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2378)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2379)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym IfThenElse vec 1)
   (tail-call lib 40)
   (label else%2379)
   (load bool 0 res 0)
   (return)
   (label else%2378)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%121)
   (new-vec 3)
   (load sym Assign vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%122)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2380)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2381)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Assign vec 1)
   (tail-call lib 40)
   (label else%2381)
   (load bool 0 res 0)
   (return)
   (label else%2380)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%123)
   (new-vec 3)
   (load sym Application vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%124)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2382)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2383)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Application vec 1)
   (tail-call lib 40)
   (label else%2383)
   (load bool 0 res 0)
   (return)
   (label else%2382)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%125)
   (new-vec 3)
   (load sym CondExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%126)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2384)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2385)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym CondExpr vec 1)
   (tail-call lib 40)
   (label else%2385)
   (load bool 0 res 0)
   (return)
   (label else%2384)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%127)
   (new-vec 4)
   (load sym CaseExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%128)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2386)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2387)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym CaseExpr vec 1)
   (tail-call lib 40)
   (label else%2387)
   (load bool 0 res 0)
   (return)
   (label else%2386)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%129)
   (new-vec 4)
   (load sym CaseRecordExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%130)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2388)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2389)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym CaseRecordExpr vec 1)
   (tail-call lib 40)
   (label else%2389)
   (load bool 0 res 0)
   (return)
   (label else%2388)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%131)
   (new-vec 2)
   (load sym ConjExpr vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%132)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2390)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2391)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ConjExpr vec 1)
   (tail-call lib 40)
   (label else%2391)
   (load bool 0 res 0)
   (return)
   (label else%2390)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%133)
   (new-vec 2)
   (load sym DisjExpr vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%134)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2392)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2393)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DisjExpr vec 1)
   (tail-call lib 40)
   (label else%2393)
   (load bool 0 res 0)
   (return)
   (label else%2392)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%135)
   (new-vec 4)
   (load sym LetExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%136)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2394)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2395)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LetExpr vec 1)
   (tail-call lib 40)
   (label else%2395)
   (load bool 0 res 0)
   (return)
   (label else%2394)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%137)
   (new-vec 4)
   (load sym SLetExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%138)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2396)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2397)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym SLetExpr vec 1)
   (tail-call lib 40)
   (label else%2397)
   (load bool 0 res 0)
   (return)
   (label else%2396)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%139)
   (new-vec 4)
   (load sym LetRecExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%140)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2398)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2399)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LetRecExpr vec 1)
   (tail-call lib 40)
   (label else%2399)
   (load bool 0 res 0)
   (return)
   (label else%2398)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%141)
   (new-vec 2)
   (load sym SequenceExpr vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%142)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2400)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2401)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym SequenceExpr vec 1)
   (tail-call lib 40)
   (label else%2401)
   (load bool 0 res 0)
   (return)
   (label else%2400)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%143)
   (new-vec 2)
   (load sym Suspend vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%144)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2402)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2403)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Suspend vec 1)
   (tail-call lib 40)
   (label else%2403)
   (load bool 0 res 0)
   (return)
   (label else%2402)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%145)
   (new-vec 2)
   (load sym Delay vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%146)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2404)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2405)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Delay vec 1)
   (tail-call lib 40)
   (label else%2405)
   (load bool 0 res 0)
   (return)
   (label else%2404)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%147)
   (new-vec 2)
   (load sym Quotation vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%148)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2406)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2407)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Quotation vec 1)
   (tail-call lib 40)
   (label else%2407)
   (load bool 0 res 0)
   (return)
   (label else%2406)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%149)
   (new-vec 2)
   (load sym Integer vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%150)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2408)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2409)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Integer vec 1)
   (tail-call lib 40)
   (label else%2409)
   (load bool 0 res 0)
   (return)
   (label else%2408)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%151)
   (new-vec 2)
   (load sym Boolean vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%152)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2410)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2411)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Boolean vec 1)
   (tail-call lib 40)
   (label else%2411)
   (load bool 0 res 0)
   (return)
   (label else%2410)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%153)
   (new-vec 2)
   (load sym String vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%154)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2412)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2413)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym String vec 1)
   (tail-call lib 40)
   (label else%2413)
   (load bool 0 res 0)
   (return)
   (label else%2412)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%155)
   (new-vec 2)
   (load sym Character vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%156)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2414)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2415)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Character vec 1)
   (tail-call lib 40)
   (label else%2415)
   (load bool 0 res 0)
   (return)
   (label else%2414)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%157)
   (new-vec 2)
   (load sym Symbol vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%158)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2416)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2417)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Symbol vec 1)
   (tail-call lib 40)
   (label else%2417)
   (load bool 0 res 0)
   (return)
   (label else%2416)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%159)
   (new-vec 1)
   (load sym Nil vec 0)
   (tail-call lib 32)

   (label lambda-deep%160)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2418)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2419)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Nil vec 1)
   (tail-call lib 40)
   (label else%2419)
   (load bool 0 res 0)
   (return)
   (label else%2418)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%161)
   (new-vec 1)
   (load sym Void vec 0)
   (tail-call lib 32)

   (label lambda-deep%162)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2420)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2421)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Void vec 1)
   (tail-call lib 40)
   (label else%2421)
   (load bool 0 res 0)
   (return)
   (label else%2420)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%163)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2422)
   (new-vec 2)
   (move 0 0 vec 0)
   (move glo 4 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 6)
   (label else%2422)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%164)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2423)
   (move 0 0 res 0)
   (return)
   (label else%2423)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2424)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 193)
   (label else%2424)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%165)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2425)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym load vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2426)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2427)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2428)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 31)
   (label else%2428)
   (load bool 0 res 0)
   (return)
   (label else%2427)
   (load bool 0 res 0)
   (return)
   (label else%2426)
   (load bool 0 res 0)
   (return)
   (label else%2425)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%166)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2429)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym load-relative vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2430)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2431)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2432)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 31)
   (label else%2432)
   (load bool 0 res 0)
   (return)
   (label else%2431)
   (load bool 0 res 0)
   (return)
   (label else%2430)
   (load bool 0 res 0)
   (return)
   (label else%2429)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%167)
   (new-vec 1)
   (extend)
   (load close-deep 583 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%168)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2433)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym define-record vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2434)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 192 vec 0)
   (move tmp 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2435)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 193)
   (label else%2435)
   (load bool 0 res 0)
   (return)
   (label else%2434)
   (load bool 0 res 0)
   (return)
   (label else%2433)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%169)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2436)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym define vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2437)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 192)
   (label else%2437)
   (load bool 0 res 0)
   (return)
   (label else%2436)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%170)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-deep%171)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2438)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym lambda vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2439)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 192 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2440)
   (move 0 0 res 0)
   (return)
   (label else%2440)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 192 vec 0)
   (move tmp 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2441)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 193)
   (label else%2441)
   (load bool 0 res 0)
   (return)
   (label else%2439)
   (load bool 0 res 0)
   (return)
   (label else%2438)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%172)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (tail-call glo 196)

   (label lambda-deep%173)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2442)
   (new-vec 0)
   (load close-flat 584 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2443)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym else vec 1)
   (tail-call glo 9)
   (label else%2443)
   (load bool 0 res 0)
   (return)
   (label else%2442)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%174)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2444)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2445)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2446)
   (new-vec 0)
   (load close-flat 585 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2447)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym else vec 1)
   (tail-call glo 9)
   (label else%2447)
   (load bool 0 res 0)
   (return)
   (label else%2446)
   (load bool 0 res 0)
   (return)
   (label else%2445)
   (load bool 0 res 0)
   (return)
   (label else%2444)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%175)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2448)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2449)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2450)
   (new-vec 0)
   (load close-flat 586 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2451)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym else vec 1)
   (tail-call glo 9)
   (label else%2451)
   (load bool 0 res 0)
   (return)
   (label else%2450)
   (load bool 0 res 0)
   (return)
   (label else%2449)
   (load bool 0 res 0)
   (return)
   (label else%2448)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%176)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 13)

   (label lambda-deep%177)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2452)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2453)
   (new-vec 0)
   (load close-flat 587 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2454)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 192 vec 0)
   (move 0 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2455)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 193)
   (label else%2455)
   (load bool 0 res 0)
   (return)
   (label else%2454)
   (load bool 0 res 0)
   (return)
   (label else%2453)
   (load bool 0 res 0)
   (return)
   (label else%2452)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%178)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2456)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2457)
   (new-vec 0)
   (load close-flat 588 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2458)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 192 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 48)
   (label else%2458)
   (load bool 0 res 0)
   (return)
   (label else%2457)
   (load bool 0 res 0)
   (return)
   (label else%2456)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%179)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2459)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2460)
   (new-vec 0)
   (load close-flat 589 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2461)
   (new-vec 2)
   (move glo 28 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 200 vec 0)
   (move tmp 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2462)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 192 vec 0)
   (move 0 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2463)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 193)
   (label else%2463)
   (load bool 0 res 0)
   (return)
   (label else%2462)
   (load bool 0 res 0)
   (return)
   (label else%2461)
   (load bool 0 res 0)
   (return)
   (label else%2460)
   (load bool 0 res 0)
   (return)
   (label else%2459)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%180)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-deep%181)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-deep%182)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2464)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 13)
   (label else%2464)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%183)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2465)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 13)
   (label else%2465)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%184)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2466)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 192)
   (label else%2466)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%185)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 138)

   (label lambda-deep%186)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 176)

   (label lambda-deep%187)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2467)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym quote vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2468)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 199 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2469)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 216)
   (label else%2469)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal quote: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2468)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lambda vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2470)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 200 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2471)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 217 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 146)
   (label else%2471)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal lambda: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2470)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym if vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2472)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 201 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2473)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 217 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 39 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 217 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 148)
   (label else%2473)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal if: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2472)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym cond vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2474)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 202 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2475)
   (new-vec 1)
   (extend)
   (load close-deep 590 0 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move glo 28 vec 1)
   (call glo 7 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 154)
   (label else%2475)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal cond: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2474)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym case vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2476)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 203 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2477)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move lib 27 vec 0)
   (move tmp 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 217 vec 0)
   (move glo 28 vec 1)
   (call glo 7 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 50 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 156)
   (label else%2477)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal case: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2476)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym case-record vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2478)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 204 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2479)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move lib 27 vec 0)
   (move tmp 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 217 vec 0)
   (move glo 28 vec 1)
   (call glo 7 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 30 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 50 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 158)
   (label else%2479)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal case-record: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2478)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym and vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2480)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 205 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2481)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move tmp 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 160)
   (label else%2481)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal and: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2480)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym or vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2482)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 206 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2483)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move tmp 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 162)
   (label else%2483)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal or: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2482)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym let vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2484)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 207 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2485)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2486)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 37 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 217)
   (label else%2486)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move glo 28 vec 1)
   (call glo 7 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 37 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 217 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 164)
   (label else%2485)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal let: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2484)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym let* vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2487)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 208 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2488)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2489)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 37 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 217)
   (label else%2489)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move glo 28 vec 1)
   (call glo 7 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 37 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 217 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 166)
   (label else%2488)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal let*: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2487)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym letrec vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2490)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 209 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2491)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2492)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 37 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 217)
   (label else%2492)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move glo 28 vec 1)
   (call glo 7 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 37 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 217 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 168)
   (label else%2491)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal letrec: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2490)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym begin vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2493)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 212 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2494)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 217 vec 0)
   (move tmp 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 170)
   (label else%2494)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal begin: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2493)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym suspend vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2495)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 210 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2496)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 172)
   (label else%2496)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal suspend: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2495)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym delay vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2497)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 211 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2498)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 174)
   (label else%2498)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal delay: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2497)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym set! vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2499)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 214 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2500)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 217 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 150)
   (label else%2500)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal set!: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2499)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 213 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2501)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 217 vec 0)
   (move tmp 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%2501)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Illegal call: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%2467)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2502)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 178 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2502)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2503)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 180 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2503)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2504)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 182 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2504)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2505)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 184 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2505)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 192 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2506)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 144)
   (label else%2506)
   (new-vec 3)
   (load sym parse-expression vec 0)
   (load str "Unrecognized expression: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%188)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 217 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 140)

   (label lambda-deep%189)
   (new-vec 1)
   (extend)
   (load close-deep 591 0 0)
   (new-vec 1)
   (load str "Parsing" vec 0)
   (call glo 134 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str " / Parsed" vec 0)
   (call glo 135 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%190)
   (new-vec 2)
   (load str "(" vec 0)
   (move 0 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 134 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 0 vec 1)
   (move 0 1 vec 2)
   (load close-flat 592 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 101 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str ")" vec 0)
   (call glo 134 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%191)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 119 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (move tmp 0 vec 2)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 103 0)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%192)
   (new-vec 3)
   (load sym Desugared-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%193)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2507)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2508)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Desugared-Program vec 1)
   (tail-call lib 40)
   (label else%2508)
   (load bool 0 res 0)
   (return)
   (label else%2507)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%194)
   (new-vec 3)
   (load sym SequenceExpr2 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%195)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2509)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2510)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym SequenceExpr2 vec 1)
   (tail-call lib 40)
   (label else%2510)
   (load bool 0 res 0)
   (return)
   (label else%2509)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%196)
   (new-vec 1)
   (load sym cons vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 227 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 227 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%197)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2511)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 178 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2511)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 11 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2512)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 180 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2512)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2513)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 182 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2513)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2514)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 184 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2514)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2515)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 186 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2515)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2516)
   (new-vec 0)
   (call glo 188 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%2516)
   (new-vec 3)
   (load sym transmogrify-quoted-non-pair-expression vec 0)
   (load str "Quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%198)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2517)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 225)
   (label else%2517)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 226)

   (label lambda-deep%199)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 140 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move glo 228 vec 1)
   (call lib 26 0)
   (move res 0 glo 228)
   (load void _ res 0)
   (return)

   (label lambda-deep%200)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2518)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2518)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2519)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2519)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2520)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2520)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2521)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2521)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2522)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2522)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 155 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2523)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2523)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 157 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2524)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2524)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 159 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2525)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2525)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 161 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2526)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2526)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 163 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2527)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2527)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 165 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2528)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2528)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 167 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2529)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2529)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2530)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2530)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 171 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2531)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2531)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 173 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2532)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2532)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 175 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2533)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2533)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2534)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2534)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 177 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2535)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2535)
   (new-vec 3)
   (load sym simple-expression? vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%201)
   (new-vec 0)
   (load close-flat 593 tmp 0)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 0 2 vec 1)
   (move 0 0 vec 2)
   (move 0 1 vec 3)
   (tail-call glo 59)

   (label lambda-deep%202)
   (new-vec 1)
   (extend)
   (load close-deep 594 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (tail-call 0 0)

   (label lambda-deep%203)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2536)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 181 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2537)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2538)
   (new-vec 0)
   (tail-call 2 1)
   (label else%2538)
   (new-vec 0)
   (tail-call 2 2)
   (label else%2537)
   (new-vec 0)
   (tail-call 1 1)
   (label else%2536)
   (new-vec 0)
   (call 0 1 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 0 2 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 148)

   (label lambda-deep%204)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2539)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 595 tmp 0)
   (jump-if-false 0 0 else%2540)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%2540)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 18 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 18 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2539)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%205)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 139 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2541)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (load str "make-" vec 0)
   (move 0 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load str "is-" vec 0)
   (move 0 0 vec 1)
   (load str "?" vec 2)
   (call lib 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 23 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (extend)
   (load close-deep 596 0 0)
   (new-vec 1)
   (load int 1 vec 0)
   (call 0 0 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load str "record%" vec 0)
   (call glo 133 3)
   (move res 0 tmp 3)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (extend)
   (new-vec 0)
   (load close-flat 597 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load sym vector vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 4 0 vec 0)
   (call glo 186 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 142 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 144 vec 0)
   (move 0 0 vec 1)
   (call glo 50 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 152 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 140 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (load sym vector? vec 0)
   (call glo 144 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 144 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 152 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load sym = vec 0)
   (call glo 144 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (load sym vector-length vec 0)
   (call glo 144 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 144 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move tmp 5 vec 0)
   (call glo 11 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (move tmp 4 vec 0)
   (move tmp 5 vec 1)
   (call glo 152 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move 3 1 vec 0)
   (call glo 178 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move tmp 5 vec 0)
   (call glo 142 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (move tmp 4 vec 0)
   (move tmp 5 vec 1)
   (call glo 11 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 152 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (load sym eqv? vec 0)
   (call glo 144 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (load sym vector-ref vec 0)
   (call glo 144 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 144 6)
   (move res 0 tmp 6)
   (new-vec 1)
   (load int 0 vec 0)
   (call glo 178 7)
   (move res 0 tmp 7)
   (new-vec 1)
   (move tmp 7 vec 0)
   (call glo 142 7)
   (move res 0 tmp 7)
   (new-vec 2)
   (move tmp 6 vec 0)
   (move tmp 7 vec 1)
   (call glo 11 6)
   (move res 0 tmp 6)
   (new-vec 2)
   (move tmp 5 vec 0)
   (move tmp 6 vec 1)
   (call glo 152 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move 4 0 vec 0)
   (call glo 186 6)
   (move res 0 tmp 6)
   (new-vec 1)
   (move tmp 6 vec 0)
   (call glo 142 6)
   (move res 0 tmp 6)
   (new-vec 2)
   (move tmp 5 vec 0)
   (move tmp 6 vec 1)
   (call glo 11 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (move tmp 4 vec 0)
   (move tmp 5 vec 1)
   (call glo 152 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (load bool 0 vec 0)
   (call glo 180 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move tmp 5 vec 0)
   (call glo 142 5)
   (move res 0 tmp 5)
   (new-vec 3)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (move tmp 5 vec 2)
   (call glo 148 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (load bool 0 vec 0)
   (call glo 180 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move tmp 4 vec 0)
   (call glo 142 4)
   (move res 0 tmp 4)
   (new-vec 3)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (move tmp 4 vec 2)
   (call glo 148 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 146 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 140 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 11)
   (label else%2541)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 141 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2542)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 232 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 140 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 11)
   (label else%2542)
   (new-vec 3)
   (load sym desugar-program vec 0)
   (load str "not a definition: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%206)
   (new-vec 1)
   (extend)
   (load close-deep 598 0 0)
   (new-vec 0)
   (load close-flat 599 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2543)
   (load sym ok res 0)
   (return)
   (label else%2543)
   (new-vec 3)
   (load sym check-for-multiple-definitions! vec 0)
   (load str "multiple definitions: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%207)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 137 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2544)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (load str "Desugaring" vec 0)
   (call glo 134 0)
   (load nil _ glo 228)
   (new-vec 2)
   (move glo 235 vec 0)
   (move 0 0 vec 1)
   (call glo 51 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 232 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str " / Desugared" vec 0)
   (call glo 135 0)
   (new-vec 1)
   (move glo 228 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (call glo 16 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 221)
   (label else%2544)
   (new-vec 2)
   (load sym desugar-program vec 0)
   (load str "not a parsed program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%208)
   (new-vec 3)
   (load sym Boxed-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%209)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2545)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2546)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Boxed-Program vec 1)
   (tail-call lib 40)
   (label else%2546)
   (load bool 0 res 0)
   (return)
   (label else%2545)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%210)
   (new-vec 4)
   (load sym Boxed-Abstraction vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%211)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2547)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2548)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Boxed-Abstraction vec 1)
   (tail-call lib 40)
   (label else%2548)
   (load bool 0 res 0)
   (return)
   (label else%2547)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%212)
   (new-vec 2)
   (load sym Boxed-Variable vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%213)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2549)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2550)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Boxed-Variable vec 1)
   (tail-call lib 40)
   (label else%2550)
   (load bool 0 res 0)
   (return)
   (label else%2549)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%214)
   (new-vec 5)
   (load sym Boxed-LetRecExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (move 0 3 vec 4)
   (tail-call lib 32)

   (label lambda-deep%215)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2551)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 5 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2552)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Boxed-LetRecExpr vec 1)
   (tail-call lib 40)
   (label else%2552)
   (load bool 0 res 0)
   (return)
   (label else%2551)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%216)
   (new-vec 2)
   (load sym Abstraction-val vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%217)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2553)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2554)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Abstraction-val vec 1)
   (tail-call lib 40)
   (label else%2554)
   (load bool 0 res 0)
   (return)
   (label else%2553)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%218)
   (new-vec 2)
   (load sym Abstraction-box vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%219)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2555)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2556)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Abstraction-box vec 1)
   (tail-call lib 40)
   (label else%2556)
   (load bool 0 res 0)
   (return)
   (label else%2555)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%220)
   (new-vec 3)
   (extend)
   (load close-deep 600 0 0)
   (load close-deep 601 0 1)
   (load close-deep 602 0 2)
   (new-vec 0)
   (load close-flat 603 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (load nil _ vec 2)
   (move tmp 0 vec 3)
   (tail-call 0 1)

   (label lambda-deep%221)
   (new-vec 4)
   (extend)
   (load close-deep 604 0 0)
   (load close-deep 605 0 1)
   (load close-deep 606 0 2)
   (load close-deep 607 0 3)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call glo 250 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (load nil _ vec 2)
   (tail-call 0 2)

   (label lambda-deep%222)
   (new-vec 1)
   (extend)
   (load close-deep 608 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%223)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 222 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2557)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (load str "Boxing" vec 0)
   (call glo 134 0)
   (new-vec 0)
   (load close-flat 609 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (call glo 252 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 1 0 vec 1)
   (call glo 251 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str " / Boxed" vec 0)
   (call glo 135 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 238)
   (label else%2557)
   (new-vec 2)
   (load sym box-program vec 0)
   (load str "not a desugared program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%224)
   (new-vec 3)
   (load sym Linearized-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%225)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2558)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2559)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Linearized-Program vec 1)
   (tail-call lib 40)
   (label else%2559)
   (load bool 0 res 0)
   (return)
   (label else%2558)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%226)
   (new-vec 3)
   (load sym LinDefExp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%227)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2560)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2561)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinDefExp vec 1)
   (tail-call lib 40)
   (label else%2561)
   (load bool 0 res 0)
   (return)
   (label else%2560)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%228)
   (new-vec 2)
   (load sym LinLiteral vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%229)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2562)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2563)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinLiteral vec 1)
   (tail-call lib 40)
   (label else%2563)
   (load bool 0 res 0)
   (return)
   (label else%2562)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%230)
   (new-vec 2)
   (load sym LinVariable vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%231)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2564)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2565)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinVariable vec 1)
   (tail-call lib 40)
   (label else%2565)
   (load bool 0 res 0)
   (return)
   (label else%2564)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%232)
   (new-vec 2)
   (load sym LinVariableTmp vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%233)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2566)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2567)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinVariableTmp vec 1)
   (tail-call lib 40)
   (label else%2567)
   (load bool 0 res 0)
   (return)
   (label else%2566)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%234)
   (new-vec 2)
   (load sym LinVariableJoin vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%235)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2568)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2569)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinVariableJoin vec 1)
   (tail-call lib 40)
   (label else%2569)
   (load bool 0 res 0)
   (return)
   (label else%2568)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%236)
   (new-vec 3)
   (load sym LinAbstraction vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%237)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2570)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2571)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinAbstraction vec 1)
   (tail-call lib 40)
   (label else%2571)
   (load bool 0 res 0)
   (return)
   (label else%2570)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%238)
   (new-vec 4)
   (load sym LinIfThenElse vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%239)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2572)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2573)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinIfThenElse vec 1)
   (tail-call lib 40)
   (label else%2573)
   (load bool 0 res 0)
   (return)
   (label else%2572)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%240)
   (new-vec 3)
   (load sym LinApplication vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%241)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2574)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2575)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinApplication vec 1)
   (tail-call lib 40)
   (label else%2575)
   (load bool 0 res 0)
   (return)
   (label else%2574)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%242)
   (new-vec 4)
   (load sym LinLetRecExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%243)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2576)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2577)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinLetRecExpr vec 1)
   (tail-call lib 40)
   (label else%2577)
   (load bool 0 res 0)
   (return)
   (label else%2576)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%244)
   (new-vec 3)
   (load sym LinAssign vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%245)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2578)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2579)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinAssign vec 1)
   (tail-call lib 40)
   (label else%2579)
   (load bool 0 res 0)
   (return)
   (label else%2578)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%246)
   (new-vec 3)
   (load sym LinAssignLam vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%247)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2580)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2581)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinAssignLam vec 1)
   (tail-call lib 40)
   (label else%2581)
   (load bool 0 res 0)
   (return)
   (label else%2580)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%248)
   (new-vec 3)
   (load sym LinAssignApp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%249)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2582)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2583)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinAssignApp vec 1)
   (tail-call lib 40)
   (label else%2583)
   (load bool 0 res 0)
   (return)
   (label else%2582)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%250)
   (new-vec 4)
   (load sym LinBindCmp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%251)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2584)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2585)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinBindCmp vec 1)
   (tail-call lib 40)
   (label else%2585)
   (load bool 0 res 0)
   (return)
   (label else%2584)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%252)
   (new-vec 4)
   (load sym LinBindVal vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%253)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2586)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2587)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinBindVal vec 1)
   (tail-call lib 40)
   (label else%2587)
   (load bool 0 res 0)
   (return)
   (label else%2586)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%254)
   (new-vec 2)
   (load sym LinReturn vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%255)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2588)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2589)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinReturn vec 1)
   (tail-call lib 40)
   (label else%2589)
   (load bool 0 res 0)
   (return)
   (label else%2588)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%256)
   (new-vec 4)
   (load sym LinBindJoin vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%257)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2590)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2591)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinBindJoin vec 1)
   (tail-call lib 40)
   (label else%2591)
   (load bool 0 res 0)
   (return)
   (label else%2590)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%258)
   (new-vec 4)
   (load sym LinSeq vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%259)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2592)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2593)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym LinSeq vec 1)
   (tail-call lib 40)
   (label else%2593)
   (load bool 0 res 0)
   (return)
   (label else%2592)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%260)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2594)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 258 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 284)
   (label else%2594)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2595)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 284)
   (label else%2595)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2596)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 284)
   (label else%2596)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2597)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 610 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (load close-flat 611 tmp 1)
   (new-vec 4)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (move tmp 1 vec 3)
   (tail-call glo 297)
   (label else%2597)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2598)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2599)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 612 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)
   (label else%2599)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 613 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2598)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2600)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 291)
   (label else%2600)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2601)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 614 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 272)
   (label else%2601)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2602)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 615 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2602)
   (new-vec 3)
   (load sym linearize-expression0 vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%261)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2603)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 290)
   (label else%2603)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 616 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 299)

   (label lambda-deep%262)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2604)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 264 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 258 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 270)
   (label else%2604)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2605)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 264 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 270)
   (label else%2605)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2606)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 264 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 262 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 270 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)
   (label else%2606)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2607)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 1 vec 2)
   (load close-flat 617 tmp 0)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 2 vec 2)
   (load close-flat 618 tmp 1)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (move tmp 1 vec 3)
   (tail-call glo 297)
   (label else%2607)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2608)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2609)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move 2 1 vec 2)
   (move 0 1 vec 3)
   (load close-flat 619 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)
   (label else%2609)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (load close-flat 620 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2608)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2610)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (tail-call glo 293)
   (label else%2610)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2611)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 621 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 292 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 272)
   (label else%2611)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2612)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 622 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2612)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%263)
   (new-vec 1)
   (extend)
   (load close-deep 623 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%264)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2613)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 258 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 1 2)
   (label else%2613)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2614)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 1 2)
   (label else%2614)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2615)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 262 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 2 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 282)
   (label else%2615)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2616)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (load str "join%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 0 vec 1)
   (call 2 2 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (move 2 1 vec 2)
   (load close-flat 624 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (load close-flat 625 tmp 2)
   (new-vec 4)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (call glo 297 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 286)
   (label else%2616)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2617)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2618)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move 2 1 vec 2)
   (move 0 1 vec 3)
   (load close-flat 626 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)
   (label else%2618)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 2 vec 1)
   (move 1 1 vec 2)
   (load close-flat 627 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2617)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2619)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (tail-call glo 296)
   (label else%2619)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2620)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 628 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 294 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 272)
   (label else%2620)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2621)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 629 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2621)
   (new-vec 3)
   (load sym linearize-expression2 vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%265)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2622)
   (new-vec 2)
   (load nil _ vec 0)
   (move 0 1 vec 1)
   (tail-call 0 2)
   (label else%2622)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 630 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 294)

   (label lambda-deep%266)
   (new-vec 1)
   (extend)
   (load close-deep 631 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%267)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2623)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 181 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2624)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2625)
   (new-vec 0)
   (tail-call 2 2)
   (label else%2625)
   (new-vec 0)
   (tail-call 2 3)
   (label else%2624)
   (new-vec 0)
   (tail-call 1 2)
   (label else%2623)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2626)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 1 2 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call 1 3 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 268)
   (label else%2626)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2627)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 0)
   (tail-call 1 2)
   (label else%2627)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2628)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (load str "join%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call 2 2 2)
   (move res 0 tmp 2)
   (new-vec 0)
   (call 2 3 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (move tmp 3 vec 2)
   (call glo 268 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (move 2 1 vec 2)
   (load close-flat 632 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (load close-flat 633 tmp 2)
   (new-vec 4)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (call glo 297 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 286)
   (label else%2628)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2629)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2630)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (move 2 1 vec 3)
   (move 0 1 vec 4)
   (load close-flat 634 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)
   (label else%2630)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 3 vec 1)
   (move 1 2 vec 2)
   (move 1 1 vec 3)
   (load close-flat 635 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2629)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2631)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (move 1 3 vec 4)
   (tail-call glo 298)
   (label else%2631)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2632)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 636 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move 1 3 vec 3)
   (call glo 297 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 272)
   (label else%2632)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2633)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 637 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2633)
   (new-vec 3)
   (load sym linearize-expression22 vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%268)
   (new-vec 1)
   (extend)
   (load close-deep 638 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%269)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2634)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (tail-call 1 2)
   (label else%2634)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2635)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (tail-call 1 2)
   (label else%2635)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2636)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 0)
   (tail-call 1 2)
   (label else%2636)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2637)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (load str "join%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 2 2 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (move 2 1 vec 2)
   (load close-flat 639 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (load close-flat 640 tmp 2)
   (new-vec 4)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (call glo 297 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 286)
   (label else%2637)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2638)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2639)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move 2 1 vec 2)
   (move 0 1 vec 3)
   (load close-flat 641 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)
   (label else%2639)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (load close-flat 642 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2638)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2640)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 643 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)
   (label else%2640)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2641)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 644 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 299 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 272)
   (label else%2641)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2642)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 645 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2642)
   (new-vec 3)
   (load sym linearize-expression3 vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%270)
   (new-vec 1)
   (extend)
   (load close-deep 646 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%271)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2643)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 258 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 274)
   (label else%2643)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2644)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 260 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 274)
   (label else%2644)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2645)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 276)
   (label else%2645)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2646)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 647 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (load close-flat 648 tmp 1)
   (new-vec 4)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (move tmp 1 vec 3)
   (call glo 297 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load nil _ vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load int 0 vec 0)
   (call glo 262 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call glo 270 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 278 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 282)
   (label else%2646)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2647)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2648)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (move 0 1 vec 2)
   (load close-flat 649 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)
   (label else%2648)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (load close-flat 650 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2647)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2649)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 651 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)
   (label else%2649)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2650)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 652 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (call glo 301 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 272)
   (label else%2650)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2651)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 653 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 294)
   (label else%2651)
   (new-vec 3)
   (load sym linearize-definiens vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%272)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 239 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2652)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (load str "Linearizing" vec 0)
   (call glo 134 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 300 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 290 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str " / Linearized" vec 0)
   (call glo 135 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 254)
   (label else%2652)
   (new-vec 2)
   (load sym linearized-program vec 0)
   (load str "not a boxed program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%273)
   (new-vec 3)
   (load sym Scoped-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%274)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2653)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2654)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Scoped-Program vec 1)
   (tail-call lib 40)
   (label else%2654)
   (load bool 0 res 0)
   (return)
   (label else%2653)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%275)
   (new-vec 3)
   (load sym ScoDefExp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%276)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2655)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2656)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoDefExp vec 1)
   (tail-call lib 40)
   (label else%2656)
   (load bool 0 res 0)
   (return)
   (label else%2655)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%277)
   (new-vec 2)
   (load sym ScoLiteral vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%278)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2657)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2658)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoLiteral vec 1)
   (tail-call lib 40)
   (label else%2658)
   (load bool 0 res 0)
   (return)
   (label else%2657)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%279)
   (new-vec 4)
   (load sym ScoVariable vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%280)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2659)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2660)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoVariable vec 1)
   (tail-call lib 40)
   (label else%2660)
   (load bool 0 res 0)
   (return)
   (label else%2659)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%281)
   (new-vec 2)
   (load sym ScoVariableTmp vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%282)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2661)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2662)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoVariableTmp vec 1)
   (tail-call lib 40)
   (label else%2662)
   (load bool 0 res 0)
   (return)
   (label else%2661)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%283)
   (new-vec 2)
   (load sym ScoVariableJoin vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%284)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2663)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2664)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoVariableJoin vec 1)
   (tail-call lib 40)
   (label else%2664)
   (load bool 0 res 0)
   (return)
   (label else%2663)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%285)
   (new-vec 3)
   (load sym ScoAbstraction-deep vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%286)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2665)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2666)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoAbstraction-deep vec 1)
   (tail-call lib 40)
   (label else%2666)
   (load bool 0 res 0)
   (return)
   (label else%2665)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%287)
   (new-vec 4)
   (load sym ScoAbstraction-flat vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%288)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2667)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2668)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoAbstraction-flat vec 1)
   (tail-call lib 40)
   (label else%2668)
   (load bool 0 res 0)
   (return)
   (label else%2667)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%289)
   (new-vec 4)
   (load sym ScoIfThenElse vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%290)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2669)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2670)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoIfThenElse vec 1)
   (tail-call lib 40)
   (label else%2670)
   (load bool 0 res 0)
   (return)
   (label else%2669)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%291)
   (new-vec 3)
   (load sym ScoApplication vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%292)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2671)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2672)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoApplication vec 1)
   (tail-call lib 40)
   (label else%2672)
   (load bool 0 res 0)
   (return)
   (label else%2671)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%293)
   (new-vec 4)
   (load sym ScoLetRecExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%294)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2673)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2674)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoLetRecExpr vec 1)
   (tail-call lib 40)
   (label else%2674)
   (load bool 0 res 0)
   (return)
   (label else%2673)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%295)
   (new-vec 3)
   (load sym ScoAssign vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%296)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2675)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2676)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoAssign vec 1)
   (tail-call lib 40)
   (label else%2676)
   (load bool 0 res 0)
   (return)
   (label else%2675)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%297)
   (new-vec 3)
   (load sym ScoAssignLam vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%298)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2677)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2678)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoAssignLam vec 1)
   (tail-call lib 40)
   (label else%2678)
   (load bool 0 res 0)
   (return)
   (label else%2677)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%299)
   (new-vec 3)
   (load sym ScoAssignApp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%300)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2679)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2680)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoAssignApp vec 1)
   (tail-call lib 40)
   (label else%2680)
   (load bool 0 res 0)
   (return)
   (label else%2679)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%301)
   (new-vec 4)
   (load sym ScoBindCmp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%302)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2681)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2682)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoBindCmp vec 1)
   (tail-call lib 40)
   (label else%2682)
   (load bool 0 res 0)
   (return)
   (label else%2681)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%303)
   (new-vec 4)
   (load sym ScoBindVal vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%304)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2683)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2684)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoBindVal vec 1)
   (tail-call lib 40)
   (label else%2684)
   (load bool 0 res 0)
   (return)
   (label else%2683)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%305)
   (new-vec 2)
   (load sym ScoReturn vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%306)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2685)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2686)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoReturn vec 1)
   (tail-call lib 40)
   (label else%2686)
   (load bool 0 res 0)
   (return)
   (label else%2685)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%307)
   (new-vec 4)
   (load sym ScoBindJoin vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%308)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2687)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2688)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoBindJoin vec 1)
   (tail-call lib 40)
   (label else%2688)
   (load bool 0 res 0)
   (return)
   (label else%2687)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%309)
   (new-vec 4)
   (load sym ScoSeq vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%310)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2689)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2690)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym ScoSeq vec 1)
   (tail-call lib 40)
   (label else%2690)
   (load bool 0 res 0)
   (return)
   (label else%2689)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%311)
   (new-vec 5)
   (extend)
   (load close-deep 654 0 0)
   (load close-deep 655 0 1)
   (load close-deep 656 0 2)
   (load close-deep 657 0 3)
   (load close-deep 658 0 4)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 267 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2691)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 659 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2692)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2692)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%2691)
   (new-vec 3)
   (load sym compute-freevars vec 0)
   (load str "not a lambda-abstraction: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%312)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2693)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 26)
   (label else%2693)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%313)
   (new-vec 1)
   (extend)
   (load close-deep 660 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%314)
   (new-vec 1)
   (extend)
   (load close-deep 661 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%315)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 259 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2694)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 307)
   (label else%2694)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 261 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2695)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call glo 344)
   (label else%2695)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 263 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2696)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 311)
   (label else%2696)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 265 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2697)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 313)
   (label else%2697)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2698)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 341 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 662 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2699)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2699)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call tmp 0)
   (label else%2698)
   (new-vec 3)
   (load sym scope-value vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%316)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 269 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2700)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 345 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 346 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 319)
   (label else%2700)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 271 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2701)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (load close-flat 663 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (tail-call glo 347)
   (label else%2701)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 273 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2702)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 664 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 323)
   (label else%2702)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 275 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2703)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2704)
   (new-vec 2)
   (move glo 130 vec 0)
   (move 1 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2705)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "unrecognized variable: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 120)
   (label else%2705)
   (new-vec 2)
   (load sym lib vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (move 3 1 vec 1)
   (move 3 2 vec 2)
   (call glo 345 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 325)
   (label else%2704)
   (new-vec 2)
   (load sym glo vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (call glo 345 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 325)
   (label else%2703)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 277 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2706)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2707)
   (new-vec 2)
   (move glo 130 vec 0)
   (move 1 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2708)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "unrecognized variable: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 120)
   (label else%2708)
   (new-vec 2)
   (load sym lib vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (load close-deep 665 tmp 1)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 267 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2709)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 1 vec 1)
   (call glo 342 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 2 vec 1)
   (move 4 2 vec 2)
   (call glo 346 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 315 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2709)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "not a lambda: ~s" vec 1)
   (move 2 1 vec 2)
   (call glo 120 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2707)
   (new-vec 2)
   (load sym glo vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (load close-deep 666 tmp 1)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 267 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2710)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 1 vec 1)
   (call glo 342 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 2 vec 1)
   (move 3 2 vec 2)
   (call glo 346 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 315 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2710)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "not a lambda: ~s" vec 1)
   (move 1 1 vec 2)
   (call glo 120 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2706)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 279 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2711)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2712)
   (new-vec 2)
   (move glo 130 vec 0)
   (move 1 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2713)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "unrecognized variable: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 120)
   (label else%2713)
   (new-vec 2)
   (load sym lib vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (move 3 1 vec 1)
   (move 3 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 329)
   (label else%2712)
   (new-vec 2)
   (load sym glo vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 329)
   (label else%2711)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 281 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2714)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 348 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 331)
   (label else%2714)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 283 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2715)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 345 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 333)
   (label else%2715)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 285 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2716)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 345 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 335)
   (label else%2716)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 287 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2717)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load close-deep 667 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 267 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2718)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (move 2 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 315 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2718)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "unexpected LinBindJoin expression: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2717)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 289 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2719)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 348 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 339)
   (label else%2719)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%317)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2720)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (move 1 3 vec 2)
   (call glo 346 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 315 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (tail-call glo 321)
   (label else%2720)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 2 vec 1)
   (move 0 3 vec 2)
   (call glo 345 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 321)

   (label lambda-deep%318)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 271 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2721)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (load close-flat 668 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 1 1 vec 2)
   (move 1 2 vec 3)
   (tail-call glo 347)
   (label else%2721)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 275 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2722)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 669 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2723)
   (new-vec 2)
   (move glo 130 vec 0)
   (move 1 0 vec 1)
   (call glo 343 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2724)
   (new-vec 3)
   (load sym scope-named vec 0)
   (load str "undeclared variable: ~s" vec 1)
   (move 2 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2724)
   (new-vec 2)
   (load sym lib vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2723)
   (new-vec 2)
   (load sym glo vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2722)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2725)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call glo 341 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 670 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2726)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2726)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call tmp 0)
   (label else%2725)
   (new-vec 3)
   (load sym scope-named vec 0)
   (load str "not a named computation: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%319)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 255 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2727)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (load str "Scoping" vec 0)
   (call glo 134 0)
   (new-vec 1)
   (extend)
   (load close-deep 671 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 672 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 3 1 vec 0)
   (load nil _ vec 1)
   (move 1 0 vec 2)
   (call glo 346 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str " / Scoped" vec 0)
   (call glo 135 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 303)
   (label else%2727)
   (new-vec 2)
   (load sym scope-program vec 0)
   (load str "not a linearized program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%320)
   (new-vec 5)
   (load sym Factorized-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (move 0 3 vec 4)
   (tail-call lib 32)

   (label lambda-deep%321)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2728)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 5 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2729)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Factorized-Program vec 1)
   (tail-call lib 40)
   (label else%2729)
   (load bool 0 res 0)
   (return)
   (label else%2728)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%322)
   (new-vec 3)
   (load sym FacDefExp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%323)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2730)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2731)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacDefExp vec 1)
   (tail-call lib 40)
   (label else%2731)
   (load bool 0 res 0)
   (return)
   (label else%2730)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%324)
   (new-vec 2)
   (load sym FacLiteral vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%325)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2732)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2733)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacLiteral vec 1)
   (tail-call lib 40)
   (label else%2733)
   (load bool 0 res 0)
   (return)
   (label else%2732)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%326)
   (new-vec 4)
   (load sym FacVariable vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%327)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2734)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2735)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacVariable vec 1)
   (tail-call lib 40)
   (label else%2735)
   (load bool 0 res 0)
   (return)
   (label else%2734)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%328)
   (new-vec 2)
   (load sym FacVariableTmp vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%329)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2736)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2737)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacVariableTmp vec 1)
   (tail-call lib 40)
   (label else%2737)
   (load bool 0 res 0)
   (return)
   (label else%2736)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%330)
   (new-vec 2)
   (load sym FacVariableJoin vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%331)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2738)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2739)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacVariableJoin vec 1)
   (tail-call lib 40)
   (label else%2739)
   (load bool 0 res 0)
   (return)
   (label else%2738)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%332)
   (new-vec 3)
   (load sym FacAbstraction-stay vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%333)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2740)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2741)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacAbstraction-stay vec 1)
   (tail-call lib 40)
   (label else%2741)
   (load bool 0 res 0)
   (return)
   (label else%2740)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%334)
   (new-vec 2)
   (load sym FacAbstraction-deep vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%335)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2742)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2743)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacAbstraction-deep vec 1)
   (tail-call lib 40)
   (label else%2743)
   (load bool 0 res 0)
   (return)
   (label else%2742)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%336)
   (new-vec 3)
   (load sym FacAbstraction-flat vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%337)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2744)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2745)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacAbstraction-flat vec 1)
   (tail-call lib 40)
   (label else%2745)
   (load bool 0 res 0)
   (return)
   (label else%2744)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%338)
   (new-vec 4)
   (load sym FacIfThenElse vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%339)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2746)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2747)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacIfThenElse vec 1)
   (tail-call lib 40)
   (label else%2747)
   (load bool 0 res 0)
   (return)
   (label else%2746)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%340)
   (new-vec 3)
   (load sym FacApplication vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%341)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2748)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2749)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacApplication vec 1)
   (tail-call lib 40)
   (label else%2749)
   (load bool 0 res 0)
   (return)
   (label else%2748)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%342)
   (new-vec 4)
   (load sym FacLetRecExpr vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%343)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2750)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2751)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacLetRecExpr vec 1)
   (tail-call lib 40)
   (label else%2751)
   (load bool 0 res 0)
   (return)
   (label else%2750)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%344)
   (new-vec 3)
   (load sym FacAssign vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%345)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2752)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2753)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacAssign vec 1)
   (tail-call lib 40)
   (label else%2753)
   (load bool 0 res 0)
   (return)
   (label else%2752)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%346)
   (new-vec 3)
   (load sym FacAssignLam vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%347)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2754)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2755)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacAssignLam vec 1)
   (tail-call lib 40)
   (label else%2755)
   (load bool 0 res 0)
   (return)
   (label else%2754)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%348)
   (new-vec 3)
   (load sym FacAssignApp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%349)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2756)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2757)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacAssignApp vec 1)
   (tail-call lib 40)
   (label else%2757)
   (load bool 0 res 0)
   (return)
   (label else%2756)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%350)
   (new-vec 4)
   (load sym FacBindCmp vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%351)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2758)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2759)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacBindCmp vec 1)
   (tail-call lib 40)
   (label else%2759)
   (load bool 0 res 0)
   (return)
   (label else%2758)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%352)
   (new-vec 4)
   (load sym FacBindVal vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%353)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2760)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2761)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacBindVal vec 1)
   (tail-call lib 40)
   (label else%2761)
   (load bool 0 res 0)
   (return)
   (label else%2760)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%354)
   (new-vec 2)
   (load sym FacReturn vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%355)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2762)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2763)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacReturn vec 1)
   (tail-call lib 40)
   (label else%2763)
   (load bool 0 res 0)
   (return)
   (label else%2762)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%356)
   (new-vec 4)
   (load sym FacBindJoin vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%357)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2764)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2765)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacBindJoin vec 1)
   (tail-call lib 40)
   (label else%2765)
   (load bool 0 res 0)
   (return)
   (label else%2764)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%358)
   (new-vec 4)
   (load sym FacSeq vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%359)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2766)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2767)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacSeq vec 1)
   (tail-call lib 40)
   (label else%2767)
   (load bool 0 res 0)
   (return)
   (label else%2766)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%360)
   (new-vec 2)
   (load sym FacInteger vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%361)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2768)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2769)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacInteger vec 1)
   (tail-call lib 40)
   (label else%2769)
   (load bool 0 res 0)
   (return)
   (label else%2768)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%362)
   (new-vec 2)
   (load sym FacBoolean vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%363)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2770)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2771)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacBoolean vec 1)
   (tail-call lib 40)
   (label else%2771)
   (load bool 0 res 0)
   (return)
   (label else%2770)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%364)
   (new-vec 2)
   (load sym FacString vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%365)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2772)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2773)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacString vec 1)
   (tail-call lib 40)
   (label else%2773)
   (load bool 0 res 0)
   (return)
   (label else%2772)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%366)
   (new-vec 2)
   (load sym FacCharacter vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%367)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2774)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2775)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacCharacter vec 1)
   (tail-call lib 40)
   (label else%2775)
   (load bool 0 res 0)
   (return)
   (label else%2774)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%368)
   (new-vec 2)
   (load sym FacSymbol vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%369)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2776)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2777)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacSymbol vec 1)
   (tail-call lib 40)
   (label else%2777)
   (load bool 0 res 0)
   (return)
   (label else%2776)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%370)
   (new-vec 1)
   (load sym FacNil vec 0)
   (tail-call lib 32)

   (label lambda-deep%371)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2778)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2779)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacNil vec 1)
   (tail-call lib 40)
   (label else%2779)
   (load bool 0 res 0)
   (return)
   (label else%2778)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%372)
   (new-vec 1)
   (load sym FacVoid vec 0)
   (tail-call lib 32)

   (label lambda-deep%373)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2780)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2781)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym FacVoid vec 1)
   (tail-call lib 40)
   (label else%2781)
   (load bool 0 res 0)
   (return)
   (label else%2780)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%374)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 320 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2782)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 0 2 vec 1)
   (move 1 3 vec 2)
   (load close-flat 673 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2782)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 322 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2783)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 316 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2784)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 2 3 vec 1)
   (move 0 0 vec 2)
   (load close-flat 674 tmp 0)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 406)
   (label else%2784)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 1 3 vec 1)
   (load close-flat 675 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2783)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 324 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2785)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (extend)
   (load close-deep 676 0 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 2 2 vec 1)
   (call 0 0 1)
   (move res 0 tmp 1)
   (new-vec 4)
   (move 2 3 vec 0)
   (move 1 0 vec 1)
   (move 2 1 vec 2)
   (move 1 1 vec 3)
   (load close-flat 677 tmp 2)
   (new-vec 4)
   (move 1 2 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (tail-call glo 404)
   (label else%2785)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 326 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2786)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 678 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2786)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 328 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2787)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 679 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2787)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 330 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2788)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 680 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)
   (label else%2788)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 332 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2789)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 3 vec 1)
   (move 0 0 vec 2)
   (load close-flat 681 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 407)
   (label else%2789)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 334 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2790)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 3 vec 1)
   (move 0 0 vec 2)
   (load close-flat 682 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2790)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 336 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2791)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 3 vec 0)
   (load close-flat 683 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2791)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 338 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2792)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 1 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (move 1 1 vec 2)
   (load close-flat 684 tmp 2)
   (new-vec 4)
   (move 0 2 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (tail-call glo 404)
   (label else%2792)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 340 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2793)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 3 vec 1)
   (move 0 0 vec 2)
   (load close-flat 685 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 407)
   (label else%2793)
   (new-vec 3)
   (load sym factorize-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%375)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 308 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2794)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 179 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2795)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 390 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2795)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 181 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2796)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 392 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2796)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 183 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2797)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 394 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2797)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 185 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2798)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 396 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2798)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 187 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2799)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 398 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2799)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 189 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2800)
   (new-vec 0)
   (extend)
   (new-vec 0)
   (call glo 400 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2800)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 191 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2801)
   (new-vec 0)
   (extend)
   (new-vec 0)
   (call glo 402 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 354 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (tail-call 2 3)
   (label else%2801)
   (new-vec 3)
   (load sym factorize-value vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%2794)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 310 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2802)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (call glo 356 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 1 3)
   (label else%2802)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 312 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2803)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 358 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 1 3)
   (label else%2803)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 314 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2804)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 360 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 1 3)
   (label else%2804)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 318 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2805)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 2 vec 1)
   (call glo 366 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call 1 3)
   (label else%2805)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 316 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2806)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 364 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call 1 3)
   (label else%2806)
   (new-vec 3)
   (load sym factorize-value vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%376)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2807)
   (new-vec 3)
   (load nil _ vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 0 3)
   (label else%2807)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 686 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 1 vec 3)
   (tail-call glo 405)

   (label lambda-deep%377)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 322 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2808)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 1 3 vec 1)
   (load close-flat 687 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2808)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 326 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2809)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 688 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 405)
   (label else%2809)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 318 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2810)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 2 vec 1)
   (call glo 366 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call 1 3)
   (label else%2810)
   (new-vec 3)
   (load sym factorize-named vec 0)
   (load str "not a named computation: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%378)
   (new-vec 1)
   (extend)
   (load close-deep 689 0 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (load nil _ vec 3)
   (tail-call 0 0)

   (label lambda-deep%379)
   (new-vec 1)
   (extend)
   (load close-deep 690 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 6)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (load nil _ vec 2)
   (move 1 0 vec 3)
   (load nil _ vec 4)
   (load nil _ vec 5)
   (tail-call 0 0)

   (label lambda-deep%380)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 304 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2811)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (load str "Factorizing" vec 0)
   (call glo 134 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (load close-flat 691 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (load nil _ vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 408)
   (label else%2811)
   (new-vec 2)
   (load sym factorize-program vec 0)
   (load str "not a scoped program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%381)
   (new-vec 7)
   (load sym Compiled-Program vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (move 0 3 vec 4)
   (move 0 4 vec 5)
   (move 0 5 vec 6)
   (tail-call lib 32)

   (label lambda-deep%382)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2812)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 7 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2813)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Compiled-Program vec 1)
   (tail-call lib 40)
   (label else%2813)
   (load bool 0 res 0)
   (return)
   (label else%2812)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%383)
   (new-vec 1)
   (extend)
   (load close-deep 692 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%384)
   (new-vec 1)
   (extend)
   (load close-deep 693 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%385)
   (new-vec 1)
   (extend)
   (load close-deep 694 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%386)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 369 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2814)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (load str "else%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 695 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2814)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 371 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2815)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (load close-deep 696 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 363 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2816)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 416 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move glo 0 vec 0)
   (move tmp 2 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 414 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2816)
   (new-vec 0)
   (load close-flat 697 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 417 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 414 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2815)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 373 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2817)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 415 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 1 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2817)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 375 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2818)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 698 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2818)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 377 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2819)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 699 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2819)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 379 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2820)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 371 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2821)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (load close-flat 700 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 417 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 414 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2821)
   (new-vec 3)
   (load sym codegen-expression vec 0)
   (load str "not an assigned application: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)
   (label else%2820)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 381 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2822)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 416 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 418)
   (label else%2822)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 383 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2823)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 701 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2823)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 385 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2824)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (load close-flat 702 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2824)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 387 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2825)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 365 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2826)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 5)
   (load sym load vec 0)
   (load sym close-deep vec 1)
   (move 0 0 vec 2)
   (load sym tmp vec 3)
   (move 1 0 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2826)
   (new-vec 3)
   (load sym codegen-expression vec 0)
   (load str "not a deep abstraction: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)
   (label else%2825)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 389 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2827)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 371 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2828)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 0 vec 1)
   (load close-flat 703 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 417 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 414 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2828)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 375 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2829)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 704 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2829)
   (new-vec 3)
   (load sym codegen-expression vec 0)
   (load str "not a sequenced computation: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)
   (label else%2827)
   (new-vec 3)
   (load sym codegen-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%387)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 355 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2830)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 391 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2831)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (load sym load vec 0)
   (load sym int vec 1)
   (move 0 0 vec 2)
   (tail-call 2 1)
   (label else%2831)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 393 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2832)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 705 tmp 0)
   (jump-if-false 0 0 else%2833)
   (new-vec 1)
   (load int 1 vec 0)
   (tail-call tmp 0)
   (label else%2833)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call tmp 0)
   (label else%2832)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 395 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2834)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (load sym load vec 0)
   (load sym str vec 1)
   (move 0 0 vec 2)
   (tail-call 2 1)
   (label else%2834)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 397 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2835)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym load vec 0)
   (load sym char vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 1)
   (label else%2835)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 399 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2836)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (load sym load vec 0)
   (load sym sym vec 1)
   (move 0 0 vec 2)
   (tail-call 2 1)
   (label else%2836)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 401 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2837)
   (new-vec 0)
   (extend)
   (new-vec 3)
   (load sym load vec 0)
   (load sym nil vec 1)
   (load sym _ vec 2)
   (tail-call 2 1)
   (label else%2837)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 403 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2838)
   (new-vec 0)
   (extend)
   (new-vec 3)
   (load sym load vec 0)
   (load sym void vec 1)
   (load sym _ vec 2)
   (tail-call 2 1)
   (label else%2838)
   (new-vec 3)
   (load sym codegen-value vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%2830)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 357 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2839)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (load sym move vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 1)
   (label else%2839)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 359 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2840)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (load sym move vec 0)
   (load sym tmp vec 1)
   (move 0 0 vec 2)
   (tail-call 1 1)
   (label else%2840)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 361 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2841)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (load sym move vec 0)
   (load sym tmp vec 1)
   (move 0 0 vec 2)
   (tail-call 1 1)
   (label else%2841)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 367 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2842)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym load vec 0)
   (load sym close-flat vec 1)
   (move 0 0 vec 2)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 413 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2842)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 365 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2843)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (load sym load vec 0)
   (load sym close-deep vec 1)
   (move 0 0 vec 2)
   (tail-call 1 1)
   (label else%2843)
   (new-vec 3)
   (load sym codegen-value vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%388)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 371 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2844)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (load close-flat 706 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 417 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 414 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2844)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 375 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2845)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 707 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 417)
   (label else%2845)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 367 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2846)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym new-vec vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 5)
   (load sym load vec 0)
   (load sym close-flat vec 1)
   (move 0 0 vec 2)
   (load sym tmp vec 3)
   (move 1 1 vec 4)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 413 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2846)
   (new-vec 3)
   (load sym codegen-named vec 0)
   (load str "not a named computation: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%389)
   (new-vec 0)
   (load close-flat 708 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 47)

   (label lambda-deep%390)
   (new-vec 0)
   (load close-flat 709 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 47)

   (label lambda-deep%391)
   (new-vec 1)
   (extend)
   (load close-deep 710 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int -1 vec 1)
   (tail-call 0 0)

   (label lambda-deep%392)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 351 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2847)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (extend)
   (new-vec 1)
   (load str "Generating code" vec 0)
   (call glo 134 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 419 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 416 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 2 3 vec 0)
   (call glo 420 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str " / Code generated" vec 0)
   (call glo 135 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (call glo 16 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 4 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 421 1)
   (move res 0 tmp 1)
   (new-vec 6)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (load int 1 vec 2)
   (move 4 2 vec 3)
   (move 0 0 vec 4)
   (move glo 129 vec 5)
   (tail-call glo 411)
   (label else%2847)
   (new-vec 2)
   (load sym codegen-program vec 0)
   (load str "not a factorized program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%393)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 412 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2848)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 5 vec 1)
   (call lib 36 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 6 vec 1)
   (call lib 36 5)
   (move res 0 tmp 5)
   (new-vec 6)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (move tmp 4 vec 4)
   (move tmp 5 vec 5)
   (extend)
   (new-vec 2)
   (load str "(DAIMI-SchemeE03" vec 0)
   (move 1 1 vec 1)
   (call glo 118 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 103 0)
   (new-vec 2)
   (load str "  (" vec 0)
   (move 1 1 vec 1)
   (call glo 118 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call glo 116 0)
   (new-vec 2)
   (move glo 80 vec 0)
   (move 1 1 vec 1)
   (call lib 54 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (call glo 116 0)
   (new-vec 2)
   (move glo 80 vec 0)
   (move 1 1 vec 1)
   (call lib 54 0)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (call glo 116 0)
   (new-vec 2)
   (load char 41 vec 0)
   (move 1 1 vec 1)
   (call lib 54 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 103 0)
   (load close-deep 711 tmp 0)
   (new-vec 1)
   (move 0 3 vec 0)
   (call lib 31 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2849)
   (new-vec 2)
   (load str "  ()" vec 0)
   (move 1 1 vec 1)
   (call glo 118 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2849)
   (new-vec 2)
   (load str "  (" vec 0)
   (move 1 1 vec 1)
   (call glo 118 1)
   (new-vec 1)
   (move 0 3 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call glo 116 1)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 712 tmp 1)
   (new-vec 1)
   (move 0 3 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 52 1)
   (new-vec 2)
   (load str ")" vec 0)
   (move 1 1 vec 1)
   (call glo 118 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2848)
   (new-vec 3)
   (load sym dump-compiled-program vec 0)
   (load str "not a compiled program: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%394)
   (new-vec 1)
   (load sym DS-nil vec 0)
   (tail-call lib 32)

   (label lambda-deep%395)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2850)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2851)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-nil vec 1)
   (tail-call lib 40)
   (label else%2851)
   (load bool 0 res 0)
   (return)
   (label else%2850)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%396)
   (new-vec 1)
   (load sym DS-false vec 0)
   (tail-call lib 32)

   (label lambda-deep%397)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2852)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2853)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-false vec 1)
   (tail-call lib 40)
   (label else%2853)
   (load bool 0 res 0)
   (return)
   (label else%2852)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%398)
   (new-vec 1)
   (load sym DS-true vec 0)
   (tail-call lib 32)

   (label lambda-deep%399)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2854)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2855)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-true vec 1)
   (tail-call lib 40)
   (label else%2855)
   (load bool 0 res 0)
   (return)
   (label else%2854)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%400)
   (new-vec 2)
   (load sym DS-integer vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%401)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2856)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2857)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-integer vec 1)
   (tail-call lib 40)
   (label else%2857)
   (load bool 0 res 0)
   (return)
   (label else%2856)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%402)
   (new-vec 2)
   (load sym DS-char vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%403)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2858)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2859)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-char vec 1)
   (tail-call lib 40)
   (label else%2859)
   (load bool 0 res 0)
   (return)
   (label else%2858)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%404)
   (new-vec 2)
   (load sym DS-string vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%405)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2860)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2861)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-string vec 1)
   (tail-call lib 40)
   (label else%2861)
   (load bool 0 res 0)
   (return)
   (label else%2860)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%406)
   (new-vec 2)
   (load sym DS-symbol vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%407)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2862)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2863)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-symbol vec 1)
   (tail-call lib 40)
   (label else%2863)
   (load bool 0 res 0)
   (return)
   (label else%2862)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%408)
   (new-vec 4)
   (load sym DS-closure vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%409)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2864)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2865)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-closure vec 1)
   (tail-call lib 40)
   (label else%2865)
   (load bool 0 res 0)
   (return)
   (label else%2864)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%410)
   (new-vec 4)
   (load sym DS-primitive vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (tail-call lib 32)

   (label lambda-deep%411)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2866)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2867)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-primitive vec 1)
   (tail-call lib 40)
   (label else%2867)
   (load bool 0 res 0)
   (return)
   (label else%2866)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%412)
   (new-vec 2)
   (load sym DS-continuation vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%413)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2868)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2869)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-continuation vec 1)
   (tail-call lib 40)
   (label else%2869)
   (load bool 0 res 0)
   (return)
   (label else%2868)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%414)
   (new-vec 3)
   (load sym DS-pair vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (tail-call lib 32)

   (label lambda-deep%415)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2870)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2871)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-pair vec 1)
   (tail-call lib 40)
   (label else%2871)
   (load bool 0 res 0)
   (return)
   (label else%2870)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%416)
   (new-vec 2)
   (load sym DS-vector vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%417)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2872)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2873)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-vector vec 1)
   (tail-call lib 40)
   (label else%2873)
   (load bool 0 res 0)
   (return)
   (label else%2872)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%418)
   (new-vec 2)
   (load sym DS-input-port vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%419)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2874)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2875)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-input-port vec 1)
   (tail-call lib 40)
   (label else%2875)
   (load bool 0 res 0)
   (return)
   (label else%2874)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%420)
   (new-vec 2)
   (load sym DS-output-port vec 0)
   (move 0 0 vec 1)
   (tail-call lib 32)

   (label lambda-deep%421)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2876)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2877)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-output-port vec 1)
   (tail-call lib 40)
   (label else%2877)
   (load bool 0 res 0)
   (return)
   (label else%2876)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%422)
   (new-vec 1)
   (load sym DS-eof-object vec 0)
   (tail-call lib 32)

   (label lambda-deep%423)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2878)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2879)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-eof-object vec 1)
   (tail-call lib 40)
   (label else%2879)
   (load bool 0 res 0)
   (return)
   (label else%2878)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%424)
   (new-vec 1)
   (load sym DS-undefined vec 0)
   (tail-call lib 32)

   (label lambda-deep%425)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2880)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2881)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-undefined vec 1)
   (tail-call lib 40)
   (label else%2881)
   (load bool 0 res 0)
   (return)
   (label else%2880)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%426)
   (new-vec 1)
   (load sym DS-void vec 0)
   (tail-call lib 32)

   (label lambda-deep%427)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2882)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2883)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym DS-void vec 1)
   (tail-call lib 40)
   (label else%2883)
   (load bool 0 res 0)
   (return)
   (label else%2882)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%428)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2884)
   (new-vec 0)
   (extend)
   (load nil _ res 0)
   (return)
   (label else%2884)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 427 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2885)
   (new-vec 0)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%2885)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 429 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2886)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2886)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 431 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2887)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%2887)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 433 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2888)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%2888)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 435 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2889)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%2889)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 437 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2890)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%2890)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 439 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2891)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load str "#<user-defined procedure>" res 0)
   (return)
   (label else%2891)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 441 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2892)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load close-deep 713 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2893)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%2893)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2892)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 443 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2894)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load str "#<continuation procedure>" res 0)
   (return)
   (label else%2894)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2895)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 463 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 463 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%2895)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 447 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2896)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 94 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 463 vec 0)
   (move tmp 0 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym vector vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%2896)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 449 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2897)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load str "#<input port>" res 0)
   (return)
   (label else%2897)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 451 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2898)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load str "#<output port>" res 0)
   (return)
   (label else%2898)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 453 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2899)
   (new-vec 0)
   (extend)
   (load str "#<eof object>" res 0)
   (return)
   (label else%2899)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 457 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2900)
   (new-vec 0)
   (extend)
   (load str "#<void object>" res 0)
   (return)
   (label else%2900)
   (new-vec 3)
   (load sym DS2S vec 0)
   (load str "not a DAIMI-Scheme value: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%429)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 714 tmp 0)
   (jump-if-false 0 0 else%2901)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%2901)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 35 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 1 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%430)
   (new-vec 2)
   (move 0 2 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 715 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-nil vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2902)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%2902)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-false vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2903)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym boolean vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2903)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-true vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2904)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym boolean vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2904)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-integer vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2905)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym integer vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2905)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-char vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2906)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym char vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2906)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-string vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2907)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym string vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2907)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-symbol vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2908)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym symbol vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2908)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-closure vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2909)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym procedure vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2909)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-primitive vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2910)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym procedure vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2910)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-continuation vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2911)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym procedure vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2911)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-pair vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2912)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym pair vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2912)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-vector vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2913)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym vector vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2913)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-input-port vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2914)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym input-port vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2914)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-output-port vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2915)
   (new-vec 2)
   (move 1 3 vec 0)
   (load sym output-port vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2915)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-eof-object vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2916)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%2916)
   (new-vec 3)
   (load sym check-type-one vec 0)
   (load str "not a DAIMI-Scheme value: ~s" vec 1)
   (move 1 2 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%431)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (load sym check-type vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (move 0 2 vec 3)
   (tail-call glo 465)

   (label lambda-deep%432)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (load sym check-type2 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (move 0 2 vec 3)
   (tail-call glo 465)

   (label lambda-deep%433)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 716 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%434)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 477 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2917)
   (load sym OK res 0)
   (return)
   (label else%2917)
   (new-vec 3)
   (load sym check-DS-proper-list? vec 0)
   (load str "not a proper list: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%435)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2918)
   (new-vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2919)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2919)
   (load bool 0 res 0)
   (return)
   (label else%2918)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 427 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2920)
   (new-vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 427 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2921)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2921)
   (load bool 0 res 0)
   (return)
   (label else%2920)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 429 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2922)
   (new-vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 429 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2923)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2923)
   (load bool 0 res 0)
   (return)
   (label else%2922)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 431 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2924)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 431 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2925)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 8)
   (label else%2925)
   (load bool 0 res 0)
   (return)
   (label else%2924)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 433 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2926)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 433 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2927)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 40)
   (label else%2927)
   (load bool 0 res 0)
   (return)
   (label else%2926)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 435 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2928)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 435 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2929)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 40)
   (label else%2929)
   (load bool 0 res 0)
   (return)
   (label else%2928)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 437 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2930)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 437 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2931)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 40)
   (label else%2931)
   (load bool 0 res 0)
   (return)
   (label else%2930)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 439 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2932)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 439 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2933)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 2 vec 1)
   (tail-call lib 40)
   (label else%2933)
   (load bool 0 res 0)
   (return)
   (label else%2932)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 441 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2934)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 441 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2935)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 40)
   (label else%2935)
   (load bool 0 res 0)
   (return)
   (label else%2934)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 443 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2936)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 443 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2937)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 40)
   (label else%2937)
   (load bool 0 res 0)
   (return)
   (label else%2936)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2938)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2939)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 40)
   (label else%2939)
   (load bool 0 res 0)
   (return)
   (label else%2938)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 447 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2940)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 447 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2941)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 40)
   (label else%2941)
   (load bool 0 res 0)
   (return)
   (label else%2940)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 449 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2942)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 449 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2943)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 40)
   (label else%2943)
   (load bool 0 res 0)
   (return)
   (label else%2942)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 451 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2944)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 451 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2945)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (tail-call lib 40)
   (label else%2945)
   (load bool 0 res 0)
   (return)
   (label else%2944)
   (new-vec 3)
   (load sym DS-eqv? vec 0)
   (load str "not a DAIMI-Scheme value: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%436)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 717 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%437)
   (new-vec 1)
   (extend)
   (load close-deep 718 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 95)

   (label lambda-deep%438)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2946)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%2946)
   (new-vec 3)
   (load sym DS-car vec 0)
   (load str "not a pair: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%439)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2947)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (move 0 1 res 0)
   (return)
   (label else%2947)
   (new-vec 3)
   (load sym DS-car vec 0)
   (load str "not a pair: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%440)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2948)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2948)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%441)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2949)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2949)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%442)
   (new-vec 1)
   (extend)
   (load close-deep 719 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 475 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2950)
   (move 0 0 res 0)
   (return)
   (label else%2950)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 476 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2951)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 474 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%2951)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%443)
   (new-vec 1)
   (extend)
   (load close-deep 720 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2952)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%2952)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2953)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call 1 0)
   (label else%2953)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%444)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 721 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-integer vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2954)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2954)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%445)
   (new-vec 3)
   (load sym + vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move lib 1 vec 1)
   (load int 0 vec 2)
   (call glo 480 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%446)
   (new-vec 3)
   (load sym - vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%447)
   (new-vec 3)
   (load sym * vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move lib 3 vec 1)
   (load int 1 vec 2)
   (call glo 480 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%448)
   (new-vec 3)
   (load sym quotient vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 4 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%449)
   (new-vec 3)
   (load sym remainder vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%450)
   (new-vec 3)
   (load sym < vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (load close-deep 722 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 6 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2955)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2955)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%451)
   (new-vec 3)
   (load sym <= vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (load close-deep 723 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 7 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2956)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2956)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%452)
   (new-vec 3)
   (load sym = vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (load close-deep 724 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 8 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2957)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2957)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%453)
   (new-vec 3)
   (load sym >= vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (load close-deep 725 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 9 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2958)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2958)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%454)
   (new-vec 3)
   (load sym > vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 468 0)
   (load close-deep 726 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 10 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2959)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2959)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%455)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 727 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-true vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2960)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2960)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-false vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2961)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2961)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%456)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 728 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-symbol vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2962)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2962)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%457)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 729 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-char vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2963)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2963)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%458)
   (new-vec 3)
   (load sym char->integer vec 0)
   (move 0 0 vec 1)
   (load sym char vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%459)
   (new-vec 3)
   (load sym integer->char vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 15 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 432 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%460)
   (new-vec 3)
   (load sym string vec 0)
   (move 0 0 vec 1)
   (load sym char vec 2)
   (call glo 468 0)
   (new-vec 0)
   (load close-flat 730 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 94 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 434 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%461)
   (new-vec 3)
   (load sym make-string vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 466 0)
   (new-vec 3)
   (load sym make-string vec 0)
   (move 0 0 vec 1)
   (load sym char vec 2)
   (call glo 467 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 17 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 434 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%462)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 731 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-string vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2964)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2964)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%463)
   (new-vec 3)
   (load sym string-length vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%464)
   (new-vec 3)
   (load sym string-append vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 468 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 434 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%465)
   (new-vec 3)
   (load sym string-=? vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 468 0)
   (load close-deep 732 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 21 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2965)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2965)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%466)
   (new-vec 3)
   (load sym string-ref vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 466 0)
   (new-vec 3)
   (load sym string-ref vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 467 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 733 tmp 0)
   (load close-deep 734 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 9 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2966)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 6 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2966)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 1)

   (label lambda-flat%467)
   (new-vec 3)
   (load sym string->symbol vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 436 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%468)
   (new-vec 3)
   (load sym symbol->string vec 0)
   (move 0 0 vec 1)
   (load sym symbol vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 434 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%469)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 735 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-pair vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2967)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2967)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%470)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 444 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%471)
   (new-vec 3)
   (load sym car vec 0)
   (move 0 0 vec 1)
   (load sym pair vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%472)
   (new-vec 3)
   (load sym cdr vec 0)
   (move 0 0 vec 1)
   (load sym pair vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%473)
   (new-vec 3)
   (load sym set-car! vec 0)
   (move 0 0 vec 1)
   (load sym pair vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (move tmp 1 vec 2)
   (call lib 37 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 462 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%474)
   (new-vec 3)
   (load sym set-car! vec 0)
   (move 0 0 vec 1)
   (load sym pair vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (move tmp 1 vec 2)
   (call lib 37 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 462 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%475)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 736 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-nil vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2968)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2968)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%476)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 481 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 446 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%477)
   (new-vec 3)
   (load sym make-vector vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 446 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%478)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 737 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-vector vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2969)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2969)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%479)
   (new-vec 3)
   (load sym vector-length vec 0)
   (move 0 0 vec 1)
   (load sym vector vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 430 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%480)
   (new-vec 3)
   (load sym vector-ref vec 0)
   (move 0 0 vec 1)
   (load sym vector vec 2)
   (call glo 466 0)
   (new-vec 3)
   (load sym vector-ref vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 467 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 738 tmp 0)
   (load close-deep 739 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 9 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2970)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 6 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2970)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 1)

   (label lambda-flat%481)
   (new-vec 3)
   (load sym vector-set! vec 0)
   (move 0 0 vec 1)
   (load sym vector vec 2)
   (call glo 466 0)
   (new-vec 3)
   (load sym vector-set! vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 467 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 740 tmp 0)
   (load close-deep 741 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 0 vec 1)
   (call lib 9 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%2971)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 6 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%2971)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 1)

   (label lambda-flat%482)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 742 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-closure vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2972)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2972)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-primitive vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2973)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2973)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-continuation vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2974)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2974)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%483)
   (load close-deep 743 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 470 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2975)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 0)
   (label else%2975)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%484)
   (new-vec 3)
   (load sym exit vec 0)
   (move 0 0 vec 1)
   (load sym integer vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (tail-call lib 36)

   (label lambda-flat%485)
   (new-vec 3)
   (load sym open-input-file vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 43 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 448 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%486)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 744 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-input-port vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2976)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2976)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%487)
   (new-vec 3)
   (load sym close-input-port vec 0)
   (move 0 0 vec 1)
   (load sym input-port vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 45 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 462 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%488)
   (new-vec 0)
   (call lib 46 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 448 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%489)
   (new-vec 3)
   (load sym read-char vec 0)
   (move 0 0 vec 1)
   (load sym input-port vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 745 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2977)
   (new-vec 0)
   (call glo 452 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2977)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 432 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%490)
   (new-vec 3)
   (load sym peek-char vec 0)
   (move 0 0 vec 1)
   (load sym input-port vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 746 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2978)
   (new-vec 0)
   (call glo 452 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2978)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 432 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%491)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 747 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-eof-object vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2979)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2979)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%492)
   (new-vec 3)
   (load sym open-output-file vec 0)
   (move 0 0 vec 1)
   (load sym string vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 450 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%493)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 748 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym DS-output-port vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%2980)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 460 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%2980)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 459 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%494)
   (new-vec 3)
   (load sym close-output-port vec 0)
   (move 0 0 vec 1)
   (load sym output-port vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 52 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 462 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%495)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 450 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-flat%496)
   (new-vec 3)
   (load sym write-char vec 0)
   (move 0 0 vec 1)
   (load sym char vec 2)
   (call glo 466 0)
   (new-vec 3)
   (load sym write-char vec 0)
   (move 0 0 vec 1)
   (load sym output-port vec 2)
   (call glo 467 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 54 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 462 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 0 1)

   (label lambda-deep%497)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 749 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 2 2 vec 1)
   (tail-call 0 0)

   (label lambda-deep%498)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 750 0 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%499)
   (new-vec 2)
   (move 0 1 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 751 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%500)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 752 0 0)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%501)
   (new-vec 0)
   (load close-flat 753 tmp 0)
   (new-vec 1)
   (extend)
   (load close-deep 754 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call 0 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 122 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 95 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 66 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 4 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int -1 vec 1)
   (call lib 33 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 4 0 vec 1)
   (load close-flat 755 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 756 0 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 glo 490)
   (new-vec 3)
   (move glo 490 vec 0)
   (move 3 0 vec 1)
   (load sym halt vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (call lib 33 0)
   (move res 0 glo 491)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 491 vec 0)
   (move 3 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 8 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%502)
   (new-vec 2)
   (move glo 493 vec 0)
   (load int 1000 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2981)
   (new-vec 2)
   (move glo 493 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 glo 493)
   (load void _ res 0)
   (return)
   (label else%2981)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "." vec 0)
   (move tmp 0 vec 1)
   (call glo 118 0)
   (load int 0 glo 493)
   (load void _ res 0)
   (return)

   (label lambda-deep%503)
   (new-vec 5)
   (load sym Control-frame vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move 0 2 vec 3)
   (move 0 3 vec 4)
   (tail-call lib 32)

   (label lambda-deep%504)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2982)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 5 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2983)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Control-frame vec 1)
   (tail-call lib 40)
   (label else%2983)
   (load bool 0 res 0)
   (return)
   (label else%2982)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%505)
   (new-vec 1)
   (load sym Control-frame-initial vec 0)
   (tail-call lib 32)

   (label lambda-deep%506)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2984)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2985)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym Control-frame-initial vec 1)
   (tail-call lib 40)
   (label else%2985)
   (load bool 0 res 0)
   (return)
   (label else%2984)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%507)
   (new-vec 3)
   (extend)
   (load close-deep 757 0 0)
   (load close-deep 758 0 1)
   (load close-deep 759 0 2)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call glo 497 1)
   (move res 0 tmp 1)
   (new-vec 4)
   (load int 0 vec 0)
   (load nil _ vec 1)
   (move tmp 0 vec 2)
   (move tmp 1 vec 3)
   (tail-call 0 0)

   (label lambda-deep%508)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 412 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2986)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 5 vec 1)
   (call lib 36 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 6 vec 1)
   (call lib 36 5)
   (move res 0 tmp 5)
   (new-vec 6)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (move tmp 4 vec 4)
   (move tmp 5 vec 5)
   (extend)
   (new-vec 1)
   (load str "Initializing " vec 0)
   (call glo 134 0)
   (new-vec 1)
   (move glo 479 vec 0)
   (call glo 481 0)
   (move res 0 glo 484)
   (new-vec 2)
   (move 0 0 vec 0)
   (move glo 461 vec 1)
   (call lib 33 0)
   (move res 0 glo 485)
   (new-vec 2)
   (move 0 1 vec 0)
   (move glo 458 vec 1)
   (call lib 33 0)
   (move res 0 glo 486)
   (new-vec 2)
   (move 0 2 vec 0)
   (move glo 458 vec 1)
   (call lib 33 0)
   (move res 0 glo 487)
   (new-vec 1)
   (move 0 3 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 33 0)
   (move res 0 glo 488)
   (new-vec 1)
   (extend)
   (load close-deep 760 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 2 3 vec 1)
   (call 0 0 0)
   (new-vec 1)
   (move 2 3 vec 0)
   (load close-flat 761 tmp 0)
   (new-vec 2)
   (move 2 4 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 492)
   (label else%2986)
   (new-vec 2)
   (load sym run-program vec 0)
   (load str "not a compiled program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%509)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2987)
   (new-vec 3)
   (load sym strip-Scheme-filename vec 0)
   (load str "not a file name: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%2987)
   (new-vec 2)
   (move 0 0 vec 0)
   (load str ".scm" vec 1)
   (call glo 85 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2988)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 19 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 4 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 84)
   (label else%2988)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%510)
   (new-vec 2)
   (move 0 0 vec 0)
   (load str ".scm" vec 1)
   (call glo 85 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2989)
   (move 0 0 res 0)
   (return)
   (label else%2989)
   (new-vec 2)
   (move 0 0 vec 0)
   (load str ".scm" vec 1)
   (tail-call lib 20)

   (label lambda-deep%511)
   (new-vec 0)
   (call glo 132 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 505 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 220 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 219 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 237 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 253 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 302 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 349 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 410 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 422)

   (label lambda-deep%512)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 506 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 412 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2990)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 5 vec 1)
   (call lib 36 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 6 vec 1)
   (call lib 36 5)
   (move res 0 tmp 5)
   (new-vec 6)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (move tmp 4 vec 4)
   (move tmp 5 vec 5)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 5)
   (load sym DAIMI-SchemeE03 vec 0)
   (move tmp 0 vec 1)
   (move 0 3 vec 2)
   (move 0 4 vec 3)
   (move 0 5 vec 4)
   (tail-call glo 11)
   (label else%2990)
   (new-vec 2)
   (move glo 507 vec 0)
   (load str "not a compiled program" vec 1)
   (tail-call glo 120)

   (label lambda-deep%513)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 504 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load str ".scm" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 506 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (load str ".dsa" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 762 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 102)

   (label lambda-deep%514)
   (load close-deep 763 tmp 0)
   (jump-if-false glo 503 else%2991)
   (new-vec 1)
   (move glo 463 vec 0)
   (tail-call tmp 0)
   (label else%2991)
   (new-vec 0)
   (load close-flat 764 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%515)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%516)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call 1 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%517)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2992)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 9)
   (label else%2992)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2993)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%2993)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%518)
   (new-vec 1)
   (extend)
   (load close-deep 765 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%519)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2994)
   (move 0 0 res 0)
   (return)
   (label else%2994)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2995)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2996)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2997)
   (move 0 0 res 0)
   (return)
   (label else%2997)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%2998)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%2998)
   (load bool 0 res 0)
   (return)
   (label else%2996)
   (load bool 0 res 0)
   (return)
   (label else%2995)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%520)
   (new-vec 2)
   (move 0 2 vec 0)
   (move 2 0 vec 1)
   (call lib 10 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%2999)
   (move 0 0 res 0)
   (return)
   (label else%2999)
   (new-vec 1)
   (extend)
   (load close-deep 766 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3000)
   (new-vec 3)
   (load sym test-proper-list? vec 0)
   (load str "length ~s, cycle 0" vec 1)
   (move 2 2 vec 2)
   (tail-call glo 120)
   (label else%3000)
   (new-vec 1)
   (load int 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%521)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3001)
   (move 2 1 res 0)
   (return)
   (label else%3001)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%522)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3002)
   (move 0 1 res 0)
   (return)
   (label else%3002)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%523)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3003)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 1 0)
   (label else%3003)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%524)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3004)
   (new-vec 4)
   (load sym list-ref vec 0)
   (load str "offset ~s is out of range for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 120)
   (label else%3004)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3005)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call lib 27)
   (label else%3005)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%525)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3006)
   (new-vec 4)
   (load sym ref-list vec 0)
   (load str "~s is not in ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 120)
   (label else%3006)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3007)
   (move 0 1 res 0)
   (return)
   (label else%3007)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%526)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3008)
   (new-vec 4)
   (load sym list-set! vec 0)
   (load str "offset ~s is out of range for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 0 vec 3)
   (tail-call glo 120)
   (label else%3008)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3009)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 3 2 vec 1)
   (call lib 29 0)
   (move 0 0 res 0)
   (return)
   (label else%3009)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%527)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3010)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3011)
   (move 0 0 res 0)
   (return)
   (label else%3011)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%3010)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%528)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3012)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3013)
   (move 0 0 res 0)
   (return)
   (label else%3013)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%3012)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%529)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 18 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 8)

   (label lambda-deep%530)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3014)
   (load nil _ res 0)
   (return)
   (label else%3014)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%531)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3015)
   (load nil _ res 0)
   (return)
   (label else%3015)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 16)

   (label lambda-deep%532)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3016)
   (load bool 1 res 0)
   (return)
   (label else%3016)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3017)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%3017)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%533)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3018)
   (load bool 0 res 0)
   (return)
   (label else%3018)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3019)
   (move 0 0 res 0)
   (return)
   (label else%3019)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%534)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3020)
   (load nil _ res 0)
   (return)
   (label else%3020)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 44 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 45 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%535)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3021)
   (load nil _ res 0)
   (return)
   (label else%3021)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 44 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 45 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 16)

   (label lambda-deep%536)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3022)
   (load nil _ res 0)
   (return)
   (label else%3022)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%537)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3023)
   (load nil _ res 0)
   (return)
   (label else%3023)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 44 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%538)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3024)
   (move 2 1 res 0)
   (return)
   (label else%3024)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%539)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3025)
   (move 0 1 res 0)
   (return)
   (label else%3025)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%540)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3026)
   (move 2 1 res 0)
   (return)
   (label else%3026)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%541)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3027)
   (move 0 1 res 0)
   (return)
   (label else%3027)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%542)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3028)
   (move 2 1 res 0)
   (return)
   (label else%3028)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 44 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)

   (label lambda-deep%543)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3029)
   (move 0 1 res 0)
   (return)
   (label else%3029)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 45 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 44 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 39 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%544)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3030)
   (load nil _ res 0)
   (return)
   (label else%3030)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3031)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3031)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%545)
   (move 0 0 res 0)
   (return)

   (label lambda-flat%546)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%547)
   (jump-if-false 0 0 else%3032)
   (load bool 1 res 0)
   (return)
   (label else%3032)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%548)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 2 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3033)
   (load bool 0 res 0)
   (return)
   (label else%3033)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3034)
   (load bool 1 res 0)
   (return)
   (label else%3034)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 14 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 1 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 14 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3035)
   (load bool 1 res 0)
   (return)
   (label else%3035)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 10 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3036)
   (load bool 0 res 0)
   (return)
   (label else%3036)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)

   (label lambda-deep%549)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (call lib 9 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3037)
   (load nil _ res 0)
   (return)
   (label else%3037)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%550)
   (jump-if-false 0 0 else%3038)
   (new-vec 1)
   (move 2 1 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 39)
   (label else%3038)
   (new-vec 5)
   (load sym substring vec 0)
   (load str "~s and ~s are not valid start/end indices for ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 2 vec 3)
   (move 2 0 vec 4)
   (tail-call glo 120)

   (label lambda-deep%551)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3039)
   (load nil _ res 0)
   (return)
   (label else%3039)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3040)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%3040)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%552)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 10 vec 1)
   (call lib 5 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "0123456789" vec 0)
   (move tmp 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 10 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3041)
   (move 0 0 res 0)
   (return)
   (label else%3041)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 10 vec 1)
   (call lib 4 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 2 0)

   (label lambda-deep%553)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 91 0)
   (move res 0 tmp 0)
   (load close-deep 767 tmp 1)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3042)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3042)
   (load close-deep 768 tmp 2)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3043)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call 1 0 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3043)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 91 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (call lib 26 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 16 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move glo 80 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (load char 46 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)

   (label lambda-deep%554)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3044)
   (new-vec 2)
   (load char 41 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)
   (label else%3044)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 91 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 16 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 80 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%555)
   (new-vec 2)
   (load char 40 vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 16 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load char 35 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%556)
   (new-vec 3)
   (extend)
   (load close-deep 769 0 0)
   (load close-deep 770 0 1)
   (load close-deep 771 0 2)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3045)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 2 1)
   (label else%3045)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)

   (label lambda-deep%557)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3046)
   (load nil _ res 0)
   (return)
   (label else%3046)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 126 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3047)
   (new-vec 3)
   (load sym format vec 0)
   (load str "too many arguments for ~s" vec 1)
   (move 4 0 vec 2)
   (tail-call glo 120)
   (label else%3047)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3048)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 2)
   (label else%3048)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%558)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3049)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 120)
   (label else%3049)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%559)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3050)
   (load nil _ res 0)
   (return)
   (label else%3050)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%560)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3051)
   (move 2 0 res 0)
   (return)
   (label else%3051)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%561)
   (jump-if-false 0 0 else%3052)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 0 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 15)
   (label else%3052)
   (new-vec 3)
   (load sym integer->digit vec 0)
   (load str "non-digitable integer: ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%562)
   (jump-if-false 0 0 else%3053)
   (new-vec 3)
   (load sym string->integer vec 0)
   (load str "invalid string: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 120)
   (label else%3053)
   (new-vec 1)
   (extend)
   (load close-deep 772 0 0)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 45 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3054)
   (new-vec 2)
   (load int 1 vec 0)
   (load int 0 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 2)
   (label else%3054)
   (new-vec 2)
   (load int 0 vec 0)
   (load int 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%563)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 1 0 vec 1)
   (load close-flat 773 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 104)

   (label lambda-deep%564)
   (new-vec 4)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (move 2 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 774 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 105)

   (label lambda-flat%565)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%566)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 97 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3055)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (load int 10 vec 0)
   (move 1 1 vec 1)
   (call lib 3 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 98 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 109)
   (label else%3055)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3056)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 1 0)
   (label else%3056)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 775 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 2 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 110)

   (label lambda-flat%567)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-deep%568)
   (new-vec 4)
   (move 2 2 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 776 tmp 0)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 777 tmp 1)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)

   (label lambda-flat%569)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 110 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3057)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3058)
   (new-vec 1)
   (load char 110 vec 0)
   (tail-call 2 1)
   (label else%3058)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3059)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 778 tmp 0)
   (new-vec 0)
   (load close-flat 779 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3059)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\n~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%3057)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 115 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3060)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3061)
   (new-vec 1)
   (load char 115 vec 0)
   (tail-call 2 1)
   (label else%3061)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 112 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3062)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 780 tmp 0)
   (new-vec 0)
   (load close-flat 781 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3062)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\s~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%3060)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 116 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3063)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3064)
   (new-vec 1)
   (load char 116 vec 0)
   (tail-call 2 1)
   (label else%3064)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 97 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3065)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 1 vec 1)
   (load close-flat 782 tmp 0)
   (new-vec 0)
   (load close-flat 783 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3065)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\t~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%3063)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 784 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 785 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)

   (label lambda-flat%570)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-deep%571)
   (new-vec 4)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (move 1 0 vec 2)
   (move 0 0 vec 3)
   (load close-flat 786 tmp 0)
   (new-vec 0)
   (load close-flat 787 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)

   (label lambda-deep%572)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (load close-flat 788 tmp 0)
   (new-vec 0)
   (load close-flat 789 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)

   (label lambda-deep%573)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 790 tmp 0)
   (new-vec 0)
   (load close-flat 791 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 107)

   (label lambda-flat%574)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 40 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3066)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 1 0)
   (label else%3066)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 91 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3067)
   (new-vec 1)
   (move 1 2 vec 0)
   (tail-call 1 1)
   (label else%3067)
   (load close-deep 792 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3068)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3068)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%575)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 793 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 41)

   (label lambda-flat%576)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 54)

   (label lambda-flat%577)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 34 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3069)
   (load nil _ res 0)
   (return)
   (label else%3069)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call lib 54)

   (label lambda-deep%578)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3070)
   (load str "" res 0)
   (return)
   (label else%3070)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 47 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3071)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 84)
   (label else%3071)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%579)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 103 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "DAIMI-Scheme: error in error." vec 0)
   (move tmp 0 vec 1)
   (call glo 118 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 103 0)
   (new-vec 1)
   (load int 3 vec 0)
   (tail-call lib 42)

   (label lambda-deep%580)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 118 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str " -- " vec 0)
   (move tmp 0 vec 1)
   (call glo 118 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 93 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 118 0)
   (new-vec 0)
   (call lib 53 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 103 0)
   (new-vec 1)
   (load int 2 vec 0)
   (tail-call lib 42)

   (label lambda-deep%581)
   (jump-if-false 0 0 else%3072)
   (move 2 1 res 0)
   (return)
   (label else%3072)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (load close-flat 794 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 61 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 122 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 4 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 63 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 2 vec 1)
   (call glo 122 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (call glo 121 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 4 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 121)

   (label lambda-flat%582)
   (new-vec 1)
   (extend)
   (load close-deep 795 0 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 0 0)

   (label lambda-deep%583)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 69 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3073)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call lib 31)
   (label else%3073)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3074)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 2 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%3074)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%584)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-flat%585)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3075)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym else vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3076)
   (move 0 0 res 0)
   (return)
   (label else%3076)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3077)
   (new-vec 0)
   (load close-flat 796 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 48)
   (label else%3077)
   (load bool 0 res 0)
   (return)
   (label else%3075)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%586)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call glo 196 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3078)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load sym else vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3079)
   (move 0 0 res 0)
   (return)
   (label else%3079)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3080)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 192 vec 0)
   (move tmp 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3081)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 193)
   (label else%3081)
   (load bool 0 res 0)
   (return)
   (label else%3080)
   (load bool 0 res 0)
   (return)
   (label else%3078)
   (load bool 0 res 0)
   (return)

   (label lambda-flat%587)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-flat%588)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-flat%589)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (tail-call glo 196)

   (label lambda-deep%590)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3082)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 11)
   (label else%3082)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 217 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%591)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3083)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 217 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 136)
   (label else%3083)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 197 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3084)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 215 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%3084)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 198 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3085)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 218 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%3085)
   (new-vec 3)
   (load sym parse-program vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%592)
   (new-vec 1)
   (extend)
   (load close-deep 797 0 0)
   (new-vec 0)
   (tail-call 0 0)

   (label lambda-flat%593)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%594)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3086)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 1 0 res 0)
   (return)
   (label else%3086)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3087)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call glo 127 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3088)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call lib 28)
   (label else%3088)
   (move 2 0 res 0)
   (return)
   (label else%3087)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3089)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 798 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3090)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load str "%" vec 1)
   (call lib 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 133 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3090)
   (new-vec 0)
   (load close-flat 799 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3089)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3091)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 1 vec 1)
   (move 2 0 vec 2)
   (load close-flat 800 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 2 vec 1)
   (move 2 0 vec 2)
   (load close-flat 801 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 233)
   (label else%3091)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3092)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 2 0 vec 1)
   (load close-flat 802 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 234)
   (label else%3092)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 155 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3093)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 803 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 0 0)
   (label else%3093)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 157 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3094)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 4)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 2 1 vec 2)
   (move 3 0 vec 3)
   (load close-flat 804 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 230 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3095)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)
   (label else%3095)
   (new-vec 1)
   (load str "case%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3094)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 159 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3096)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 4)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 3 0 vec 2)
   (move 2 1 vec 3)
   (load close-flat 805 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 230 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3097)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)
   (label else%3097)
   (new-vec 1)
   (load str "case-record%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3096)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 161 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3098)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 806 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3099)
   (new-vec 1)
   (load bool 1 vec 0)
   (call glo 180 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%3099)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)
   (label else%3098)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 163 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3100)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 807 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3101)
   (new-vec 1)
   (load bool 0 vec 0)
   (call glo 180 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%3101)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 0 0)
   (label else%3100)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 165 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3102)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 808 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 144 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 1 vec 2)
   (call glo 231 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move tmp 0 vec 1)
   (call 3 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 3 0 vec 1)
   (load close-flat 809 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3102)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 167 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3103)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 810 0 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (move 2 1 vec 2)
   (tail-call 0 0)
   (label else%3103)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3104)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 0)
   (load close-flat 811 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 144 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 2 1 vec 2)
   (call glo 231 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (load close-flat 812 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 0 0 vec 1)
   (call 4 0 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 168)
   (label else%3104)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 171 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3105)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 7)
   (extend)
   (load close-deep 813 0 0)
   (load close-deep 814 0 1)
   (load close-deep 815 0 2)
   (load close-deep 816 0 3)
   (load close-deep 817 0 4)
   (load close-deep 818 0 5)
   (load close-deep 819 0 6)
   (new-vec 2)
   (move 1 0 vec 0)
   (load nil _ vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 0 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 6)
   (label else%3105)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 173 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3106)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load nil _ vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 146)
   (label else%3106)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 175 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3107)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str "delay%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load str "delay-tmp%" vec 0)
   (call glo 133 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load sym vector-ref vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 0 vec 0)
   (call glo 178 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call glo 142 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 152 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (load sym vector-ref vec 0)
   (call glo 144 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (load int 1 vec 0)
   (call glo 178 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move tmp 4 vec 0)
   (call glo 142 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 152 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (load sym vector-set! vec 0)
   (call glo 144 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (load int 1 vec 0)
   (call glo 178 6)
   (move res 0 tmp 6)
   (new-vec 1)
   (move tmp 6 vec 0)
   (call glo 142 6)
   (move res 0 tmp 6)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 144 7)
   (move res 0 tmp 7)
   (new-vec 3)
   (move tmp 5 vec 0)
   (move tmp 6 vec 1)
   (move tmp 7 vec 2)
   (call glo 11 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (move tmp 4 vec 0)
   (move tmp 5 vec 1)
   (call glo 152 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (load sym vector-set! vec 0)
   (call glo 144 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 6)
   (move res 0 tmp 6)
   (new-vec 1)
   (load int 0 vec 0)
   (call glo 178 7)
   (move res 0 tmp 7)
   (new-vec 1)
   (move tmp 7 vec 0)
   (call glo 142 7)
   (move res 0 tmp 7)
   (new-vec 1)
   (load bool 1 vec 0)
   (call glo 180 8)
   (move res 0 tmp 8)
   (new-vec 1)
   (move tmp 8 vec 0)
   (call glo 142 8)
   (move res 0 tmp 8)
   (new-vec 3)
   (move tmp 6 vec 0)
   (move tmp 7 vec 1)
   (move tmp 8 vec 2)
   (call glo 11 6)
   (move res 0 tmp 6)
   (new-vec 2)
   (move tmp 5 vec 0)
   (move tmp 6 vec 1)
   (call glo 152 5)
   (move res 0 tmp 5)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 144 6)
   (move res 0 tmp 6)
   (new-vec 2)
   (move tmp 5 vec 0)
   (move tmp 6 vec 1)
   (call glo 11 5)
   (move res 0 tmp 5)
   (new-vec 2)
   (move tmp 4 vec 0)
   (move tmp 5 vec 1)
   (call glo 223 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 146 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 1 vec 1)
   (call 3 0 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move tmp 4 vec 0)
   (call glo 11 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call glo 152 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (move tmp 3 vec 2)
   (call glo 148 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load nil _ vec 0)
   (move tmp 1 vec 1)
   (call glo 146 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load sym vector vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (load bool 0 vec 0)
   (call glo 180 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 142 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load str "not computed yet" vec 0)
   (call glo 182 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call glo 142 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 152 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3107)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3108)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call glo 127 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 820 tmp 0)
   (jump-if-false 0 0 else%3109)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3109)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call tmp 0)
   (label else%3108)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 177 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3110)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3111)
   (new-vec 1)
   (load str "immutable%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 225 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 229 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 144)
   (label else%3111)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 226)
   (label else%3110)
   (new-vec 3)
   (load sym desugar-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%595)
   (jump-if-false 0 0 else%3112)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 3 1 vec 1)
   (tail-call glo 152)
   (label else%3112)
   (new-vec 4)
   (load sym desugar-expression vec 0)
   (load str "arity mismatch in beta-redex: ~s and ~s" vec 1)
   (move 2 0 vec 2)
   (move 3 1 vec 3)
   (tail-call glo 120)

   (label lambda-deep%596)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3113)
   (load nil _ res 0)
   (return)
   (label else%3113)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 65 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-flat%597)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load str "_" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 23)

   (label lambda-deep%598)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3114)
   (load nil _ res 0)
   (return)
   (label else%3114)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 23 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3115)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3115)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%599)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 141 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3116)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%3116)
   (new-vec 3)
   (load sym check-for-multiple-definitions! vec 0)
   (load str "not a definition: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%600)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3117)
   (new-vec 2)
   (load nil _ vec 0)
   (move 0 2 vec 1)
   (tail-call 0 3)
   (label else%3117)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 0 vec 1)
   (move 0 3 vec 2)
   (move 0 0 vec 3)
   (load close-flat 821 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 1 vec 3)
   (tail-call 1 1)

   (label lambda-deep%601)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3118)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 2 vec 1)
   (tail-call 1 3)
   (label else%3118)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3119)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 2 vec 1)
   (tail-call 1 3)
   (label else%3119)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3120)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 822 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3121)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3121)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%3120)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3122)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 5)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 0 2 vec 2)
   (move 2 1 vec 3)
   (move 1 3 vec 4)
   (load close-flat 823 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call 2 1)
   (label else%3122)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3123)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 0 1 vec 1)
   (move 2 0 vec 2)
   (move 1 3 vec 3)
   (load close-flat 824 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call 2 1)
   (label else%3123)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3124)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 0 1 vec 1)
   (move 2 0 vec 2)
   (move 1 3 vec 3)
   (load close-flat 825 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call 2 1)
   (label else%3124)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3125)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load nil _ vec 0)
   (move 1 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (move 3 1 vec 2)
   (move 2 3 vec 3)
   (move 1 0 vec 4)
   (load close-flat 826 tmp 0)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (move tmp 0 vec 3)
   (tail-call 3 0)
   (label else%3125)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3126)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (move 3 1 vec 3)
   (call 2 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 1 3 vec 2)
   (load close-flat 827 tmp 1)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (move tmp 1 vec 3)
   (tail-call 2 1)
   (label else%3126)
   (new-vec 3)
   (load sym scan-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%602)
   (new-vec 1)
   (extend)
   (load close-deep 828 0 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (tail-call 0 0)

   (label lambda-flat%603)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3127)
   (move 0 0 res 0)
   (return)
   (label else%3127)
   (new-vec 3)
   (load sym scan-expression vec 0)
   (load str "non-null updates on return: ~s" vec 1)
   (move 0 1 vec 2)
   (tail-call glo 120)

   (label lambda-deep%604)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3128)
   (move 0 1 res 0)
   (return)
   (label else%3128)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (load close-flat 829 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%605)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3129)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3130)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (extend)
   (load close-deep 830 0 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (call 0 0 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3130)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (tail-call glo 152)
   (label else%3129)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%606)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3131)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 1 0 res 0)
   (return)
   (label else%3131)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3132)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 3 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3133)
   (new-vec 1)
   (load sym vector-ref vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (load int 0 vec 0)
   (call glo 178 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 142 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3133)
   (move 1 0 res 0)
   (return)
   (label else%3132)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 243 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3134)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 144)
   (label else%3134)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 241 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3135)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (load close-deep 831 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3136)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3136)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%3135)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3137)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 2 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 2 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 148)
   (label else%3137)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3138)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 2 2 vec 2)
   (load close-flat 832 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call glo 46 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 1)
   (label else%3138)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 224 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3139)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 2 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 2 2 vec 2)
   (load close-flat 833 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call glo 46 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 223)
   (label else%3139)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 245 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3140)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 3 vec 0)
   (move 1 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (move 3 2 vec 2)
   (move 1 3 vec 3)
   (load close-flat 834 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (move 1 1 vec 2)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (call 3 2 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 168)
   (label else%3140)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3141)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 2 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 150)
   (label else%3141)
   (new-vec 3)
   (load sym box-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%607)
   (new-vec 1)
   (extend)
   (load close-deep 835 0 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (tail-call 0 0)

   (label lambda-deep%608)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3142)
   (load nil _ res 0)
   (return)
   (label else%3142)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 141 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3143)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 4 1 vec 1)
   (call glo 251 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 140 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 3 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3143)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym box-definitions vec 0)
   (load str "not a definition: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%609)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 141 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3144)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (move 0 0 res 0)
   (return)
   (label else%3144)
   (new-vec 3)
   (load sym box-program vec 0)
   (load str "not a definition: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%610)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call glo 290)

   (label lambda-flat%611)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call glo 290)

   (label lambda-flat%612)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 290 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-flat%613)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 836 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)

   (label lambda-flat%614)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3145)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 837 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3146)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3146)
   (new-vec 3)
   (load sym linearize-expression0 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3145)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3147)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 838 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3148)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3148)
   (new-vec 3)
   (load sym linearize-expression0 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3147)
   (new-vec 3)
   (load sym linearize-expression0 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%615)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (call glo 274 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call glo 190 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 258 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 284 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 288)

   (label lambda-flat%616)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 291)

   (label lambda-flat%617)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%618)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%619)
   (new-vec 3)
   (move 1 3 vec 0)
   (move 1 2 vec 1)
   (move 1 1 vec 2)
   (call glo 292 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-flat%620)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 839 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)

   (label lambda-flat%621)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3149)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 840 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3150)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3150)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3149)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3151)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 841 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3152)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3152)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3151)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%622)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 274 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 264 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 262 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 270 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-deep%623)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3153)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move 2 3 vec 2)
   (tail-call glo 292)
   (label else%3153)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 842 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 299)

   (label lambda-flat%624)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%625)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%626)
   (new-vec 3)
   (move 1 3 vec 0)
   (move 1 2 vec 1)
   (move 1 1 vec 2)
   (call glo 294 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-flat%627)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 843 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)

   (label lambda-flat%628)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3154)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 844 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3155)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3155)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3154)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3156)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 845 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3157)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3157)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3156)
   (new-vec 3)
   (load sym linearize-expression2 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%629)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 274 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 262 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-flat%630)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (load close-flat 846 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 295)

   (label lambda-deep%631)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3158)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move 2 3 vec 2)
   (tail-call glo 294)
   (label else%3158)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 847 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 299)

   (label lambda-flat%632)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%633)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%634)
   (new-vec 4)
   (move 1 4 vec 0)
   (move 1 3 vec 1)
   (move 1 2 vec 2)
   (move 1 1 vec 3)
   (call glo 297 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-flat%635)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 1 3 vec 2)
   (move 0 0 vec 3)
   (load close-flat 848 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)

   (label lambda-flat%636)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3159)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 849 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3160)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3160)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3159)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3161)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 850 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3162)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3162)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3161)
   (new-vec 3)
   (load sym linearize-expression22 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%637)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 274 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-deep%638)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3163)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move 2 3 vec 2)
   (move 2 4 vec 3)
   (tail-call glo 297)
   (label else%3163)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 851 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 2 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 299)

   (label lambda-flat%639)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%640)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 292)

   (label lambda-flat%641)
   (new-vec 3)
   (move 1 3 vec 0)
   (move 1 2 vec 1)
   (move 1 1 vec 2)
   (call glo 299 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-flat%642)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 852 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)

   (label lambda-deep%643)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3164)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 3 1 vec 1)
   (move 3 2 vec 2)
   (tail-call glo 299)
   (label else%3164)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 853 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 3 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 299)

   (label lambda-flat%644)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3165)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 854 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3166)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3166)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3165)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3167)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 855 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3168)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3168)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3167)
   (new-vec 3)
   (load sym linearize-expression2 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%645)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 274 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 288)

   (label lambda-deep%646)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3169)
   (load nil _ res 0)
   (return)
   (label else%3169)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 141 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3170)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (call glo 301 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 256 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 3 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3170)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym linearize-definitions vec 0)
   (load str "not a definition: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%647)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call glo 290)

   (label lambda-flat%648)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call glo 290)

   (label lambda-flat%649)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (call glo 301 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 266 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-flat%650)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 856 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 295)

   (label lambda-deep%651)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3171)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 1 vec 1)
   (tail-call glo 301)
   (label else%3171)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (load close-flat 857 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 299)

   (label lambda-flat%652)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3172)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 858 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3173)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3173)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3172)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3174)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 859 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3175)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 290 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 266 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3175)
   (new-vec 3)
   (load sym linearize-expression1 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 1 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3174)
   (new-vec 3)
   (load sym linearize-expression2 vec 0)
   (load str "invalid letrec header: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%653)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (call glo 274 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call glo 188 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 258 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 274 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load int 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-deep%654)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 269 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3176)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 1)
   (label else%3176)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 271 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3177)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 2)
   (label else%3177)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 273 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3178)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (call 3 3 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call 3 0)
   (label else%3178)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 281 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3179)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 4 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 0)
   (label else%3179)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 283 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3180)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 0)
   (label else%3180)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 289 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3181)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 4 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 0)
   (label else%3181)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 285 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3182)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 1)
   (label else%3182)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 287 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3183)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 2 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 0)
   (label else%3183)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 275 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3184)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 1)
   (label else%3184)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 277 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3185)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 1)
   (label else%3185)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 279 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3186)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 0)
   (label else%3186)
   (new-vec 3)
   (load sym compute-freevars vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%655)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 259 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3187)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 1 2 res 0)
   (return)
   (label else%3187)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 261 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3188)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 860 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (call glo 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3189)
   (move 1 2 res 0)
   (return)
   (label else%3189)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 861 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call glo 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3190)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (call glo 23 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3191)
   (move 1 2 res 0)
   (return)
   (label else%3191)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (tail-call lib 26)
   (label else%3190)
   (move 1 2 res 0)
   (return)
   (label else%3188)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 263 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3192)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 1 2 res 0)
   (return)
   (label else%3192)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 265 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3193)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (move 1 2 res 0)
   (return)
   (label else%3193)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3194)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 862 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3195)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3195)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3194)
   (new-vec 3)
   (load sym compute-freevars vec 0)
   (load str "quasar: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%656)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3196)
   (move 0 2 res 0)
   (return)
   (label else%3196)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call 1 2)

   (label lambda-deep%657)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3197)
   (move 0 2 res 0)
   (return)
   (label else%3197)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (load close-deep 863 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3198)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 1)
   (label else%3198)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3199)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 1)
   (label else%3199)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (load sym walk-values-rec vec 0)
   (load str "illegal header: ~s" vec 1)
   (move tmp 2 vec 2)
   (call glo 120 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%658)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 271 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3200)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (call 2 1 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move tmp 0 vec 2)
   (tail-call 2 2)
   (label else%3200)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 275 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3201)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 1)
   (label else%3201)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3202)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load close-deep 864 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3203)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3203)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3202)
   (new-vec 3)
   (load sym walk-named vec 0)
   (load str "not a named computation: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%659)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (load nil _ vec 2)
   (tail-call 2 0)

   (label lambda-deep%660)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3204)
   (load int -1 res 0)
   (return)
   (label else%3204)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3205)
   (move 0 1 res 0)
   (return)
   (label else%3205)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%661)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3206)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3207)
   (new-vec 2)
   (move glo 130 vec 0)
   (move 3 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3208)
   (new-vec 4)
   (load sym scope-lookup vec 0)
   (load str "undeclared variable: ~s in ~s" vec 1)
   (move 4 0 vec 2)
   (move 4 1 vec 3)
   (tail-call glo 120)
   (label else%3208)
   (new-vec 3)
   (move 4 0 vec 0)
   (load sym lib vec 1)
   (move 0 0 vec 2)
   (tail-call glo 309)
   (label else%3207)
   (new-vec 3)
   (move 3 0 vec 0)
   (load sym glo vec 1)
   (move 0 0 vec 2)
   (tail-call glo 309)
   (label else%3206)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call glo 343 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3209)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 2 0)
   (label else%3209)
   (new-vec 3)
   (move 3 0 vec 0)
   (move 1 0 vec 1)
   (move 0 0 vec 2)
   (tail-call glo 309)

   (label lambda-deep%662)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move 3 2 vec 2)
   (call glo 346 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (load close-flat 865 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 317)

   (label lambda-flat%663)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 345)

   (label lambda-flat%664)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3210)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 866 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3211)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 1 vec 1)
   (call glo 342 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (move 3 0 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 315 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3211)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "illegal header: ~s" vec 1)
   (move 0 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3210)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3212)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 867 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 267 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3213)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 3 1 vec 1)
   (call glo 342 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 1 vec 0)
   (move tmp 1 vec 1)
   (move 3 0 vec 2)
   (call glo 346 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 315 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3213)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "illegal header: ~s" vec 1)
   (move 0 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3212)
   (new-vec 3)
   (load sym scope-expression vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%665)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 327)

   (label lambda-deep%666)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 327)

   (label lambda-deep%667)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (call glo 346 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 337)

   (label lambda-flat%668)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 345)

   (label lambda-deep%669)
   (new-vec 3)
   (move 2 1 vec 0)
   (move 3 1 vec 1)
   (move 3 2 vec 2)
   (call glo 345 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 325)

   (label lambda-deep%670)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move 3 2 vec 2)
   (call glo 346 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (load close-flat 868 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 317)

   (label lambda-deep%671)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3214)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call glo 17)
   (label else%3214)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 257 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3215)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (load close-deep 869 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (call glo 25 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (extend)
   (load close-deep 870 tmp 2)
   (jump-if-false 0 0 else%3216)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 2)
   (label else%3216)
   (new-vec 2)
   (move 1 0 vec 0)
   (move glo 130 vec 1)
   (call glo 25 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3215)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym scope-program vec 0)
   (load str "not a definition: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%672)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 257 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3217)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 3)
   (move 0 1 vec 0)
   (load nil _ vec 1)
   (move 2 0 vec 2)
   (call glo 346 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 305)
   (label else%3217)
   (new-vec 3)
   (load sym scope-program vec 0)
   (load str "not a definition: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%673)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 0 0 vec 2)
   (load close-flat 871 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-flat%674)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 1 2 vec 2)
   (load close-flat 872 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-flat%675)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 873 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 406)

   (label lambda-deep%676)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3218)
   (move 0 1 res 0)
   (return)
   (label else%3218)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%677)
   (new-vec 1)
   (extend)
   (load close-deep 874 0 0)
   (new-vec 2)
   (move 2 3 vec 0)
   (move 2 2 vec 1)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move 1 0 vec 2)
   (call glo 372 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 0)

   (label lambda-flat%678)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 374 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%679)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 376 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%680)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 378 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%681)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 1 2 vec 2)
   (load close-flat 875 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-flat%682)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 1 2 vec 2)
   (load close-flat 876 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-flat%683)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 384 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%684)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 364 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (call glo 386 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%685)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 1 2 vec 2)
   (load close-flat 877 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-flat%686)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (load close-flat 878 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 1 vec 3)
   (tail-call glo 406)

   (label lambda-flat%687)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 879 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 406)

   (label lambda-flat%688)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 374 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-deep%689)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3219)
   (new-vec 3)
   (move 0 3 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 2 3)
   (label else%3219)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 306 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3220)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 4)
   (move 3 0 vec 0)
   (move 2 3 vec 1)
   (move 0 0 vec 2)
   (move 2 0 vec 3)
   (load close-flat 880 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)
   (label else%3220)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym factorize-definitions vec 0)
   (load str "not a scoped definition: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%690)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3221)
   (new-vec 1)
   (move 0 4 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3222)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 3 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3223)
   (new-vec 3)
   (move 0 3 vec 0)
   (move 0 2 vec 1)
   (move 0 5 vec 2)
   (tail-call 2 2)
   (label else%3223)
   (new-vec 4)
   (load sym factorize-finalize vec 0)
   (load str "mismatching indices: ~s and ~s" vec 1)
   (move 0 0 vec 2)
   (move 0 3 vec 3)
   (tail-call glo 120)
   (label else%3222)
   (new-vec 1)
   (move 0 4 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 6)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 2 vec 2)
   (move 0 3 vec 3)
   (load nil _ vec 4)
   (move 0 5 vec 5)
   (tail-call 1 0)
   (label else%3221)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 318 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3224)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 6)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (move 2 5 vec 2)
   (move 2 2 vec 3)
   (move 2 1 vec 4)
   (move 2 0 vec 5)
   (load close-flat 881 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 2 3 vec 1)
   (move 2 4 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)
   (label else%3224)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 316 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3225)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 6)
   (move 0 0 vec 0)
   (move 3 0 vec 1)
   (move 2 5 vec 2)
   (move 2 2 vec 3)
   (move 2 1 vec 4)
   (move 2 0 vec 5)
   (load close-flat 882 tmp 0)
   (new-vec 4)
   (move 0 1 vec 0)
   (move 2 3 vec 1)
   (move 2 4 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)
   (label else%3225)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym factorize-program vec 0)
   (load str "not a lambda-abstraction: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%691)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 883 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-deep%692)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3226)
   (move 2 1 res 0)
   (return)
   (label else%3226)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 884 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 310 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3227)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (move tmp 3 vec 2)
   (extend)
   (new-vec 5)
   (load sym move vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (load sym vec vec 3)
   (move 2 1 vec 4)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3227)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (load sym codegen-abstraction-flat vec 0)
   (load str "illegal free variable: ~s" vec 1)
   (move tmp 1 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%693)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3228)
   (move 2 1 res 0)
   (return)
   (label else%3228)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (move 0 1 vec 2)
   (load close-flat 885 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 417)

   (label lambda-deep%694)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3229)
   (move 2 1 res 0)
   (return)
   (label else%3229)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 247 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3230)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 5)
   (load sym load vec 0)
   (load sym close-deep vec 1)
   (move 0 0 vec 2)
   (load int 0 vec 3)
   (move 2 1 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 3 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3230)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 249 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3231)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (load str "letrec%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 5)
   (load sym load vec 0)
   (load sym close-deep vec 1)
   (move 1 0 vec 2)
   (load sym vec vec 3)
   (load int 0 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 130 vec 0)
   (load sym vector vec 1)
   (call glo 343 1)
   (move res 0 tmp 1)
   (new-vec 4)
   (load sym call vec 0)
   (load sym lib vec 1)
   (move tmp 1 vec 2)
   (load int 0 vec 3)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 5)
   (load sym move vec 0)
   (load sym res vec 1)
   (load int 0 vec 2)
   (load int 0 vec 3)
   (move 3 1 vec 4)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call 4 0 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 3 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%3231)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym codegen-letrec vec 0)
   (load str "not a deep abstraction: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%695)
   (new-vec 4)
   (load sym jump-if-false vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move 1 2 vec 3)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load sym label vec 0)
   (move 1 2 vec 1)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 416 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 16 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%696)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 26)

   (label lambda-flat%697)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3232)
   (new-vec 3)
   (load sym tail-call vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 11)
   (label else%3232)
   (new-vec 3)
   (load sym codegen-expression vec 0)
   (load str "unexpected tag: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%698)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (move tmp 1 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 11)

   (label lambda-flat%699)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (move tmp 1 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load nil _ vec 1)
   (tail-call lib 26)

   (label lambda-flat%700)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3233)
   (new-vec 4)
   (load sym call vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (load int 0 vec 3)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 5)
   (load sym move vec 0)
   (load sym res vec 1)
   (load int 0 vec 2)
   (move tmp 1 vec 3)
   (move tmp 2 vec 4)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load nil _ vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3233)
   (new-vec 3)
   (load sym codegen-named vec 0)
   (load str "unexpected tag: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%701)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (load sym tmp vec 3)
   (move 1 1 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-flat%702)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (load sym res vec 3)
   (load int 0 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move glo 2 vec 1)
   (tail-call glo 11)

   (label lambda-flat%703)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3234)
   (new-vec 4)
   (load sym call vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move 1 1 vec 3)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3234)
   (new-vec 3)
   (load sym codegen-expression vec 0)
   (load str "unexpected tag: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%704)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (move tmp 1 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%705)
   (new-vec 3)
   (load sym load vec 0)
   (load sym bool vec 1)
   (move 0 0 vec 2)
   (tail-call 3 1)

   (label lambda-flat%706)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3235)
   (new-vec 4)
   (load sym call vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move 1 1 vec 3)
   (call glo 11 0)
   (move res 0 tmp 0)
   (load close-deep 886 tmp 1)
   (load close-deep 887 tmp 2)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 31 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call glo 6 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3236)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3237)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3238)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move 4 1 vec 1)
   (call lib 40 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3238)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 2)
   (label else%3237)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 2)
   (label else%3236)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 2)
   (label else%3235)
   (new-vec 3)
   (load sym codegen-named vec 0)
   (load str "unexpected tag: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%707)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (move tmp 1 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 5)
   (load sym load vec 0)
   (load sym void vec 1)
   (load sym _ vec 2)
   (load sym tmp vec 3)
   (move 1 1 vec 4)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-flat%708)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 353 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3239)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call glo 416)
   (label else%3239)
   (new-vec 3)
   (load sym codegen-definitions vec 0)
   (load str "not a factorized definition: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%709)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load sym label vec 0)
   (move tmp 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 416 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%710)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3240)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call glo 64)
   (label else%3240)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 888 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load sym move vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (load close-deep 889 tmp 1)
   (jump-if-false 0 0 else%3241)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 1)
   (label else%3241)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load sym load vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%711)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 103 0)
   (new-vec 2)
   (load str "  (" vec 0)
   (move 2 1 vec 1)
   (call glo 118 0)
   (new-vec 1)
   (move 1 4 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call glo 116 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (load close-flat 890 tmp 0)
   (new-vec 1)
   (move 1 4 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 52 0)
   (new-vec 2)
   (load str ")" vec 0)
   (move 2 1 vec 1)
   (call glo 118 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 103 0)
   (new-vec 2)
   (load str "  " vec 0)
   (move 2 1 vec 1)
   (call glo 118 0)
   (new-vec 2)
   (move 1 5 vec 0)
   (move 2 1 vec 1)
   (call glo 116 0)
   (new-vec 2)
   (load str ")" vec 0)
   (move 2 1 vec 1)
   (call glo 118 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (tail-call glo 103)

   (label lambda-flat%712)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 103 0)
   (new-vec 2)
   (load str "   " vec 0)
   (move 1 0 vec 1)
   (call glo 118 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call glo 116)

   (label lambda-deep%713)
   (new-vec 2)
   (move 0 0 vec 0)
   (load str ">" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "#<predefined procedure " vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 20)

   (label lambda-deep%714)
   (jump-if-false 0 0 else%3242)
   (load sym OK res 0)
   (return)
   (label else%3242)
   (new-vec 5)
   (load sym check-arity vec 0)
   (load str "~s(~s): wrong arity: ~s" vec 1)
   (move 2 0 vec 2)
   (move 2 1 vec 3)
   (move 2 2 vec 4)
   (tail-call glo 120)

   (label lambda-deep%715)
   (jump-if-false 0 0 else%3243)
   (load sym OK res 0)
   (return)
   (label else%3243)
   (new-vec 5)
   (move 2 0 vec 0)
   (load str "~s / not a ~s: ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 3 vec 3)
   (move 2 2 vec 4)
   (tail-call glo 120)

   (label lambda-deep%716)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3244)
   (load sym OK res 0)
   (return)
   (label else%3244)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (load sym check-types vec 0)
   (move 3 0 vec 1)
   (move tmp 0 vec 2)
   (move 3 2 vec 3)
   (call glo 465 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%717)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3245)
   (move glo 458 res 0)
   (return)
   (label else%3245)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 64 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 444)

   (label lambda-deep%718)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3246)
   (new-vec 0)
   (extend)
   (load nil _ res 0)
   (return)
   (label else%3246)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3247)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)
   (label else%3247)
   (new-vec 3)
   (load sym DS-list->vector vec 0)
   (load str "not a list: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%719)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 475 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3248)
   (move 0 0 res 0)
   (return)
   (label else%3248)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 476 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3249)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3250)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 474 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 475 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3251)
   (move 0 0 res 0)
   (return)
   (label else%3251)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 476 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3252)
   (new-vec 1)
   (move 3 0 vec 0)
   (call glo 474 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 474 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%3252)
   (load bool 0 res 0)
   (return)
   (label else%3250)
   (load bool 0 res 0)
   (return)
   (label else%3249)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%720)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3253)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3253)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3254)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3255)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3256)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3256)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3257)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 425 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3258)
   (new-vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3258)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3259)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 3 0 vec 0)
   (call glo 445 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3260)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (tail-call 5 0)
   (label else%3260)
   (new-vec 2)
   (load sym DS-proper-list? vec 0)
   (load str "im-po-ssi-ble!" vec 1)
   (tail-call glo 120)
   (label else%3259)
   (load bool 0 res 0)
   (return)
   (label else%3257)
   (load bool 0 res 0)
   (return)
   (label else%3255)
   (load bool 0 res 0)
   (return)
   (label else%3254)
   (load bool 0 res 0)
   (return)

   (label lambda-deep%721)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%722)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%723)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%724)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%725)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%726)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%727)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%728)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%729)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-flat%730)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (tail-call lib 36)

   (label lambda-deep%731)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%732)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%733)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%734)
   (jump-if-false 0 0 else%3261)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 432 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3261)
   (new-vec 4)
   (load sym primitive-string-ref vec 0)
   (load str "index out of bounds: ~s and ~s" vec 1)
   (move 1 0 vec 2)
   (move 1 1 vec 3)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%735)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%736)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%737)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%738)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%739)
   (jump-if-false 0 0 else%3262)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3262)
   (new-vec 4)
   (load sym primitive-vector-ref vec 0)
   (load str "index out of bounds: ~s and ~s" vec 1)
   (move 1 0 vec 2)
   (move 1 1 vec 3)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%740)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move glo 462 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%741)
   (jump-if-false 0 0 else%3263)
   (new-vec 2)
   (move 2 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 1 vec 2)
   (call lib 37 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3263)
   (new-vec 4)
   (load sym primitive-vector-set! vec 0)
   (load str "index out of bounds: ~s and ~s" vec 1)
   (move 1 0 vec 2)
   (move 1 1 vec 3)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%742)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%743)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-deep%744)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%745)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%746)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%747)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%748)
   (new-vec 0)
   (tail-call 2 1)

   (label lambda-deep%749)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3264)
   (move 0 1 res 0)
   (return)
   (label else%3264)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 1 vec 1)
   (call 3 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%750)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3265)
   (move 2 0 res 0)
   (return)
   (label else%3265)
   (new-vec 2)
   (move 4 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%751)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 68 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3266)
   (move 2 0 res 0)
   (return)
   (label else%3266)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 2 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%752)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3267)
   (move 3 0 res 0)
   (return)
   (label else%3267)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%753)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 83)

   (label lambda-deep%754)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3268)
   (load nil _ res 0)
   (return)
   (label else%3268)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym label vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3269)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (call 3 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3269)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym nop vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3270)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (tail-call 3 0)
   (label else%3270)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 3 0)

   (label lambda-flat%755)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (extend)
   (load close-deep 891 0 0)
   (new-vec 2)
   (load int 0 vec 0)
   (move 3 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%756)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3271)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3272)
   (new-vec 1)
   (move 2 0 vec 0)
   (tail-call 9 1)
   (label else%3272)
   (new-vec 4)
   (load sym crossref vec 0)
   (load str "mismatching numbers: ~s and ~s" vec 1)
   (move 0 1 vec 2)
   (move 4 0 vec 3)
   (tail-call glo 120)
   (label else%3271)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym label vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3273)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 2 1 vec 1)
   (tail-call 3 0)
   (label else%3273)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym jump vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3274)
   (new-vec 3)
   (move glo 490 vec 0)
   (move 2 1 vec 1)
   (load sym jump vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 4 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 491 vec 0)
   (move 2 1 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 3 0)
   (label else%3274)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym jump-if-false vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3275)
   (new-vec 3)
   (move glo 490 vec 0)
   (move 2 1 vec 1)
   (load sym jump-if-false vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 95 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 5 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 3)
   (move glo 491 vec 0)
   (move 3 1 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 4 0)
   (label else%3275)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym new-vec vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3276)
   (new-vec 3)
   (move glo 490 vec 0)
   (move 2 1 vec 1)
   (load sym new-vec vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 491 vec 0)
   (move 2 1 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 3 0)
   (label else%3276)
   (load close-deep 892 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3277)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3277)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym load vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3278)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3278)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym call vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3279)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3279)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tail-call vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3280)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3280)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym extend vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3281)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3281)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym return vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%757)
   (load close-deep 893 tmp 0)
   (jump-if-false glo 502 else%3282)
   (new-vec 2)
   (move glo 501 vec 0)
   (load int 0 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3283)
   (new-vec 1)
   (load str "Shhh" vec 0)
   (tail-call tmp 0)
   (label else%3283)
   (new-vec 2)
   (move glo 501 vec 0)
   (load int 1 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3284)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 116 1)
   (new-vec 1)
   (load str ": " vec 0)
   (call glo 118 1)
   (new-vec 2)
   (move glo 490 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 491 vec 0)
   (move 0 0 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (extend)
   (load close-deep 894 tmp 2)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3285)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 94 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3285)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3284)
   (new-vec 2)
   (move glo 501 vec 0)
   (load int 2 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3286)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 103 1)
   (new-vec 2)
   (move glo 490 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 491 vec 0)
   (move 0 0 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (extend)
   (load close-deep 895 tmp 2)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3287)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 94 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3287)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3286)
   (new-vec 0)
   (call glo 494 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3282)
   (new-vec 0)
   (call glo 494 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%758)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 439 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3288)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move glo 488 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 489 vec 0)
   (move 1 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (load close-deep 896 tmp 1)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 35 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 2 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3289)
   (new-vec 1)
   (move 2 1 vec 0)
   (tail-call tmp 1)
   (label else%3289)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int -1 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3290)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 471 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call lib 32 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3290)
   (new-vec 1)
   (move 2 1 vec 0)
   (call glo 94 2)
   (move res 0 tmp 2)
   (new-vec 5)
   (load sym user-procedure-application vec 0)
   (load str "arity mismatch for closure number ~s: ~s and ~s" vec 1)
   (move 1 0 vec 2)
   (move 0 0 vec 3)
   (move tmp 2 vec 4)
   (call glo 120 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3288)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 441 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3291)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 1 1 vec 2)
   (call glo 464 0)
   (new-vec 2)
   (move 0 2 vec 0)
   (load sym apply vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3292)
   (new-vec 3)
   (load sym apply vec 0)
   (move 1 1 vec 1)
   (load sym procedure vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 469 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 472 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 1)
   (label else%3292)
   (new-vec 2)
   (move 0 2 vec 0)
   (load sym call/cc vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3293)
   (new-vec 3)
   (load sym call/cc vec 0)
   (move 1 1 vec 1)
   (load sym procedure vec 2)
   (call glo 466 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 442 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 32 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move 1 2 vec 2)
   (tail-call 2 1)
   (label else%3293)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 2 2 vec 1)
   (load close-flat 897 tmp 0)
   (new-vec 2)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 0 2)
   (label else%3291)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 443 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3294)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load int 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3295)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 2 2)
   (label else%3295)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 94 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym continuation-application vec 0)
   (load str "arity mismatch: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)
   (label else%3294)
   (new-vec 3)
   (load sym application vec 0)
   (load str "unapplicable value: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%759)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 496 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3296)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 4 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move tmp 3 vec 3)
   (extend)
   (new-vec 2)
   (move glo 486 vec 0)
   (move 0 2 vec 1)
   (call glo 483 0)
   (new-vec 0)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move tmp 0 vec 2)
   (move 0 3 vec 3)
   (tail-call 2 0)
   (label else%3296)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 498 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3297)
   (new-vec 0)
   (extend)
   (new-vec 2)
   (move glo 487 vec 0)
   (load int 0 vec 1)
   (tail-call lib 36)
   (label else%3297)
   (new-vec 3)
   (load sym application vec 0)
   (load str "fudged continuation: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%760)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3298)
   (load sym done res 0)
   (return)
   (label else%3298)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 488 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%761)
   (new-vec 2)
   (move lib 27 vec 0)
   (move 1 0 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 95 0)
   (move res 0 glo 488)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 898 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (call glo 46 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 95 0)
   (move res 0 glo 489)
   (new-vec 1)
   (load str "/ initialized" vec 0)
   (call glo 135 0)
   (new-vec 0)
   (tail-call glo 499)

   (label lambda-flat%762)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 423)

   (label lambda-deep%763)
   (load close-deep 899 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 18 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3299)
   (new-vec 2)
   (move 1 0 vec 0)
   (load str ".scm" vec 1)
   (call glo 85 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3300)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 506 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3300)
   (new-vec 2)
   (move 1 0 vec 0)
   (load str ".dsa" vec 1)
   (call glo 85 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3301)
   (new-vec 2)
   (move 1 0 vec 0)
   (move glo 114 vec 1)
   (call glo 101 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load sym DAIMI-SchemeE03 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3302)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (move 3 0 vec 2)
   (load close-flat 900 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 5 0 vec 1)
   (call lib 39 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3302)
   (new-vec 3)
   (load sym run vec 0)
   (load str "invalid header in ~s" vec 1)
   (move 2 0 vec 2)
   (call glo 120 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3301)
   (new-vec 2)
   (move 1 0 vec 0)
   (load str ".scm" vec 1)
   (call lib 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 506 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3299)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%764)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%765)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3303)
   (load bool 1 res 0)
   (return)
   (label else%3303)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3304)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 18 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3305)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3306)
   (load bool 1 res 0)
   (return)
   (label else%3306)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%3305)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%3304)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3307)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3308)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3309)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3310)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%3310)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%3309)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3311)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%3311)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 1 0 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%3308)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%3307)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3312)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 34 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3313)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 35 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3314)
   (new-vec 1)
   (extend)
   (load close-deep 901 0 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 0 0)
   (label else%3314)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 3 0)
   (label else%3313)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)
   (label else%3312)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 2 0)

   (label lambda-deep%766)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3315)
   (new-vec 2)
   (move 3 2 vec 0)
   (load nil _ vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 2 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 3 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call 4 0)
   (label else%3315)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 30 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (call glo 13 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3316)
   (new-vec 4)
   (load sym test-proper-list? vec 0)
   (load str "length ~s, cycle ~s" vec 1)
   (move 3 2 vec 2)
   (move 0 0 vec 3)
   (tail-call glo 120)
   (label else%3316)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%767)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 16)

   (label lambda-deep%768)
   (new-vec 2)
   (move glo 80 vec 0)
   (move 0 0 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%769)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3317)
   (load nil _ res 0)
   (return)
   (label else%3317)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 126 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3318)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 1)
   (label else%3318)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3319)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 2)
   (label else%3319)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%770)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3320)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 5 0 vec 2)
   (tail-call glo 120)
   (label else%3320)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 115 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3321)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3322)
   (new-vec 3)
   (load sym format vec 0)
   (load str "too few arguments for ~s" vec 1)
   (move 6 0 vec 2)
   (tail-call glo 120)
   (label else%3322)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 91 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 4 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 16)
   (label else%3321)
   (new-vec 3)
   (load sym format vec 0)
   (load str "illegal control character: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%771)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3323)
   (new-vec 3)
   (load sym format vec 0)
   (load str "incomplete directive: ~s" vec 1)
   (move 5 0 vec 2)
   (tail-call glo 120)
   (label else%3323)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%772)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 4 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3324)
   (move 0 1 res 0)
   (return)
   (label else%3324)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 98 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (load int 10 vec 0)
   (move 0 1 vec 1)
   (call lib 3 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%773)
   (new-vec 2)
   (move 0 0 vec 0)
   (move glo 79 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3325)
   (new-vec 0)
   (tail-call 1 0)
   (label else%3325)
   (new-vec 0)
   (tail-call 1 1)

   (label lambda-flat%774)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 81 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3326)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 47 0)
   (new-vec 0)
   (tail-call 1 1)
   (label else%3326)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 59 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3327)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 106)
   (label else%3327)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call 1 3)

   (label lambda-flat%775)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 96 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%776)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3328)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%3328)
   (new-vec 1)
   (move 1 3 vec 0)
   (call lib 47 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%777)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%778)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 119 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3329)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 902 tmp 0)
   (new-vec 0)
   (load close-flat 903 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3329)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\ne~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%779)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\ne" vec 1)
   (tail-call glo 120)

   (label lambda-flat%780)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 97 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3330)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 904 tmp 0)
   (new-vec 0)
   (load close-flat 905 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3330)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\sp~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%781)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\sp" vec 1)
   (tail-call glo 120)

   (label lambda-flat%782)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 98 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3331)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 906 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 907 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)
   (label else%3331)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\ta~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%783)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\ta" vec 1)
   (tail-call glo 120)

   (label lambda-flat%784)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3332)
   (new-vec 1)
   (move 1 1 vec 0)
   (tail-call 1 0)
   (label else%3332)
   (new-vec 4)
   (load sym read vec 0)
   (load str "Invalid character name #\\~s~s" vec 1)
   (move 1 1 vec 2)
   (move 0 0 vec 3)
   (tail-call glo 120)

   (label lambda-flat%785)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%786)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 34 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3333)
   (new-vec 1)
   (move 1 3 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move lib 16 vec 0)
   (move tmp 0 vec 1)
   (call lib 39 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%3333)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3334)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 1 3 vec 1)
   (load close-flat 908 tmp 0)
   (new-vec 0)
   (load close-flat 909 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3334)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 3 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 2)

   (label lambda-flat%787)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%788)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 41 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3335)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 1 2)
   (label else%3335)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (load close-flat 910 tmp 0)
   (new-vec 0)
   (load close-flat 911 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 113)

   (label lambda-flat%789)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%790)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 93 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3336)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (load nil _ vec 0)
   (tail-call 1 2)
   (label else%3336)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (load close-flat 912 tmp 0)
   (new-vec 0)
   (load close-flat 913 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 113)

   (label lambda-flat%791)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-deep%792)
   (jump-if-false 0 0 else%3337)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unexpected ~s" vec 1)
   (move 1 0 vec 2)
   (tail-call glo 120)
   (label else%3337)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 39 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3338)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 914 tmp 0)
   (new-vec 0)
   (load close-flat 915 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 113)
   (label else%3338)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 96 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3339)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 916 tmp 0)
   (new-vec 0)
   (load close-flat 917 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 113)
   (label else%3339)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 44 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3340)
   (new-vec 1)
   (move 2 3 vec 0)
   (call lib 48 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load char 64 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3341)
   (new-vec 1)
   (move 2 3 vec 0)
   (call lib 47 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 918 tmp 0)
   (new-vec 0)
   (load close-flat 919 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 113)
   (label else%3341)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 920 tmp 0)
   (new-vec 0)
   (load close-flat 921 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 113)
   (label else%3340)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 35 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3342)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 922 tmp 0)
   (new-vec 0)
   (load close-flat 923 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3342)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 34 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3343)
   (new-vec 2)
   (move 2 3 vec 0)
   (move 2 2 vec 1)
   (tail-call glo 112)
   (label else%3343)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 45 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3344)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 924 tmp 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 925 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)
   (label else%3344)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 43 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3345)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 2 3 vec 1)
   (load close-flat 926 tmp 0)
   (new-vec 1)
   (move 2 2 vec 0)
   (load close-flat 927 tmp 1)
   (new-vec 3)
   (move 2 3 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)
   (label else%3345)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 97 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3346)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 98 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 109)
   (label else%3346)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 2 3 vec 1)
   (move 2 2 vec 2)
   (tail-call glo 110)

   (label lambda-flat%793)
   (new-vec 0)
   (load close-flat 928 tmp 0)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (tail-call glo 113)

   (label lambda-flat%794)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 1 1)

   (label lambda-deep%795)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3347)
   (load bool 0 res 0)
   (return)
   (label else%3347)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (move tmp 0 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3348)
   (move 0 0 res 0)
   (return)
   (label else%3348)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 2 0)

   (label lambda-flat%796)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 12 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3349)
   (move 0 0 res 0)
   (return)
   (label else%3349)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3350)
   (move 0 0 res 0)
   (return)
   (label else%3350)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (jump-if-false 0 0 else%3351)
   (move 0 0 res 0)
   (return)
   (label else%3351)
   (new-vec 1)
   (move 3 0 vec 0)
   (tail-call lib 13)

   (label lambda-deep%797)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 114 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 49 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3352)
   (load nil _ res 0)
   (return)
   (label else%3352)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 194 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3353)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 5 2 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3354)
   (new-vec 3)
   (load sym read-file vec 0)
   (load str "circular load: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%3354)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 5 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (load str "" vec 2)
   (call 5 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (call 4 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 16)
   (label else%3353)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 195 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3355)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 5 2 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3356)
   (new-vec 3)
   (load sym read-file vec 0)
   (load str "circular load-relative: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)
   (label else%3356)
   (load close-deep 929 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 22 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load char 47 vec 1)
   (call glo 77 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3357)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%3357)
   (new-vec 2)
   (move 5 0 vec 0)
   (move 0 0 vec 1)
   (call lib 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3355)
   (new-vec 0)
   (call 2 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%798)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (load close-deep 930 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 12 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3358)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 3 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3358)
   (new-vec 2)
   (move glo 144 vec 0)
   (move 0 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 1 vec 1)
   (move 3 1 vec 2)
   (call glo 231 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%799)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load str "%" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 133)

   (label lambda-flat%800)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 2)

   (label lambda-flat%801)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 2)

   (label lambda-flat%802)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-deep%803)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3359)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (tail-call 4 0)
   (label else%3359)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 3 1 vec 0)
   (move 4 0 vec 1)
   (move 0 1 vec 2)
   (load close-flat 931 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 0 vec 2)
   (load close-flat 932 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 233)

   (label lambda-flat%804)
   (new-vec 1)
   (extend)
   (load close-deep 933 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (tail-call 0 0)

   (label lambda-flat%805)
   (new-vec 1)
   (extend)
   (load close-deep 934 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 2 0 vec 1)
   (tail-call 0 0)

   (label lambda-deep%806)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3360)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (tail-call 4 0)
   (label else%3360)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (load close-flat 935 tmp 1)
   (new-vec 0)
   (load close-flat 936 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 233)

   (label lambda-deep%807)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3361)
   (move 0 0 res 0)
   (return)
   (label else%3361)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 230 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3362)
   (new-vec 1)
   (move 0 0 vec 0)
   (load close-flat 937 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 1 0 vec 1)
   (load close-flat 938 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 233)
   (label else%3362)
   (new-vec 1)
   (load str "or%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call 3 0 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (move tmp 3 vec 2)
   (call glo 148 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-flat%808)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load str "%" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 133)

   (label lambda-flat%809)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-deep%810)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3363)
   (new-vec 2)
   (move 2 2 vec 0)
   (move 0 2 vec 1)
   (tail-call 4 0)
   (label else%3363)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move tmp 4 vec 0)
   (call glo 144 4)
   (move res 0 tmp 4)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move tmp 4 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move 0 2 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (move tmp 3 vec 2)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 2 vec 1)
   (call 4 0 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-flat%811)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load str "%" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 133)

   (label lambda-flat%812)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-deep%813)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3364)
   (move 0 1 res 0)
   (return)
   (label else%3364)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 171 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3365)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (call 3 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call 3 0)
   (label else%3365)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call 2 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%814)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 143 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3366)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3366)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 145 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3367)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3367)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3368)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3368)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 149 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3369)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3370)
   (new-vec 1)
   (move 0 1 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3371)
   (new-vec 1)
   (move 0 2 vec 0)
   (tail-call 2 1)
   (label else%3371)
   (load bool 0 res 0)
   (return)
   (label else%3370)
   (load bool 0 res 0)
   (return)
   (label else%3369)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 153 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3372)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3373)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 147 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3374)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 1)
   (move 0 1 vec 0)
   (tail-call 3 1)
   (label else%3374)
   (load bool 0 res 0)
   (return)
   (label else%3373)
   (load bool 0 res 0)
   (return)
   (label else%3372)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 155 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3375)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 0 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3376)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (tail-call glo 48)
   (label else%3376)
   (load bool 0 res 0)
   (return)
   (label else%3375)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 157 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3377)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3378)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 2 vec 1)
   (tail-call glo 48)
   (label else%3378)
   (load bool 0 res 0)
   (return)
   (label else%3377)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 159 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3379)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call 2 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3380)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 2 vec 1)
   (tail-call glo 48)
   (label else%3380)
   (load bool 0 res 0)
   (return)
   (label else%3379)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 161 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3381)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 48)
   (label else%3381)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 163 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3382)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 48)
   (label else%3382)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 165 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3383)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3384)
   (new-vec 1)
   (move 0 2 vec 0)
   (tail-call 2 1)
   (label else%3384)
   (load bool 0 res 0)
   (return)
   (label else%3383)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 167 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3385)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 1 vec 1)
   (call glo 48 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3386)
   (new-vec 1)
   (move 0 2 vec 0)
   (tail-call 2 1)
   (label else%3386)
   (load bool 0 res 0)
   (return)
   (label else%3385)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 169 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3387)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (extend)
   (new-vec 1)
   (move 0 2 vec 0)
   (tail-call 2 1)
   (label else%3387)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 171 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3388)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 48)
   (label else%3388)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 173 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3389)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3389)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 175 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3390)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3390)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 151 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3391)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (load bool 0 res 0)
   (return)
   (label else%3391)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 177 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3392)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load bool 1 res 0)
   (return)
   (label else%3392)
   (new-vec 3)
   (load sym transparent? vec 0)
   (load str "quasar: ~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%815)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3393)
   (move 0 0 res 0)
   (return)
   (label else%3393)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 1 1 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3394)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 2)
   (label else%3394)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 2 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%816)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3395)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (tail-call 4 0)
   (label else%3395)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (call glo 230 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3396)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 3)
   (label else%3396)
   (new-vec 1)
   (load str "begin%" vec 0)
   (call glo 133 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call 1 3 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 3 1 vec 1)
   (call 4 0 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%817)
   (new-vec 0)
   (load close-flat 939 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 19 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 146 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 5 0 vec 1)
   (load close-flat 940 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 0 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%818)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 4 0 vec 1)
   (load close-flat 941 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 170)

   (label lambda-deep%819)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 4 0 vec 1)
   (load close-flat 942 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 223)

   (label lambda-deep%820)
   (new-vec 2)
   (move 2 1 vec 0)
   (move 3 1 vec 1)
   (call 4 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 150)

   (label lambda-flat%821)
   (new-vec 1)
   (move 1 3 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (load close-flat 943 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (move 0 1 vec 2)
   (move tmp 1 vec 3)
   (tail-call 1 1)

   (label lambda-deep%822)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load nil _ vec 0)
   (move 2 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 3 vec 0)
   (move 1 0 vec 1)
   (load close-flat 944 tmp 2)
   (new-vec 4)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (tail-call 3 1)

   (label lambda-flat%823)
   (new-vec 5)
   (move 1 1 vec 0)
   (move 1 2 vec 1)
   (move 1 3 vec 2)
   (move 1 4 vec 3)
   (move 0 0 vec 4)
   (load close-flat 945 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (move 0 1 vec 2)
   (move tmp 0 vec 3)
   (tail-call 1 3)

   (label lambda-flat%824)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 946 tmp 0)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 1 0 vec 1)
   (move 0 1 vec 2)
   (move tmp 0 vec 3)
   (tail-call 1 2)

   (label lambda-flat%825)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (load close-flat 947 tmp 0)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 1 0 vec 1)
   (move 0 1 vec 2)
   (move tmp 0 vec 3)
   (tail-call 1 2)

   (label lambda-flat%826)
   (new-vec 3)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (move 1 4 vec 2)
   (load close-flat 948 tmp 0)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 1 0 vec 1)
   (move 0 1 vec 2)
   (move tmp 0 vec 3)
   (tail-call 1 2)

   (label lambda-flat%827)
   (load close-deep 949 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 950 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 0 vec 1)
   (call glo 49 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3397)
   (new-vec 1)
   (load sym vector-set! vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 242 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load int 0 vec 0)
   (call glo 178 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call glo 142 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (move 0 0 vec 2)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 152 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3397)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 150 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%828)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3398)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 2 3 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 951 tmp 0)
   (jump-if-false 0 0 else%3399)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 0)
   (label else%3399)
   (new-vec 2)
   (move 3 0 vec 0)
   (move glo 130 vec 1)
   (call glo 25 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3398)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3400)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3401)
   (move 0 1 res 0)
   (return)
   (label else%3401)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)
   (label else%3400)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-flat%829)
   (new-vec 1)
   (load sym vector vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 144 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%830)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3402)
   (new-vec 0)
   (call glo 188 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)
   (label else%3402)
   (new-vec 1)
   (load sym cons vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call 1 0 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)

   (label lambda-deep%831)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 2 2 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (call 3 2 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move tmp 0 vec 1)
   (call 3 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 146)

   (label lambda-flat%832)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call 1 2)

   (label lambda-flat%833)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call 1 2)

   (label lambda-flat%834)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 3 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3403)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (call 1 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 248)
   (label else%3403)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (call 1 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%835)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3404)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3405)
   (load bool 0 res 0)
   (return)
   (label else%3405)
   (new-vec 4)
   (load sym box-expression vec 0)
   (load str "mismatch between ~s and ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 2 vec 3)
   (tail-call glo 120)
   (label else%3404)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3406)
   (new-vec 4)
   (load sym box-expression vec 0)
   (load str "mismatch between ~s and ~s" vec 1)
   (move 2 1 vec 2)
   (move 2 2 vec 3)
   (tail-call glo 120)
   (label else%3406)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3407)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (call glo 25 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3408)
   (load bool 1 res 0)
   (return)
   (label else%3408)
   (new-vec 5)
   (load sym box-expression vec 0)
   (load str "~x in ~s but not in ~s" vec 1)
   (move 2 0 vec 2)
   (move 2 1 vec 3)
   (move 2 2 vec 4)
   (tail-call glo 120)
   (label else%3407)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%836)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 270)

   (label lambda-deep%837)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%838)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%839)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 270 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 264 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 262 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 270 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-deep%840)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%841)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%842)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%843)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 270 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 262 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-deep%844)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%845)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%846)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%847)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%848)
   (new-vec 2)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (call glo 270 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 2 vec 0)
   (call glo 262 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call 1 1 2)
   (move res 0 tmp 2)
   (new-vec 0)
   (call 1 0 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (move tmp 3 vec 2)
   (call glo 268 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 2 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 280)

   (label lambda-deep%849)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%850)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%851)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%852)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 270 0)
   (move res 0 tmp 0)
   (new-vec 0)
   (call 1 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 288)

   (label lambda-flat%853)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%854)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%855)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%856)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 270 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 278)

   (label lambda-flat%857)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%858)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%859)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%860)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 25)

   (label lambda-flat%861)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 25)

   (label lambda-deep%862)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (tail-call 3 0)

   (label lambda-deep%863)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (move 2 2 vec 2)
   (call 3 1 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call 3 3)

   (label lambda-deep%864)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 2 2 vec 2)
   (tail-call 3 0)

   (label lambda-flat%865)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (load nil _ vec 2)
   (tail-call glo 344)

   (label lambda-deep%866)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 246)

   (label lambda-deep%867)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call glo 248)

   (label lambda-flat%868)
   (new-vec 3)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (load nil _ vec 2)
   (tail-call glo 344)

   (label lambda-deep%869)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 4 0)

   (label lambda-deep%870)
   (jump-if-false 0 0 else%3409)
   (load close-deep 952 tmp 2)
   (new-vec 2)
   (move 2 0 vec 0)
   (load sym call-with-input-file vec 1)
   (call lib 40 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (extend)
   (load close-deep 953 tmp 3)
   (jump-if-false 0 0 else%3410)
   (new-vec 1)
   (move 0 0 vec 0)
   (tail-call tmp 3)
   (label else%3410)
   (new-vec 2)
   (move 3 0 vec 0)
   (load sym call-with-output-file vec 1)
   (call lib 40 4)
   (move res 0 tmp 4)
   (new-vec 1)
   (move tmp 4 vec 0)
   (tail-call tmp 3)
   (label else%3409)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 4 1 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-flat%871)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move 1 2 vec 2)
   (load close-flat 954 tmp 0)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 0 vec 3)
   (tail-call glo 404)

   (label lambda-flat%872)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 362 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (call glo 370 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%873)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 370 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-deep%874)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3411)
   (load nil _ res 0)
   (return)
   (label else%3411)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call lib 32 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-flat%875)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (call glo 380 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%876)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (call glo 382 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%877)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (call glo 388 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%878)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%879)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 370 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-flat%880)
   (new-vec 1)
   (move 1 3 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 2 vec 0)
   (move 0 0 vec 1)
   (call glo 352 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 1 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move tmp 1 vec 3)
   (tail-call 1 0)

   (label lambda-flat%881)
   (new-vec 1)
   (move 1 5 vec 0)
   (call glo 96 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "lambda-flat%" vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 5 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 4 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (load close-deep 955 tmp 2)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 12 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3412)
   (new-vec 1)
   (load int -1 vec 0)
   (tail-call tmp 2)
   (label else%3412)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 18 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)

   (label lambda-flat%882)
   (new-vec 1)
   (move 1 5 vec 0)
   (call glo 96 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "lambda-deep%" vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 5 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 4 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (load close-deep 956 tmp 2)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 12 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3413)
   (new-vec 1)
   (load int -1 vec 0)
   (tail-call tmp 2)
   (label else%3413)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 18 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)

   (label lambda-flat%883)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (load close-flat 957 tmp 0)
   (new-vec 3)
   (move 0 1 vec 0)
   (move 0 2 vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 409)

   (label lambda-deep%884)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 3 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call lib 26)

   (label lambda-flat%885)
   (new-vec 5)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (load sym vec vec 3)
   (move 1 2 vec 4)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 1 2 vec 0)
   (load int 1 vec 1)
   (call lib 1 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-deep%886)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 0 vec 1)
   (tail-call lib 26)

   (label lambda-deep%887)
   (jump-if-false 0 0 else%3414)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 27 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 3 vec 1)
   (call glo 20 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 27 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load int 4 vec 1)
   (call glo 20 3)
   (move res 0 tmp 3)
   (new-vec 5)
   (load sym move vec 0)
   (load sym res vec 1)
   (load int 0 vec 2)
   (move tmp 2 vec 3)
   (move tmp 3 vec 4)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3414)
   (new-vec 5)
   (load sym move vec 0)
   (load sym res vec 1)
   (load int 0 vec 2)
   (load sym tmp vec 3)
   (move 2 1 vec 4)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move 2 0 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%888)
   (jump-if-false 0 0 else%3415)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 41 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 1 vec 0)
   (move tmp 1 vec 1)
   (call glo 76 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 3 0)
   (label else%3415)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 1 vec 1)
   (tail-call 3 0)

   (label lambda-deep%889)
   (jump-if-false 0 0 else%3416)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 39 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (load sym tmp vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3416)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%890)
   (new-vec 1)
   (move 1 0 vec 0)
   (call glo 103 0)
   (load close-deep 958 tmp 0)
   (load close-deep 959 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load sym label vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3417)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call lib 24 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 0 vec 1)
   (call lib 22 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load char 108 vec 1)
   (call glo 77 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3417)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%891)
   (new-vec 2)
   (move 0 1 vec 0)
   (move 0 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 3 vec 1)
   (call lib 6 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3418)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3419)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)
   (label else%3419)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3420)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)
   (label else%3420)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3421)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 2 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)
   (label else%3421)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 2 0 vec 1)
   (call lib 21 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3422)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 3 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 4 1 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 28)
   (label else%3422)
   (new-vec 3)
   (load sym crossref vec 0)
   (load str "label not found: ~s" vec 1)
   (move 3 0 vec 2)
   (tail-call glo 120)
   (label else%3418)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load int 2 vec 1)
   (call lib 4 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 5 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 0 vec 1)
   (call glo 83 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3423)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 2 0)
   (label else%3423)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call 2 0)

   (label lambda-deep%892)
   (jump-if-false 0 0 else%3424)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 490 vec 0)
   (move 3 1 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 95 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move glo 491 vec 0)
   (move 3 1 vec 1)
   (move tmp 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 3 1 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (tail-call 4 0)
   (label else%3424)
   (new-vec 3)
   (load sym crossref vec 0)
   (load str "Illegal instruction: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%893)
   (new-vec 2)
   (move glo 491 vec 0)
   (move 1 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move glo 490 vec 0)
   (move 2 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym jump vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3425)
   (new-vec 4)
   (move 1 0 vec 0)
   (move 3 1 vec 1)
   (move 3 2 vec 2)
   (move 3 3 vec 3)
   (tail-call 4 0)
   (label else%3425)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym jump-if-false vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3426)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 960 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym res vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3427)
   (new-vec 1)
   (move glo 487 vec 0)
   (tail-call tmp 0)
   (label else%3427)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3428)
   (new-vec 1)
   (move glo 486 vec 0)
   (tail-call tmp 0)
   (label else%3428)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym glo vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3429)
   (new-vec 1)
   (move glo 485 vec 0)
   (tail-call tmp 0)
   (label else%3429)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lib vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3430)
   (new-vec 1)
   (move glo 484 vec 0)
   (tail-call tmp 0)
   (label else%3430)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3426)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym new-vec vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3431)
   (new-vec 1)
   (move 3 0 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 491 vec 0)
   (move 3 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move glo 458 vec 1)
   (call lib 33 1)
   (move res 0 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (move tmp 1 vec 2)
   (move 3 3 vec 3)
   (tail-call 4 0)
   (label else%3431)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym extend vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3432)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 2 vec 0)
   (move 3 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move 3 2 vec 2)
   (move 3 3 vec 3)
   (tail-call 4 0)
   (label else%3432)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym move vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3433)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 961 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym res vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3434)
   (new-vec 1)
   (move glo 487 vec 0)
   (tail-call tmp 0)
   (label else%3434)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3435)
   (new-vec 1)
   (move glo 486 vec 0)
   (tail-call tmp 0)
   (label else%3435)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym glo vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3436)
   (new-vec 1)
   (move glo 485 vec 0)
   (tail-call tmp 0)
   (label else%3436)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lib vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3437)
   (new-vec 1)
   (move glo 484 vec 0)
   (tail-call tmp 0)
   (label else%3437)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym vec vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3438)
   (new-vec 1)
   (move 4 2 vec 0)
   (tail-call tmp 0)
   (label else%3438)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3433)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym load vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3439)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 962 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym res vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3440)
   (new-vec 1)
   (move glo 487 vec 0)
   (tail-call tmp 0)
   (label else%3440)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3441)
   (new-vec 1)
   (move glo 486 vec 0)
   (tail-call tmp 0)
   (label else%3441)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym glo vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3442)
   (new-vec 1)
   (move glo 485 vec 0)
   (tail-call tmp 0)
   (label else%3442)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lib vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3443)
   (new-vec 1)
   (move glo 484 vec 0)
   (tail-call tmp 0)
   (label else%3443)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym vec vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3444)
   (new-vec 1)
   (move 4 2 vec 0)
   (tail-call tmp 0)
   (label else%3444)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3439)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tail-call vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3445)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 963 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym res vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3446)
   (new-vec 1)
   (move glo 487 vec 0)
   (tail-call tmp 0)
   (label else%3446)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3447)
   (new-vec 1)
   (move glo 486 vec 0)
   (tail-call tmp 0)
   (label else%3447)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym glo vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3448)
   (new-vec 1)
   (move glo 485 vec 0)
   (tail-call tmp 0)
   (label else%3448)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lib vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3449)
   (new-vec 1)
   (move glo 484 vec 0)
   (tail-call tmp 0)
   (label else%3449)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3445)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym call vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3450)
   (new-vec 2)
   (move 1 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 964 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym res vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3451)
   (new-vec 1)
   (move glo 487 vec 0)
   (tail-call tmp 0)
   (label else%3451)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3452)
   (new-vec 1)
   (move glo 486 vec 0)
   (tail-call tmp 0)
   (label else%3452)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym glo vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3453)
   (new-vec 1)
   (move glo 485 vec 0)
   (tail-call tmp 0)
   (label else%3453)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lib vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3454)
   (new-vec 1)
   (move glo 484 vec 0)
   (tail-call tmp 0)
   (label else%3454)
   (new-vec 2)
   (move 4 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3450)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym return vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3455)
   (new-vec 1)
   (move 3 3 vec 0)
   (tail-call 4 2)
   (label else%3455)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym halt vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3456)
   (new-vec 1)
   (load str "halt" vec 0)
   (tail-call glo 434)
   (label else%3456)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym nop vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3457)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 3 1 vec 1)
   (move 3 2 vec 2)
   (move 3 3 vec 3)
   (tail-call 4 0)
   (label else%3457)
   (new-vec 2)
   (move glo 490 vec 0)
   (move 3 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (load sym run vec 0)
   (load str "Illegal instruction: ~s" vec 1)
   (move tmp 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%894)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call lib 53 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 116 1)
   (load close-deep 965 tmp 1)
   (load close-deep 966 tmp 2)
   (new-vec 2)
   (move glo 490 vec 0)
   (move 2 0 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load sym check-and-jump vec 1)
   (call lib 40 3)
   (move res 0 tmp 3)
   (jump-if-false tmp 3 else%3458)
   (new-vec 2)
   (move glo 491 vec 0)
   (move 2 0 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load int 0 vec 1)
   (call lib 36 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (load sym lib vec 1)
   (call lib 40 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)
   (label else%3458)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 2)

   (label lambda-deep%895)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call lib 53 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 116 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 103 1)
   (new-vec 0)
   (load close-flat 967 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 2 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call lib 53 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 116 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 103 1)
   (new-vec 1)
   (move glo 486 vec 0)
   (call glo 94 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 463 vec 0)
   (move tmp 1 vec 1)
   (call glo 50 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call lib 53 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 116 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 103 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 2 3 vec 0)
   (move tmp 1 vec 1)
   (call glo 116 1)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 103 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%896)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 2 1 vec 1)
   (call lib 26 1)
   (move res 0 tmp 1)
   (new-vec 0)
   (call lib 32 2)
   (move res 0 tmp 2)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move 3 2 vec 3)
   (tail-call 4 0)

   (label lambda-flat%897)
   (new-vec 1)
   (move 1 0 vec 0)
   (tail-call 1 1)

   (label lambda-flat%898)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%899)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 500 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%900)
   (new-vec 6)
   (move 0 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (move 1 2 vec 3)
   (move 1 1 vec 4)
   (move 1 0 vec 5)
   (tail-call glo 411)

   (label lambda-deep%901)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3459)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 4 0)
   (label else%3459)
   (new-vec 2)
   (move 3 0 vec 0)
   (move 0 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call 4 0 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%902)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 108 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3460)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 968 tmp 0)
   (new-vec 0)
   (load close-flat 969 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3460)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\new~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%903)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\new" vec 1)
   (tail-call glo 120)

   (label lambda-flat%904)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 99 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3461)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 970 tmp 0)
   (new-vec 0)
   (load close-flat 971 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3461)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%905)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa" vec 1)
   (tail-call glo 120)

   (label lambda-flat%906)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3462)
   (new-vec 1)
   (move glo 78 vec 0)
   (tail-call 1 0)
   (label else%3462)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\tab~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%907)
   (new-vec 1)
   (move glo 78 vec 0)
   (tail-call 1 0)

   (label lambda-flat%908)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%909)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%910)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 972 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%911)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%912)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (load close-flat 973 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%913)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%914)
   (new-vec 2)
   (load sym quote vec 0)
   (move 0 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%915)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%916)
   (new-vec 2)
   (load sym quasiquote vec 0)
   (move 0 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%917)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%918)
   (new-vec 2)
   (load sym unquote-splicing vec 0)
   (move 0 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%919)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%920)
   (new-vec 2)
   (load sym unquote vec 0)
   (move 0 0 vec 1)
   (call glo 11 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%921)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%922)
   (load close-deep 974 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 116 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3463)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3463)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 84 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%923)
   (new-vec 2)
   (load sym read vec 0)
   (load str "end of input stream" vec 1)
   (tail-call glo 120)

   (label lambda-flat%924)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 97 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3464)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (load close-flat 975 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 109)
   (label else%3464)
   (new-vec 3)
   (load char 45 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 110)

   (label lambda-flat%925)
   (new-vec 1)
   (load sym - vec 0)
   (tail-call 1 0)

   (label lambda-flat%926)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 97 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3465)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 47 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 98 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 109)
   (label else%3465)
   (new-vec 3)
   (load char 43 vec 0)
   (move 1 1 vec 1)
   (move 1 0 vec 2)
   (tail-call glo 110)

   (label lambda-flat%927)
   (new-vec 1)
   (load sym + vec 0)
   (tail-call 1 0)

   (label lambda-flat%928)
   (move 0 0 res 0)
   (return)

   (label lambda-deep%929)
   (new-vec 1)
   (move 0 0 vec 0)
   (extend)
   (new-vec 2)
   (move 2 0 vec 0)
   (move 7 2 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 119 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (call 7 1 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 0)
   (call 6 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 16)

   (label lambda-deep%930)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 0 0 vec 1)
   (call 5 0 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 146)

   (label lambda-flat%931)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-flat%932)
   (new-vec 1)
   (move 1 2 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%933)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3466)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 2 vec 1)
   (tail-call 3 3)
   (label else%3466)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3467)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)
   (label else%3467)
   (new-vec 1)
   (extend)
   (load close-deep 976 0 0)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call 0 0 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move 4 2 vec 1)
   (call 4 3 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call 2 0 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 148)

   (label lambda-deep%934)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3468)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 3 3 vec 1)
   (tail-call 3 2)
   (label else%3468)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (extend)
   (new-vec 0)
   (load close-flat 977 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (call glo 50 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (new-vec 1)
   (move 1 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load str "?" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "is-" vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 23 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 4 0 vec 0)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 152 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 2 1 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move glo 144 vec 0)
   (move 0 0 vec 1)
   (call glo 50 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move 1 1 vec 0)
   (move tmp 2 vec 1)
   (move 5 3 vec 2)
   (call glo 231 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 5 2 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 146 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (extend)
   (load close-deep 978 0 0)
   (new-vec 2)
   (move 2 1 vec 0)
   (load int 1 vec 1)
   (call 0 0 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call glo 152 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 3 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 3 1 vec 0)
   (call lib 28 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call 4 0 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 148)

   (label lambda-flat%935)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%936)
   (new-vec 1)
   (load bool 0 vec 0)
   (call glo 180 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 142)

   (label lambda-flat%937)
   (move 1 0 res 0)
   (return)

   (label lambda-flat%938)
   (new-vec 1)
   (move 1 1 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%939)
   (new-vec 1)
   (load str "begin%" vec 0)
   (tail-call glo 133)

   (label lambda-flat%940)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-flat%941)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-flat%942)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (tail-call 1 1)

   (label lambda-flat%943)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%944)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (move tmp 0 vec 2)
   (call glo 240 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%945)
   (new-vec 3)
   (move 1 3 vec 0)
   (move 0 0 vec 1)
   (move 1 4 vec 2)
   (load close-flat 979 tmp 0)
   (new-vec 4)
   (move 1 1 vec 0)
   (move 1 0 vec 1)
   (move 0 1 vec 2)
   (move tmp 0 vec 3)
   (tail-call 1 2)

   (label lambda-flat%946)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 152 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%947)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call glo 223 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call 1 0)

   (label lambda-flat%948)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 27 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (move tmp 0 vec 3)
   (call glo 244 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%949)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 1 vec 1)
   (tail-call 2 2)

   (label lambda-flat%950)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 0 0 vec 1)
   (tail-call glo 25)

   (label lambda-deep%951)
   (jump-if-false 0 0 else%3469)
   (load nil _ res 0)
   (return)
   (label else%3469)
   (new-vec 3)
   (load sym scan-expression vec 0)
   (load str "undeclared variable: ~s" vec 1)
   (move 4 0 vec 2)
   (tail-call glo 120)

   (label lambda-deep%952)
   (new-vec 1)
   (move 5 1 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%953)
   (jump-if-false 0 0 else%3470)
   (new-vec 1)
   (load str "Sic transit." vec 0)
   (tail-call tmp 2)
   (label else%3470)
   (new-vec 2)
   (load str " Multiple definition for ~s" vec 0)
   (move 4 0 vec 1)
   (call glo 93 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (call glo 134 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (move tmp 3 vec 0)
   (tail-call tmp 2)

   (label lambda-flat%954)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (call glo 368 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (move 0 2 vec 2)
   (tail-call 1 0)

   (label lambda-deep%955)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move 3 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 0 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move 3 2 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 6)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move 2 1 vec 3)
   (move 2 2 vec 4)
   (move tmp 3 vec 5)
   (tail-call 3 1)

   (label lambda-deep%956)
   (new-vec 2)
   (move 0 0 vec 0)
   (move 1 0 vec 1)
   (call glo 11 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move 3 3 vec 1)
   (call lib 26 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 0 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 3 vec 0)
   (move 3 2 vec 1)
   (call lib 26 3)
   (move res 0 tmp 3)
   (new-vec 6)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (move 2 1 vec 3)
   (move 2 2 vec 4)
   (move tmp 3 vec 5)
   (tail-call 3 1)

   (label lambda-flat%957)
   (new-vec 1)
   (load str " / Factorized" vec 0)
   (call glo 135 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (call glo 17 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 17 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 2 vec 0)
   (call glo 17 2)
   (move res 0 tmp 2)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 1 0 vec 1)
   (move tmp 1 vec 2)
   (move tmp 2 vec 3)
   (tail-call glo 350)

   (label lambda-deep%958)
   (new-vec 2)
   (load str "   " vec 0)
   (move 2 0 vec 1)
   (call glo 118 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 2 0 vec 1)
   (tail-call glo 116)

   (label lambda-deep%959)
   (jump-if-false 0 0 else%3471)
   (new-vec 1)
   (move 2 0 vec 0)
   (call glo 103 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)
   (label else%3471)
   (new-vec 1)
   (load sym ikke-noget vec 0)
   (tail-call tmp 0)

   (label lambda-deep%960)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (extend)
   (load close-deep 980 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 427 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3472)
   (new-vec 0)
   (extend)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call tmp 0)
   (label else%3472)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%961)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (load close-deep 981 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym res vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3473)
   (new-vec 1)
   (move glo 487 vec 0)
   (tail-call tmp 1)
   (label else%3473)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym tmp vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3474)
   (new-vec 1)
   (move glo 486 vec 0)
   (tail-call tmp 1)
   (label else%3474)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym glo vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3475)
   (new-vec 1)
   (move glo 485 vec 0)
   (tail-call tmp 1)
   (label else%3475)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym lib vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3476)
   (new-vec 1)
   (move glo 484 vec 0)
   (tail-call tmp 1)
   (label else%3476)
   (new-vec 2)
   (move 6 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%962)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 3 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (extend)
   (load close-deep 982 tmp 1)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym nil vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3477)
   (new-vec 1)
   (move glo 458 vec 0)
   (tail-call tmp 1)
   (label else%3477)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym bool vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3478)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (extend)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 0 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3479)
   (new-vec 1)
   (move glo 459 vec 0)
   (tail-call tmp 1)
   (label else%3479)
   (new-vec 2)
   (move 0 0 vec 0)
   (load int 1 vec 1)
   (call lib 8 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3480)
   (new-vec 1)
   (move glo 460 vec 0)
   (tail-call tmp 1)
   (label else%3480)
   (new-vec 3)
   (load sym run vec 0)
   (load str "not a boolean: ~s" vec 1)
   (move 0 0 vec 2)
   (call glo 120 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3478)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym int vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3481)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 430 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3481)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym char vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3482)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call lib 15 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 432 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3482)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym str vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3483)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 434 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3483)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym sym vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3484)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 436 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3484)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym close-flat vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3485)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move 6 2 vec 0)
   (call glo 11 3)
   (move res 0 tmp 3)
   (new-vec 1)
   (load str "flat-closure%" vec 0)
   (call glo 133 4)
   (move res 0 tmp 4)
   (new-vec 3)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (move tmp 4 vec 2)
   (call glo 438 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3485)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym close-deep vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3486)
   (new-vec 2)
   (move 4 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (load str "deep-closure%" vec 0)
   (call glo 133 3)
   (move res 0 tmp 3)
   (new-vec 3)
   (move tmp 2 vec 0)
   (move 6 1 vec 1)
   (move tmp 3 vec 2)
   (call glo 438 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3486)
   (new-vec 2)
   (move 0 0 vec 0)
   (load sym void vec 1)
   (call lib 40 2)
   (move res 0 tmp 2)
   (jump-if-false tmp 2 else%3487)
   (new-vec 1)
   (move glo 462 vec 0)
   (tail-call tmp 1)
   (label else%3487)
   (new-vec 2)
   (move 6 1 vec 0)
   (move 0 0 vec 1)
   (call glo 20 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)

   (label lambda-deep%963)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 5 2 vec 1)
   (move 5 3 vec 2)
   (tail-call 6 1)

   (label lambda-deep%964)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 5 0 vec 0)
   (load int 1 vec 1)
   (call lib 1 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 3 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move glo 486 vec 0)
   (move tmp 2 vec 1)
   (call glo 482 2)
   (move res 0 tmp 2)
   (new-vec 4)
   (move tmp 1 vec 0)
   (move 5 1 vec 1)
   (move tmp 2 vec 2)
   (move 5 3 vec 3)
   (call glo 495 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move 5 2 vec 1)
   (move tmp 1 vec 2)
   (tail-call 6 1)

   (label lambda-deep%965)
   (new-vec 0)
   (call lib 53 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 103 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-deep%966)
   (jump-if-false 0 0 else%3488)
   (new-vec 1)
   (load int 9 vec 0)
   (call lib 15 2)
   (move res 0 tmp 2)
   (new-vec 0)
   (call lib 53 3)
   (move res 0 tmp 3)
   (new-vec 2)
   (move tmp 2 vec 0)
   (move tmp 3 vec 1)
   (call lib 54 2)
   (new-vec 0)
   (call lib 53 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (load str "; " vec 0)
   (move tmp 2 vec 1)
   (call glo 118 2)
   (new-vec 2)
   (move glo 491 vec 0)
   (move 3 0 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 2 vec 0)
   (load int 1 vec 1)
   (call lib 36 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move glo 130 vec 0)
   (move tmp 2 vec 1)
   (call glo 20 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call glo 116 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (tail-call tmp 1)
   (label else%3488)
   (new-vec 1)
   (load str "ikke noget" vec 0)
   (tail-call tmp 1)

   (label lambda-flat%967)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 94 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move glo 463 vec 0)
   (move tmp 0 vec 1)
   (tail-call glo 50)

   (label lambda-flat%968)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 105 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3489)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 983 tmp 0)
   (new-vec 0)
   (load close-flat 984 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3489)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newl~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%969)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newl" vec 1)
   (tail-call glo 120)

   (label lambda-flat%970)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3490)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 985 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 986 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3490)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%971)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\spa" vec 1)
   (tail-call glo 120)

   (label lambda-flat%972)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%973)
   (new-vec 2)
   (move 1 1 vec 0)
   (move 0 0 vec 1)
   (call lib 26 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)

   (label lambda-deep%974)
   (jump-if-false 0 0 else%3491)
   (new-vec 1)
   (move 2 0 vec 0)
   (load close-flat 987 tmp 0)
   (new-vec 1)
   (move 2 0 vec 0)
   (load close-flat 988 tmp 1)
   (new-vec 3)
   (move 2 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)
   (label else%3491)
   (load close-deep 989 tmp 0)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 102 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (jump-if-false tmp 1 else%3492)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call tmp 0)
   (label else%3492)
   (new-vec 2)
   (move 1 0 vec 0)
   (load char 70 vec 1)
   (call lib 40 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (tail-call tmp 0)

   (label lambda-flat%975)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 0 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3493)
   (new-vec 2)
   (load int 0 vec 0)
   (move 0 0 vec 1)
   (call lib 2 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call 1 0)
   (label else%3493)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (load str "-" vec 0)
   (move tmp 0 vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call lib 23)

   (label lambda-deep%976)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3494)
   (new-vec 1)
   (load sym eqv? vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 227 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call glo 152)
   (label else%3494)
   (new-vec 1)
   (load sym eqv? vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 27 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 227 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 4 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 152 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (load bool 1 vec 0)
   (call glo 180 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 142 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 2)
   (move res 0 tmp 2)
   (new-vec 1)
   (move tmp 2 vec 0)
   (call 1 0 2)
   (move res 0 tmp 2)
   (new-vec 3)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (move tmp 2 vec 2)
   (tail-call glo 148)

   (label lambda-flat%977)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 24 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (load str "%" vec 1)
   (call lib 20 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move tmp 0 vec 0)
   (tail-call glo 133)

   (label lambda-deep%978)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 31 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3495)
   (load nil _ res 0)
   (return)
   (label else%3495)
   (new-vec 1)
   (load sym vector-ref vec 0)
   (call glo 144 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 1 vec 0)
   (call glo 178 1)
   (move res 0 tmp 1)
   (new-vec 1)
   (move tmp 1 vec 0)
   (call glo 142 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 6 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 11 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (call glo 152 0)
   (move res 0 tmp 0)
   (new-vec 1)
   (move 0 0 vec 0)
   (call lib 28 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move 0 1 vec 0)
   (load int 1 vec 1)
   (call lib 1 2)
   (move res 0 tmp 2)
   (new-vec 2)
   (move tmp 1 vec 0)
   (move tmp 2 vec 1)
   (call 1 0 1)
   (move res 0 tmp 1)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move tmp 1 vec 1)
   (tail-call lib 26)

   (label lambda-flat%979)
   (new-vec 3)
   (move 1 2 vec 0)
   (move 1 1 vec 1)
   (move 0 0 vec 2)
   (call glo 148 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move tmp 0 vec 0)
   (move 0 1 vec 1)
   (tail-call 1 0)

   (label lambda-deep%980)
   (jump-if-false 0 0 else%3496)
   (new-vec 1)
   (move 7 0 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 7 1 vec 1)
   (move 7 2 vec 2)
   (move 7 3 vec 3)
   (tail-call 8 0)
   (label else%3496)
   (new-vec 2)
   (move 5 0 vec 0)
   (load int 2 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 7 1 vec 1)
   (move 7 2 vec 2)
   (move 7 3 vec 3)
   (tail-call 8 0)

   (label lambda-deep%981)
   (new-vec 2)
   (move 5 0 vec 0)
   (load int 1 vec 1)
   (call lib 36 0)
   (move res 0 tmp 0)
   (new-vec 2)
   (move 0 0 vec 0)
   (move tmp 0 vec 1)
   (call lib 36 1)
   (move res 0 tmp 1)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 7 0 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 7 1 vec 1)
   (move 7 2 vec 2)
   (move 7 3 vec 3)
   (tail-call 8 0)

   (label lambda-deep%982)
   (new-vec 3)
   (move 2 0 vec 0)
   (move tmp 0 vec 1)
   (move 0 0 vec 2)
   (call lib 37 0)
   (new-vec 1)
   (move 7 0 vec 0)
   (call glo 64 0)
   (move res 0 tmp 0)
   (new-vec 4)
   (move tmp 0 vec 0)
   (move 7 1 vec 1)
   (move 7 2 vec 2)
   (move 7 3 vec 3)
   (tail-call 8 0)

   (label lambda-flat%983)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 110 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3497)
   (new-vec 2)
   (move 1 0 vec 0)
   (move 1 1 vec 1)
   (load close-flat 990 tmp 0)
   (new-vec 0)
   (load close-flat 991 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3497)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newli~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%984)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newli" vec 1)
   (tail-call glo 120)

   (label lambda-flat%985)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3498)
   (new-vec 1)
   (move glo 80 vec 0)
   (tail-call 1 0)
   (label else%3498)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\space~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%986)
   (new-vec 1)
   (move glo 80 vec 0)
   (tail-call 1 0)

   (label lambda-flat%987)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3499)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call 1 0)
   (label else%3499)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown #t~s sequence" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%988)
   (new-vec 1)
   (load bool 1 vec 0)
   (tail-call 1 0)

   (label lambda-deep%989)
   (jump-if-false 0 0 else%3500)
   (new-vec 1)
   (move 3 0 vec 0)
   (load close-flat 992 tmp 0)
   (new-vec 1)
   (move 3 0 vec 0)
   (load close-flat 993 tmp 1)
   (new-vec 3)
   (move 3 1 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 105)
   (label else%3500)
   (new-vec 2)
   (move 2 0 vec 0)
   (load char 92 vec 1)
   (call lib 40 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3501)
   (new-vec 2)
   (move 3 1 vec 0)
   (move 3 0 vec 1)
   (tail-call glo 111)
   (label else%3501)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown # code: ~s" vec 1)
   (move 2 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%990)
   (new-vec 2)
   (move 0 0 vec 0)
   (load char 101 vec 1)
   (call glo 77 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3502)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 994 tmp 0)
   (new-vec 1)
   (move 1 1 vec 0)
   (load close-flat 995 tmp 1)
   (new-vec 3)
   (move 1 0 vec 0)
   (move tmp 0 vec 1)
   (move tmp 1 vec 2)
   (tail-call glo 104)
   (label else%3502)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newlin~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%991)
   (new-vec 2)
   (load sym read vec 0)
   (load str "Invalid character name #\\newlin" vec 1)
   (tail-call glo 120)

   (label lambda-flat%992)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3503)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 1 0)
   (label else%3503)
   (new-vec 3)
   (load sym read vec 0)
   (load str "unknown #f~s sequence" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%993)
   (new-vec 1)
   (load bool 0 vec 0)
   (tail-call 1 0)

   (label lambda-flat%994)
   (new-vec 1)
   (move 0 0 vec 0)
   (call glo 82 0)
   (move res 0 tmp 0)
   (jump-if-false tmp 0 else%3504)
   (new-vec 1)
   (move glo 79 vec 0)
   (tail-call 1 0)
   (label else%3504)
   (new-vec 3)
   (load sym read vec 0)
   (load str "Invalid character name #\\newline~s" vec 1)
   (move 0 0 vec 2)
   (tail-call glo 120)

   (label lambda-flat%995)
   (new-vec 1)
   (move glo 79 vec 0)
   (tail-call 1 0))
  "DAIMI-Scheme compiler, 03-10-12")
