(define not (lambda (v%0) (if v%0 #f #t)))
(define compose (lambda (f%1 g%2) (lambda (x%3) (f%1 (g%2 x%3)))))
(define compose2 (lambda (f%4 g%5) (lambda (x%6 y%7) (f%4 (g%5 x%6 y%7)))))
(define equal? (lambda (x%8 y%9) (if (eqv? x%8 y%9) #t (if (string? x%8) (if (string? y%9) (string=? x%8 y%9) #f) (if (pair? x%8) (if (pair? y%9) (if (null? (cdr x%8)) (if (null? (cdr y%9)) (equal? (car x%8) (car y%9)) #f) (if (equal? (car x%8) (car y%9)) (equal? (cdr x%8) (cdr y%9)) #f)) #f) (if (vector? x%8) (if (vector? y%9) (let ([len%10 (vector-length x%8)]) (if (= len%10 (vector-length y%9)) (letrec ([traverse%11 (lambda (i%12) (if (= i%12 0) (equal? (vector-ref x%8 0) (vector-ref y%9 0)) (if (equal? (vector-ref x%8 i%12) (vector-ref y%9 i%12)) (traverse%11 (- i%12 1)) #f)))]) (traverse%11 (- len%10 1))) #f)) #f) #f))))))
(define alt-equal? (lambda (x%13 y%14) (call/cc (lambda (k%15) (letrec ([walk%16 (lambda (x%17 y%18) (if (eqv? x%17 y%18) #t (if (string? x%17) (if (string? y%18) (if (string=? x%17 y%18) #t (k%15 #f)) (k%15 #f)) (if (pair? x%17) (if (pair? y%18) (if (null? (cdr x%17)) (if (null? (cdr y%18)) (walk%16 (car x%17) (car y%18)) (k%15 #f)) (if (null? (cdr y%18)) (k%15 #f) (begin (walk%16 (car x%17) (car y%18)) (walk%16 (cdr x%17) (cdr y%18))))) (k%15 #f)) (if (vector? x%17) (if (vector? y%18) (let ([len%19 (vector-length x%17)]) (if (= len%19 (vector-length y%18)) (letrec ([traverse%20 (lambda (i%21) (if (= i%21 0) (walk%16 (vector-ref x%17 0) (vector-ref y%18 0)) (begin (walk%16 (vector-ref x%17 i%21) (vector-ref y%18 i%21)) (traverse%20 (- i%21 1)))))]) (traverse%20 (- len%19 1))) (k%15 #f))) (k%15 #f)) (k%15 #f))))))]) (walk%16 x%13 y%14))))))
(define list (lambda xs%22 xs%22))
(define list? (lambda (v%23) (let ([or%24 (null? v%23)]) (if or%24 or%24 (pair? v%23)))))
(define proper-list? (lambda (xs%25) (letrec ([walk%26 (lambda (xs1%27 xs2%28) (let ([or%31 (null? xs2%28)]) (if or%31 or%31 (if (pair? xs2%28) (if (not (eqv? xs1%27 xs2%28)) (let ([xs2p%29 (cdr xs2%28)]) (let ([or%30 (null? xs2p%29)]) (if or%30 or%30 (if (pair? xs2p%29) (walk%26 (cdr xs1%27) (cdr xs2p%29)) #f)))) #f) #f))))]) (let ([or%32 (null? xs%25)]) (if or%32 or%32 (if (pair? xs%25) (walk%26 xs%25 (cdr xs%25)) #f))))))
(define test-proper-list? (lambda (range%33) (letrec ([outer%34 (lambda (head%35 last-pair%36 n%37) (let ([or%40 (> n%37 range%33)]) (if or%40 or%40 (letrec ([inner%38 (lambda (m%39) (if (eqv? (cdr last-pair%36) last-pair%36) (begin (set-cdr! last-pair%36 (cons n%37 '())) (outer%34 head%35 (cdr last-pair%36) (+ n%37 1))) (begin (set-cdr! last-pair%36 (cdr (cdr last-pair%36))) (if (proper-list? head%35) (error 'test-proper-list? "length ~s, cycle ~s" n%37 m%39) (inner%38 (+ m%39 1))))))]) (begin (set-cdr! last-pair%36 head%35) (if (proper-list? head%35) (error 'test-proper-list? "length ~s, cycle 0" n%37) (inner%38 0)))))))]) (let ([head%41 (cons 0 '())]) (outer%34 head%41 head%41 1)))))
(define append2 (lambda (xs%42 ys%43) (letrec ([walk%44 (lambda (xs%45) (if (null? xs%45) ys%43 (cons (car xs%45) (walk%44 (cdr xs%45)))))]) (walk%44 xs%42))))
(define append (lambda xs%46 (let ([case%47 (length xs%46)]) (if (eqv? case%47 0) '() (if (eqv? case%47 1) (car xs%46) (if (eqv? case%47 2) (append2 (car xs%46) (cadr xs%46)) (foldr append2 '() xs%46)))))))
(define reverse (lambda (xs%48) (foldl cons '() xs%48)))
(define length (lambda (xs%49) (letrec ([loop%50 (lambda (xs%51 a%52) (if (null? xs%51) a%52 (loop%50 (cdr xs%51) (+ a%52 1))))]) (loop%50 xs%49 0))))
(define last-pair (lambda (xs%53) (if (pair? xs%53) (letrec ([traverse%54 (lambda (p%55 xs%56) (if (pair? xs%56) (traverse%54 xs%56 (cdr xs%56)) p%55))]) (traverse%54 xs%53 (cdr xs%53))) (error 'last-pair "not a non-empty list: ~s" xs%53))))
(define list-ref (lambda (xs%57 i%58) (if (< i%58 0) (error 'list-ref "negative offset: ~s" i%58) (letrec ([loop%59 (lambda (ys%60 j%61) (if (null? ys%60) (error 'list-ref "offset ~s is out of range for ~s" i%58 xs%57) (if (= i%58 j%61) (car ys%60) (loop%59 (cdr ys%60) (+ j%61 1)))))]) (loop%59 xs%57 0)))))
(define ref-list (lambda (xs%62 x%63) (letrec ([loop%64 (lambda (ys%65 offset%66) (if (null? ys%65) (error 'ref-list "~s is not in ~s" x%63 xs%62) (if (equal? (car ys%65) x%63) offset%66 (loop%64 (cdr ys%65) (+ offset%66 1)))))]) (loop%64 xs%62 0))))
(define list-set! (lambda (xs%67 i%68 v%69) (if (< i%68 0) (error 'list-set! "negative offset: ~s" i%68) (letrec ([loop%70 (lambda (ys%71 j%72) (if (null? ys%71) (error 'list-set! "offset ~s is out of range for ~s" i%68 xs%67) (if (= i%68 j%72) (let ([res%73 (car ys%71)]) (begin (set-car! ys%71 v%69) res%73)) (loop%70 (cdr ys%71) (+ j%72 1)))))]) (loop%70 xs%67 0)))))
(define memq (lambda (e%74 es%75) (letrec ([loop%76 (lambda (es%77) (if (not (null? es%77)) (if (eqv? e%74 (car es%77)) es%77 (loop%76 (cdr es%77))) #f))]) (loop%76 es%75))))
(define memq? (lambda (e%78 es%79) (pair? (memq e%78 es%79))))
(define member (lambda (e%80 es%81) (letrec ([loop%82 (lambda (es%83) (if (not (null? es%83)) (if (equal? e%80 (car es%83)) es%83 (loop%82 (cdr es%83))) #f))]) (loop%82 es%81))))
(define member? (lambda (e%84 es%85) (pair? (member e%84 es%85))))
(define caar (lambda (p%86) (car (car p%86))))
(define cadr (lambda (p%87) (car (cdr p%87))))
(define cdar (lambda (p%88) (cdr (car p%88))))
(define cddr (lambda (p%89) (cdr (cdr p%89))))
(define caaar (compose car caar))
(define cdaar (compose cdr caar))
(define cadar (compose car cdar))
(define cddar (compose cdr cdar))
(define caadr (compose car cadr))
(define cdadr (compose cdr cadr))
(define caddr (compose car cddr))
(define cdddr (compose cdr cddr))
(define cadddr (compose car cdddr))
(define cddddr (compose cdr cdddr))
(define caddddr (compose car cddddr))
(define cdddddr (compose cdr cddddr))
(define all-same-length? (lambda (ls%90) (let ([len%91 (length (car ls%90))]) (andmap1 (lambda (l%92) (= len%91 (length l%92))) (cdr ls%90)))))
(define all-the-cars (lambda (ls%93) (map1 car ls%93)))
(define all-the-cdrs (lambda (ls%94) (map1 cdr ls%94)))
(define map1 (lambda (f%95 l%96) (letrec ([loop%97 (lambda (l%98) (if (null? l%98) '() (cons (f%95 (car l%98)) (loop%97 (cdr l%98)))))]) (loop%97 l%96))))
(define map-append1 (lambda (f%99 l%100) (letrec ([loop%101 (lambda (l%102) (if (null? l%102) '() (append (f%99 (car l%102)) (loop%101 (cdr l%102)))))]) (loop%101 l%100))))
(define andmap1 (lambda (f%103 l%104) (letrec ([loop%105 (lambda (l%106) (if (null? l%106) #t (if (f%103 (car l%106)) (loop%105 (cdr l%106)) #f)))]) (loop%105 l%104))))
(define ormap1 (lambda (f%107 l%108) (letrec ([loop%109 (lambda (l%110) (if (null? l%110) #f (let ([or%111 (f%107 (car l%110))]) (if or%111 or%111 (loop%109 (cdr l%110))))))]) (loop%109 l%108))))
(define map (lambda xs%112 (if (< (length xs%112) 2) (error 'map "missing list(s)") (let ([f%113 (car xs%112)] [ls%114 (cdr xs%112)]) (if (null? (cdr ls%114)) (map1 f%113 (car ls%114)) (if (all-same-length? ls%114) (letrec ([loop%115 (lambda (ls%116) (if (null? (car ls%116)) '() (cons (apply f%113 (all-the-cars ls%116)) (loop%115 (all-the-cdrs ls%116)))))]) (loop%115 ls%114)) (error 'map "mismatching lists")))))))
(define map-append (lambda xs%117 (if (< (length xs%117) 2) (error 'map-append "missing list(s)") (let ([f%118 (car xs%117)] [ls%119 (cdr xs%117)]) (if (null? (cdr ls%119)) (map-append1 f%118 (car ls%119)) (if (all-same-length? ls%119) (letrec ([loop%120 (lambda (ls%121) (if (null? (car ls%121)) '() (append (apply f%118 (all-the-cars ls%121)) (loop%120 (all-the-cdrs ls%121)))))]) (loop%120 ls%119)) (error 'map-append "mismatching lists")))))))
(define for-each1 (lambda (f%122 l%123) (letrec ([loop%124 (lambda (l%125) (if (null? l%125) '() (begin (f%122 (car l%125)) (loop%124 (cdr l%125)))))]) (loop%124 l%123))))
(define for-each (lambda xs%126 (if (< (length xs%126) 2) (error 'for-each "missing list(s)") (let ([f%127 (car xs%126)] [ls%128 (cdr xs%126)]) (if (null? (cdr ls%128)) (for-each1 f%127 (car ls%128)) (if (all-same-length? ls%128) (letrec ([loop%129 (lambda (ls%130) (if (null? (car ls%130)) '() (begin (apply f%127 (all-the-cars ls%130)) (loop%129 (all-the-cdrs ls%130)))))]) (loop%129 ls%128)) (error 'for-each "mismatching lists")))))))
(define foldr (lambda (f%131 b%132 l%133) (letrec ([loop%134 (lambda (l%135) (if (null? l%135) b%132 (f%131 (car l%135) (loop%134 (cdr l%135)))))]) (loop%134 l%133))))
(define foldl (lambda (f%136 b%137 l%138) (letrec ([loop%139 (lambda (l%140 b%141) (if (null? l%140) b%141 (loop%139 (cdr l%140) (f%136 (car l%140) b%141))))]) (loop%139 l%138 b%137))))
(define right-fold1 (lambda (f%142 b%143 l%144) (letrec ([fast-loop%145 (lambda (l%146) (if (null? l%146) b%143 (f%142 (fast-loop%145 (cdr l%146)) (car l%146))))]) (fast-loop%145 l%144))))
(define left-fold1 (lambda (f%147 b%148 l%149) (letrec ([loop%150 (lambda (l%151 b%152) (if (null? l%151) b%152 (loop%150 (cdr l%151) (f%147 b%152 (car l%151)))))]) (loop%150 l%149 b%148))))
(define variadic-right-fold (lambda xs%153 (if (<= (length xs%153) 2) (error 'right-fold "missing list(s)") (let ([f%154 (car xs%153)] [b%155 (cadr xs%153)] [ls%156 (cddr xs%153)]) (if (null? (cdr ls%156)) (right-fold1 f%154 b%155 (car ls%156)) (if (all-same-length? ls%156) (letrec ([loop%157 (lambda (ls%158) (if (null? (car ls%158)) b%155 (apply f%154 (cons (loop%157 (all-the-cdrs ls%158)) (all-the-cars ls%158)))))]) (loop%157 ls%156)) (error 'variadic-right-fold "mismatching lists")))))))
(define variadic-left-fold (lambda xs%159 (if (<= (length xs%159) 2) (error 'left-fold "missing list(s)") (let ([f%160 (car xs%159)] [b%161 (cadr xs%159)] [ls%162 (cddr xs%159)]) (if (null? (cdr ls%162)) (left-fold1 f%160 b%161 (car ls%162)) (if (all-same-length? ls%162) (letrec ([loop%163 (lambda (ls%164 b%165) (if (null? (car ls%164)) b%165 (loop%163 (all-the-cdrs ls%164) (apply f%160 (cons b%165 (all-the-cars ls%164))))))]) (loop%163 ls%162 b%161)) (error 'variadic-left-fold "mismatching lists")))))))
(define filter-in++ (lambda (p%166 alpha%167 l%168) (letrec ([loop%169 (lambda (l%170) (if (null? l%170) '() (if (p%166 (car l%170)) (cons (alpha%167 (car l%170)) (loop%169 (cdr l%170))) (loop%169 (cdr l%170)))))]) (loop%169 l%168))))
(define filter-in (lambda (p%171 l%172) (filter-in++ p%171 (lambda (x%173) x%173) l%172)))
(define filter-out++ (lambda (p%174 alpha%175 l%176) (filter-in++ (compose not p%174) alpha%175 l%176)))
(define filter-out (lambda (p%177 l%178) (filter-out++ p%177 (lambda (x%179) x%179) l%178)))
(define 1+ (lambda (n%180) (+ n%180 1)))
(define add1 1+)
(define 1- (lambda (n%181) (- n%181 1)))
(define sub1 1-)
(define negative? (lambda (n%182) (< n%182 0)))
(define zero? (lambda (n%183) (= n%183 0)))
(define positive? (lambda (n%184) (> n%184 0)))
(define even? (lambda (n%185) (= (remainder n%185 2) 0)))
(define odd? (lambda (n%186) (not (= (remainder n%186 2) 0))))
(define modulo (lambda (i%187 j%188) (let ([r%189 (remainder i%187 j%188)]) (if (negative? i%187) (if (negative? j%188) r%189 (+ r%189 j%188)) (if (negative? j%188) (+ r%189 j%188) r%189)))))
(define abs (lambda (n%190) (if (< n%190 0) (- 0 n%190) n%190)))
(define min (lambda (i%191 j%192) (if (< i%191 j%192) i%191 j%192)))
(define max (lambda (i%193 j%194) (if (< i%193 j%194) j%194 i%193)))
(define char=? (lambda (c1%195 c2%196) (= (char->integer c1%195) (char->integer c2%196))))
(define char:tab (integer->char 9))
(define char:newline (integer->char 10))
(define char:space (integer->char 32))
(define char:whitespace? (lambda (c%197) (if (char? c%197) (let ([i%198 (char->integer c%197)]) (if (= i%198 32) #t (if (= i%198 10) #t (= i%198 9)))) (error 'char:whitespace? "not a char: ~s" c%197))))
(define char:separator? (lambda (c%199) (if (char:whitespace? c%199) #t (if (if (eqv? c%199 #\() #t (if (eqv? c%199 #\)) #t (if (eqv? c%199 #\[) #t (if (eqv? c%199 #\]) #t (if (eqv? c%199 #\') #t (if (eqv? c%199 #\`) #t (if (eqv? c%199 #\,) #t (eqv? c%199 #\;)))))))) #t #f))))
(define string<? (lambda (s1%200 s2%201) (let ([l1%202 (string-length s1%200)] [l2%203 (string-length s2%201)]) (letrec ([loop%204 (lambda (i1%205 i2%206) (if (= i2%206 l2%203) #f (if (= i1%205 l1%202) #t (let ([j1%207 (char->integer (string-ref s1%200 i1%205))] [j2%208 (char->integer (string-ref s2%201 i2%206))]) (if (< j1%207 j2%208) #t (if (> j1%207 j2%208) #f (loop%204 (+ i1%205 1) (+ i2%206 1))))))))]) (loop%204 0 0)))))
(define substring (lambda (s%209 i%210 j%211) (letrec ([walk%212 (lambda (i%213) (if (>= i%213 j%211) '() (cons (string-ref s%209 i%213) (walk%212 (+ i%213 1)))))]) (if (if (<= 0 i%210) (if (<= i%210 j%211) (<= j%211 (string-length s%209)) #f) #f) (apply string (walk%212 i%210)) (error 'substring "~s and ~s are not valid start/end indices for ~s" i%210 j%211 s%209)))))
(define string-suffix? (lambda (text%214 suffix%215) (if (not (string? text%214)) (error 'string-suffix? "not a string: ~s" text%214) (if (not (string? suffix%215)) (error 'string-suffix? "not a string: ~s" suffix%215) (let ([text-len%216 (string-length text%214)] [suffix-len%217 (string-length suffix%215)]) (if (>= text-len%216 suffix-len%217) (string=? (substring text%214 (- text-len%216 suffix-len%217) text-len%216) suffix%215) #f))))))
(define string->list (lambda (s%218) (if (string? s%218) (let ([len%219 (string-length s%218)]) (letrec ([walk%220 (lambda (i%221) (if (= i%221 len%219) '() (let ([c%222 (string-ref s%218 i%221)]) (if (char=? c%222 #\\) (cons c%222 (cons c%222 (walk%220 (+ i%221 1)))) (cons c%222 (walk%220 (+ i%221 1)))))))]) (walk%220 0))) (error 'string->list "not a string: ~s" s%218))))
(define string->list-of-chars (lambda (s%223) (cons #\" (append (string->list s%223) (cons #\" '())))))
(define integer->list-of-chars (lambda (n%224) (letrec ([loop%225 (lambda (n%226 a%227) (let ([a%228 (cons (string-ref "0123456789" (remainder n%226 10)) a%227)]) (if (< n%226 10) a%228 (loop%225 (quotient n%226 10) a%228))))]) (if (negative? n%224) (cons #\- (loop%225 (- 0 n%224) '())) (loop%225 n%224 '())))))
(define list-of-values->list-of-chars (lambda (vs%229) (letrec ([walk%230 (lambda (a%231 d%232) (append (value->list-of-chars a%231) (if (null? d%232) (cons #\) '()) (cons char:space (if (pair? d%232) (walk%230 (car d%232) (cdr d%232)) (cons #\. (cons char:space (append (value->list-of-chars d%232) (cons #\) '())))))))))]) (if (null? vs%229) (list #\( #\)) (if (pair? vs%229) (cons #\( (walk%230 (car vs%229) (cdr vs%229))) (error 'list-of-values->list-of-chars "not a list: ~s" vs%229))))))
(define vector->list-of-chars (lambda (v%233) (let ([len%234 (vector-length v%233)]) (cons #\# (append (integer->list-of-chars len%234) (cons #\( (letrec ([walk%235 (lambda (i%236) (if (= i%236 len%234) (cons #\) '()) (cons char:space (append (value->list-of-chars (vector-ref v%233 i%236)) (walk%235 (+ i%236 1))))))]) (if (= len%234 0) (cons #\) '()) (append (value->list-of-chars (vector-ref v%233 0)) (walk%235 1))))))))))
(define value->list-of-chars (lambda (v%237) (if (list? v%237) (list-of-values->list-of-chars v%237) (if (boolean? v%237) (if v%237 (string->list "#t") (string->list "#f")) (if (integer? v%237) (integer->list-of-chars v%237) (if (char? v%237) (cons v%237 '()) (if (string? v%237) (string->list-of-chars v%237) (if (symbol? v%237) (string->list (symbol->string v%237)) (if (procedure? v%237) (string->list "#<procedure>") (if (vector? v%237) (vector->list-of-chars v%237) (if (input-port? v%237) (string->list "#<input-port>") (if (output-port? v%237) (string->list "#<output-port>") (if (eof-object? v%237) (string->list "#<eof-object>") (error 'value->list-of-chars "unrecognized value: ~s" v%237))))))))))))))
(define value->string (lambda (v%238) (apply string (value->list-of-chars v%238))))
(define format (lambda args%239 (if (null? args%239) "" (let ([directive%240 (car args%239)] [rest%241 (cdr args%239)]) (if (string? directive%240) (let ([end%242 (string-length directive%240)]) (letrec ([walk%243 (lambda (index%246 rest%247) (letrec ([walk-char%248 (lambda (index%251) (if (= index%251 end%242) '() (let ([c%252 (string-ref directive%240 index%251)]) (if (eqv? c%252 #\~) (walk-control%249 (+ index%251 1)) (if (eqv? c%252 #\\) (walk-quote%250 (+ index%251 1)) (cons c%252 (walk-char%248 (+ index%251 1))))))))] [walk-control%249 (lambda (index%253) (if (= index%253 end%242) (error 'format "incomplete directive: ~s" directive%240) (let ([c%254 (string-ref directive%240 index%253)]) (if (eqv? c%254 #\s) (if (null? rest%247) (error 'format "too few arguments for ~s" directive%240) (append (value->list-of-chars (car rest%247)) (walk%243 (+ index%253 1) (cdr rest%247)))) (error 'format "illegal control character: ~s" c%254)))))] [walk-quote%250 (lambda (index%255) (if (= index%255 end%242) (error 'format "incomplete directive: ~s" directive%240) (cons (string-ref directive%240 index%255) (walk-char%248 (+ index%255 1)))))]) (if (null? rest%247) (complete%244 index%246) (walk-char%248 index%246))))] [complete%244 (lambda (index%256) (if (= index%256 end%242) '() (let ([c%257 (string-ref directive%240 index%256)]) (if (eqv? c%257 #\~) (error 'format "too many arguments for ~s" directive%240) (if (eqv? c%257 #\\) (complete-quote%245 (+ index%256 1)) (cons c%257 (complete%244 (+ index%256 1))))))))] [complete-quote%245 (lambda (index%258) (if (= index%258 end%242) (error 'format "incomplete directive: ~s" directive%240) (cons (string-ref directive%240 index%258) (complete%244 (+ index%258 1)))))]) (apply string (walk%243 0 rest%241)))) (error 'format "not a string: ~s" directive%240))))))
(define vector->list (lambda (v%259) (let ([len%260 (vector-length v%259)]) (letrec ([loop%261 (lambda (i%262) (if (= i%262 len%260) '() (cons (vector-ref v%259 i%262) (loop%261 (+ i%262 1)))))]) (loop%261 0)))))
(define list->vector (lambda (l%263) (let* ([len%264 (length l%263)] [v%265 (make-vector len%264 '())]) (letrec ([loop%266 (lambda (i%267 l%268) (if (= i%267 len%264) v%265 (begin (vector-set! v%265 i%267 (car l%268)) (loop%266 (+ i%267 1) (cdr l%268)))))]) (loop%266 0 l%263)))))
(define integer->string (lambda (n%269) (apply string (integer->list-of-chars n%269))))
(define digit? (let ([zero%270 (char->integer #\0)] [nine%271 (char->integer #\9)]) (lambda (c%272) (if (char? c%272) (let ([i%273 (char->integer c%272)]) (if (<= zero%270 i%273) (<= i%273 nine%271) #f)) #f))))
(define digit->integer (let ([zero%274 (char->integer #\0)]) (lambda (d%275) (if (digit? d%275) (- (char->integer d%275) zero%274) (error 'digit->integer "not a digit: ~s" d%275)))))
(define integer->digit (let ([zero%276 (char->integer #\0)]) (lambda (i%277) (if (if (<= 0 i%277) (<= i%277 9) #f) (integer->char (+ i%277 zero%276)) (error 'integer->digit "non-digitable integer: ~s" i%277)))))
(define string->integer (lambda (s%278) (if (string? s%278) (let ([len%279 (string-length s%278)]) (if (let ([or%280 (= len%279 0)]) (if or%280 or%280 (if (char=? (string-ref s%278 0) #\-) (= len%279 1) #f))) (error 'string->integer "invalid string: ~s" s%278) (letrec ([loop%281 (lambda (offset%282 a%283) (if (= offset%282 len%279) a%283 (loop%281 (+ offset%282 1) (+ (digit->integer (string-ref s%278 offset%282)) (* 10 a%283)))))]) (if (char=? (string-ref s%278 0) #\-) (- 0 (loop%281 1 0)) (loop%281 0 0))))) (error 'string->integer "not a string: ~s" s%278))))
(define call-with-input-file (lambda (filename%284 procedure%285) (let* ([port%286 (open-input-file filename%284)] [result%287 (procedure%285 port%286)]) (begin (close-input-port port%286) result%287))))
(define call-with-output-file (lambda (filename%288 procedure%289) (let* ([port%290 (open-output-file filename%288)] [result%291 (procedure%289 port%290)]) (begin (close-output-port port%290) result%291))))
(define newline (lambda xs%292 (if (null? xs%292) (write-char #\newline (current-output-port)) (if (null? (cdr xs%292)) (let ([port%293 (car xs%292)]) (if (output-port? port%293) (write-char #\newline port%293) (error 'newline "not a port: ~s" port%293))) (error 'newline "Too many arguments: ~s" xs%292)))))
(define reader:read-char (lambda (port%294 continue-with-char%295 continue-with-eof-object%296) (let ([c%297 (read-char port%294)]) (if (eof-object? c%297) (continue-with-eof-object%296 c%297) (continue-with-char%295 c%297)))))
(define reader:peek-char (lambda (port%298 continue-with-char%299 continue-with-eof-object%300) (let ([c%301 (peek-char port%298)]) (if (eof-object? c%301) (continue-with-eof-object%300 c%301) (continue-with-char%299 c%301)))))
(define reader:skip-to-end-of-line (lambda (port%302 continue%303 continue-with-eof-object%304) (letrec ([loop%305 (lambda () (reader:read-char port%302 (lambda (c%306) (if (char=? c%306 char:newline) (continue%303) (loop%305))) continue-with-eof-object%304))]) (loop%305))))
(define reader:skip-whitespace-peek (lambda (port%307 continue-with-char%308 continue-with-eof-object%309) (letrec ([loop%310 (lambda () (reader:peek-char port%307 (lambda (c%311) (if (char:whitespace? c%311) (begin (read-char port%307) (loop%310)) (if (char=? c%311 #\;) (reader:skip-to-end-of-line port%307 loop%310 continue-with-eof-object%309) (continue-with-char%308 c%311)))) continue-with-eof-object%309))]) (loop%310))))
(define reader:skip-whitespace (lambda (port%312 continue-with-char%313 continue-with-eof-object%314) (reader:skip-whitespace-peek port%312 (lambda (c%315) (begin (read-char port%312) (continue-with-char%313 c%315))) continue-with-eof-object%314)))
(define reader:read-num (lambda (total%316 port%317 continue-with-token%318) (reader:peek-char port%317 (lambda (c%319) (if (digit? c%319) (begin (read-char port%317) (reader:read-num (+ (* 10 total%316) (digit->integer c%319)) port%317 continue-with-token%318)) (if (char:separator? c%319) (continue-with-token%318 total%316) (reader:read-identifier (read-char port%317) port%317 (lambda (ident%320) (continue-with-token%318 (string->symbol (string-append (integer->string total%316) (symbol->string ident%320))))))))) (lambda (eof-object%321) (continue-with-token%318 total%316)))))
(define reader:read-identifier (lambda (c%322 port%323 continue-with-token%324) (letrec ([loop%325 (lambda (cs%326) (reader:peek-char port%323 (lambda (c%327) (if (char:separator? c%327) (continue-with-token%324 (string->symbol (apply string (reverse cs%326)))) (begin (read-char port%323) (loop%325 (cons c%327 cs%326))))) (lambda (eof-object%328) (continue-with-token%324 (string->symbol (apply string (reverse cs%326)))))))]) (loop%325 (cons c%322 '())))))
(define reader:read-character (lambda (port%329 continue-with-token%330) (reader:read-char port%329 (lambda (c%331) (if (eqv? c%331 #\n) (let ([c%332 (peek-char port%329)]) (if (char:separator? c%332) (continue-with-token%330 #\n) (if (char=? c%332 #\e) (begin (read-char port%329) (reader:read-char port%329 (lambda (c%333) (if (char=? c%333 #\w) (reader:read-char port%329 (lambda (c%334) (if (char=? c%334 #\l) (reader:read-char port%329 (lambda (c%335) (if (char=? c%335 #\i) (reader:read-char port%329 (lambda (c%336) (if (char=? c%336 #\n) (reader:read-char port%329 (lambda (c%337) (if (char=? c%337 #\e) (reader:read-char port%329 (lambda (c%338) (if (char:separator? c%338) (continue-with-token%330 char:newline) (error 'read "Invalid character name #\\newline~s" c%338))) (lambda (eof-object%339) (continue-with-token%330 char:newline))) (error 'read "Invalid character name #\\newlin~s" c%337))) (lambda (eof-object%340) (error 'read "Invalid character name #\\newlin"))) (error 'read "Invalid character name #\\newli~s" c%336))) (lambda (eof-object%341) (error 'read "Invalid character name #\\newli"))) (error 'read "Invalid character name #\\newl~s" c%335))) (lambda (eof-object%342) (error 'read "Invalid character name #\\newl"))) (error 'read "Invalid character name #\\new~s" c%334))) (lambda (eof-object%343) (error 'read "Invalid character name #\\new"))) (error 'read "Invalid character name #\\ne~s" c%333))) (lambda (eof-object%344) (error 'read "Invalid character name #\\ne")))) (error 'read "Invalid character name #\\n~s" c%332)))) (if (eqv? c%331 #\s) (let ([c%345 (peek-char port%329)]) (if (char:separator? c%345) (continue-with-token%330 #\s) (if (char=? c%345 #\p) (begin (read-char port%329) (reader:read-char port%329 (lambda (c%346) (if (char=? c%346 #\a) (reader:read-char port%329 (lambda (c%347) (if (char=? c%347 #\c) (reader:read-char port%329 (lambda (c%348) (if (char=? c%348 #\e) (reader:read-char port%329 (lambda (c%349) (if (char:separator? c%349) (continue-with-token%330 char:space) (error 'read "Invalid character name #\\space~s" c%349))) (lambda (eof-object%350) (continue-with-token%330 char:space))) (error 'read "Invalid character name #\\spa~s" c%348))) (lambda (eof-object%351) (error 'read "Invalid character name #\\spa"))) (error 'read "Invalid character name #\\spa~s" c%347))) (lambda (eof-object%352) (error 'read "Invalid character name #\\spa"))) (error 'read "Invalid character name #\\sp~s" c%346))) (lambda (eof-object%353) (error 'read "Invalid character name #\\sp")))) (error 'read "Invalid character name #\\s~s" c%345)))) (if (eqv? c%331 #\t) (let ([c%354 (peek-char port%329)]) (if (char:separator? c%354) (continue-with-token%330 #\t) (if (char=? c%354 #\a) (begin (read-char port%329) (reader:read-char port%329 (lambda (c%355) (if (char=? c%355 #\b) (reader:peek-char port%329 (lambda (c%356) (if (char:separator? c%356) (continue-with-token%330 char:tab) (error 'read "Invalid character name #\\tab~s" c%356))) (lambda (eof-object%357) (continue-with-token%330 char:tab))) (error 'read "Invalid character name #\\ta~s" c%355))) (lambda (eof-object%358) (error 'read "Invalid character name #\\ta")))) (error 'read "Invalid character name #\\t~s" c%354)))) (reader:peek-char port%329 (lambda (c2%359) (if (char:separator? c2%359) (continue-with-token%330 c%331) (error 'read "Invalid character name #\\~s~s" c%331 c2%359))) (lambda (eof-object%360) (continue-with-token%330 c%331))))))) (lambda (eof-object%361) (error 'read "end of input stream")))))
(define reader:read-string (lambda (port%362 continue-with-token%363) (letrec ([loop%364 (lambda (cs%365) (reader:read-char port%362 (lambda (c%366) (if (eqv? c%366 #\") (continue-with-token%363 (apply string (reverse cs%365))) (if (eqv? c%366 #\\) (reader:read-char port%362 (lambda (c%367) (loop%364 (cons c%367 cs%365))) (lambda (eof-object%368) (error 'read "end of input stream"))) (loop%364 (cons c%366 cs%365))))) (lambda (eof-object%369) (error 'read "end of input stream"))))]) (loop%364 '()))))
(define reader:read (lambda (port%370 continue-with-token%371 continue-with-eof-object%372) (letrec ([read-round-parens%373 (lambda (continue-with-token%375) (reader:skip-whitespace-peek port%370 (lambda (c%376) (if (eqv? c%376 #\)) (begin (read-char port%370) (continue-with-token%375 '())) (reader:read port%370 (lambda (token%377) (read-round-parens%373 (lambda (tokens%378) (continue-with-token%375 (cons token%377 tokens%378))))) (lambda (eof-object%379) (error 'read "end of input stream"))))) (lambda (eof-object%380) (error 'read "end of input stream"))))] [read-square-parens%374 (lambda (continue-with-token%381) (reader:skip-whitespace-peek port%370 (lambda (c%382) (if (eqv? c%382 #\]) (begin (read-char port%370) (continue-with-token%381 '())) (reader:read port%370 (lambda (token%383) (read-square-parens%374 (lambda (tokens%384) (continue-with-token%381 (cons token%383 tokens%384))))) (lambda (eof-object%385) (error 'read "end of input stream"))))) (lambda (eof-object%386) (error 'read "end of input stream"))))]) (reader:skip-whitespace port%370 (lambda (c%387) (if (eqv? c%387 #\() (read-round-parens%373 continue-with-token%371) (if (eqv? c%387 #\[) (read-square-parens%374 continue-with-token%371) (if (if (eqv? c%387 #\)) #t (eqv? c%387 #\])) (error 'read "unexpected ~s" c%387) (if (eqv? c%387 #\') (reader:read port%370 (lambda (token%388) (continue-with-token%371 (list 'quote token%388))) (lambda (eof-object%389) (error 'read "end of input stream"))) (if (eqv? c%387 #\`) (reader:read port%370 (lambda (token%390) (continue-with-token%371 (list 'quasiquote token%390))) (lambda (eof-object%391) (error 'read "end of input stream"))) (if (eqv? c%387 #\,) (if (char=? (peek-char port%370) #\@) (begin (read-char port%370) (reader:read port%370 (lambda (token%392) (continue-with-token%371 (list 'unquote-splicing token%392))) (lambda (eof-object%393) (error 'read "end of input stream")))) (reader:read port%370 (lambda (token%394) (continue-with-token%371 (list 'unquote token%394))) (lambda (eof-object%395) (error 'read "end of input stream")))) (if (eqv? c%387 #\#) (reader:read-char port%370 (lambda (c%396) (if (if (eqv? c%396 #\t) #t (eqv? c%396 #\T)) (reader:peek-char port%370 (lambda (c%397) (if (char:separator? c%397) (continue-with-token%371 #t) (error 'read "unknown #t~s sequence" c%397))) (lambda (eof-object%398) (continue-with-token%371 #t))) (if (if (eqv? c%396 #\f) #t (eqv? c%396 #\F)) (reader:peek-char port%370 (lambda (c%399) (if (char:separator? c%399) (continue-with-token%371 #f) (error 'read "unknown #f~s sequence" c%399))) (lambda (eof-object%400) (continue-with-token%371 #f))) (if (eqv? c%396 #\\) (reader:read-character port%370 continue-with-token%371) (error 'read "unknown # code: ~s" c%396))))) (lambda (eof-object%401) (error 'read "end of input stream"))) (if (eqv? c%387 #\") (reader:read-string port%370 continue-with-token%371) (if (eqv? c%387 #\-) (reader:peek-char port%370 (lambda (c%402) (if (digit? c%402) (reader:read-num (digit->integer (read-char port%370)) port%370 (lambda (token%403) (if (integer? token%403) (continue-with-token%371 (- 0 token%403)) (string->symbol (string-append "-" (symbol->string token%403)))))) (reader:read-identifier #\- port%370 continue-with-token%371))) (lambda (eof-object%404) (continue-with-token%371 '-))) (if (eqv? c%387 #\+) (reader:peek-char port%370 (lambda (c%405) (if (digit? c%405) (reader:read-num (digit->integer (read-char port%370)) port%370 continue-with-token%371) (reader:read-identifier #\+ port%370 continue-with-token%371))) (lambda (eof-object%406) (continue-with-token%371 '+))) (if (digit? c%387) (reader:read-num (digit->integer c%387) port%370 continue-with-token%371) (reader:read-identifier c%387 port%370 continue-with-token%371))))))))))))) continue-with-eof-object%372))))
(define read (lambda <port>%407 (let ([<port>%408 (if (null? <port>%407) (current-input-port) (car <port>%407))]) (call/cc (lambda (k%409) (reader:read <port>%408 (lambda (token%410) token%410) k%409))))))
(define write-to-port (lambda (value%411 port%412) (for-each (lambda (c%413) (write-char c%413 port%412)) (value->list-of-chars value%411))))
(define write (lambda args%414 (let ([case%415 (length args%414)]) (if (eqv? case%415 1) (write-to-port (car args%414) (current-output-port)) (if (eqv? case%415 2) (write-to-port (car args%414) (cadr args%414)) (error 'write "wrong arity: ~s" args%414))))))
(define display-to-port (lambda (value%416 port%417) (for-each (lambda (c%418) (if (char=? c%418 #\") '() (write-char c%418 port%417))) (value->list-of-chars value%416))))
(define display (lambda args%419 (let ([case%420 (length args%419)]) (if (eqv? case%420 1) (display-to-port (car args%419) (current-output-port)) (if (eqv? case%420 2) (display-to-port (car args%419) (cadr args%419)) (error 'display "wrong arity: ~s" args%419))))))
(define extract-directory-name (lambda (filename%421) (if (string? filename%421) (let ([len%422 (string-length filename%421)]) (letrec ([walk%423 (lambda (offset%424) (if (negative? offset%424) "" (if (char=? (string-ref filename%421 offset%424) #\/) (substring filename%421 0 (+ offset%424 1)) (walk%423 (- offset%424 1)))))]) (walk%423 (- len%422 1)))) (error 'extract-directory-name "not a file name: ~s" filename%421))))
(define error (lambda msg%425 (begin (set! error (lambda msg%426 (begin (newline (current-output-port)) (display "DAIMI-Scheme: error in error." (current-output-port)) (newline (current-output-port)) (exit 3)))) (newline (current-output-port)) (display "DAIMI-Scheme error -- " (current-output-port)) (if (null? msg%425) (begin (newline (current-output-port)) (exit 1)) (let* ([name%427 (car msg%425)] [printable-name%428 (if (symbol? name%427) (symbol->string name%427) name%427)]) (begin (display printable-name%428 (current-output-port)) (display " -- " (current-output-port)) (display (apply format (cdr msg%425)) (current-output-port)) (newline (current-output-port)) (exit 2)))))))
(define merge (lambda (p%429 xs%430 ys%431) (if (null? xs%430) ys%431 (if (null? ys%431) xs%430 (if (p%429 (car xs%430) (car ys%431)) (cons (car xs%430) (merge p%429 (cdr xs%430) ys%431)) (cons (car ys%431) (merge p%429 xs%430 (cdr ys%431))))))))
(define sort (lambda (p%432 xs%433) (if (let ([or%434 (null? xs%433)]) (if or%434 or%434 (null? (cdr xs%433)))) xs%433 (let* ([x1%435 (car xs%433)] [q%436 (lambda (x%437) (p%432 x1%435 x%437))]) (merge p%432 (list x1%435) (merge p%432 (sort p%432 (filter-in q%436 (cdr xs%433))) (sort p%432 (filter-out q%436 (cdr xs%433)))))))))
(define call-with-current-continuation call/cc)
(define throw (lambda (continuation%438 value%439) (continuation%438 value%439)))
(define force (lambda (thunk%440) (thunk%440)))
(define associate (lambda (p%441) (lambda (key%442 a-list%443) (letrec ([loop%444 (lambda (a-list%445) (if (null? a-list%445) #f (let ([pair%446 (car a-list%445)]) (if (p%441 key%442 (car pair%446)) pair%446 (loop%444 (cdr a-list%445))))))]) (loop%444 a-list%443)))))
(define assq (associate eqv?))
(define assoc (associate equal?))
(define the-tag "DAIMI-Scheme compiler, 03-10-12")
(define immutable%447 (cons 'integer? (cons '+ (cons '- (cons '* (cons 'quotient (cons 'remainder (cons '< (cons '<= (cons '= (cons '>= (cons '> (cons 'boolean? (cons 'symbol? (cons 'char? (cons 'char->integer (cons 'integer->char (cons 'string (cons 'make-string (cons 'string? (cons 'string-length (cons 'string-append (cons 'string=? (cons 'string-ref (cons 'string->symbol (cons 'symbol->string (cons 'pair? (cons 'cons (cons 'car (cons 'cdr (cons 'set-car! (cons 'set-cdr! (cons 'null? (cons 'vector (cons 'make-vector (cons 'vector? (cons 'vector-length (cons 'vector-ref (cons 'vector-set! (cons 'procedure? (cons 'apply (cons 'eqv? (cons 'call/cc (cons 'exit (cons 'open-input-file (cons 'input-port? (cons 'close-input-port (cons 'current-input-port (cons 'read-char (cons 'peek-char (cons 'eof-object? (cons 'open-output-file (cons 'output-port? (cons 'close-output-port (cons 'current-output-port (cons 'write-char '()))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define predefined-procedures immutable%447)
(define gensym-count -1)
(define reset-gensym! (lambda () (set! gensym-count -1)))
(define gensym! (lambda (str%448) (begin (set! gensym-count (+ gensym-count 1)) (string->symbol (string-append str%448 (integer->string gensym-count))))))
(define warn (lambda (msg%449) (if verbose (display msg%449 (current-output-port)) "Shhh!")))
(define warnl (lambda (msg%450) (if verbose (begin (display msg%450 (current-output-port)) (newline (current-output-port))) "Shhh!")))
(define make-Parsed-Program (lambda (the-definitions_ the-expression_) (vector 'Parsed-Program the-definitions_ the-expression_)))
(define is-Parsed-Program? (lambda (record%451) (if (vector? record%451) (if (= (vector-length record%451) 3) (eqv? (vector-ref record%451 0) 'Parsed-Program) #f) #f)))
(define make-DefRec (lambda (name_ fields_) (vector 'DefRec name_ fields_)))
(define is-DefRec? (lambda (record%452) (if (vector? record%452) (if (= (vector-length record%452) 3) (eqv? (vector-ref record%452 0) 'DefRec) #f) #f)))
(define make-DefExp (lambda (name_ expression_) (vector 'DefExp name_ expression_)))
(define is-DefExp? (lambda (record%453) (if (vector? record%453) (if (= (vector-length record%453) 3) (eqv? (vector-ref record%453 0) 'DefExp) #f) #f)))
(define make-Literal (lambda (literal_) (vector 'Literal literal_)))
(define is-Literal? (lambda (record%454) (if (vector? record%454) (if (= (vector-length record%454) 2) (eqv? (vector-ref record%454 0) 'Literal) #f) #f)))
(define make-Variable (lambda (variable_) (vector 'Variable variable_)))
(define is-Variable? (lambda (record%455) (if (vector? record%455) (if (= (vector-length record%455) 2) (eqv? (vector-ref record%455 0) 'Variable) #f) #f)))
(define make-Abstraction (lambda (formals_ body_) (vector 'Abstraction formals_ body_)))
(define is-Abstraction? (lambda (record%456) (if (vector? record%456) (if (= (vector-length record%456) 3) (eqv? (vector-ref record%456 0) 'Abstraction) #f) #f)))
(define make-IfThenElse (lambda (test-exp_ then-exp_ else-exp_) (vector 'IfThenElse test-exp_ then-exp_ else-exp_)))
(define is-IfThenElse? (lambda (record%457) (if (vector? record%457) (if (= (vector-length record%457) 4) (eqv? (vector-ref record%457 0) 'IfThenElse) #f) #f)))
(define make-Assign (lambda (variable_ expression_) (vector 'Assign variable_ expression_)))
(define is-Assign? (lambda (record%458) (if (vector? record%458) (if (= (vector-length record%458) 3) (eqv? (vector-ref record%458 0) 'Assign) #f) #f)))
(define make-Application (lambda (procedure_ arguments_) (vector 'Application procedure_ arguments_)))
(define is-Application? (lambda (record%459) (if (vector? record%459) (if (= (vector-length record%459) 3) (eqv? (vector-ref record%459 0) 'Application) #f) #f)))
(define make-CondExpr (lambda (tests_ consequents_) (vector 'CondExpr tests_ consequents_)))
(define is-CondExpr? (lambda (record%460) (if (vector? record%460) (if (= (vector-length record%460) 3) (eqv? (vector-ref record%460 0) 'CondExpr) #f) #f)))
(define make-CaseExpr (lambda (test_ headers_ expressions_) (vector 'CaseExpr test_ headers_ expressions_)))
(define is-CaseExpr? (lambda (record%461) (if (vector? record%461) (if (= (vector-length record%461) 4) (eqv? (vector-ref record%461 0) 'CaseExpr) #f) #f)))
(define make-CaseRecordExpr (lambda (test_ headers_ expressions_) (vector 'CaseRecordExpr test_ headers_ expressions_)))
(define is-CaseRecordExpr? (lambda (record%462) (if (vector? record%462) (if (= (vector-length record%462) 4) (eqv? (vector-ref record%462 0) 'CaseRecordExpr) #f) #f)))
(define make-ConjExpr (lambda (expressions_) (vector 'ConjExpr expressions_)))
(define is-ConjExpr? (lambda (record%463) (if (vector? record%463) (if (= (vector-length record%463) 2) (eqv? (vector-ref record%463 0) 'ConjExpr) #f) #f)))
(define make-DisjExpr (lambda (expressions_) (vector 'DisjExpr expressions_)))
(define is-DisjExpr? (lambda (record%464) (if (vector? record%464) (if (= (vector-length record%464) 2) (eqv? (vector-ref record%464 0) 'DisjExpr) #f) #f)))
(define make-LetExpr (lambda (formals_ expressions_ body_) (vector 'LetExpr formals_ expressions_ body_)))
(define is-LetExpr? (lambda (record%465) (if (vector? record%465) (if (= (vector-length record%465) 4) (eqv? (vector-ref record%465 0) 'LetExpr) #f) #f)))
(define make-SLetExpr (lambda (formals_ expressions_ body_) (vector 'SLetExpr formals_ expressions_ body_)))
(define is-SLetExpr? (lambda (record%466) (if (vector? record%466) (if (= (vector-length record%466) 4) (eqv? (vector-ref record%466 0) 'SLetExpr) #f) #f)))
(define make-LetRecExpr (lambda (formals_ lambdas_ expression_) (vector 'LetRecExpr formals_ lambdas_ expression_)))
(define is-LetRecExpr? (lambda (record%467) (if (vector? record%467) (if (= (vector-length record%467) 4) (eqv? (vector-ref record%467 0) 'LetRecExpr) #f) #f)))
(define make-SequenceExpr (lambda (expressions_) (vector 'SequenceExpr expressions_)))
(define is-SequenceExpr? (lambda (record%468) (if (vector? record%468) (if (= (vector-length record%468) 2) (eqv? (vector-ref record%468 0) 'SequenceExpr) #f) #f)))
(define make-Suspend (lambda (expression_) (vector 'Suspend expression_)))
(define is-Suspend? (lambda (record%469) (if (vector? record%469) (if (= (vector-length record%469) 2) (eqv? (vector-ref record%469 0) 'Suspend) #f) #f)))
(define make-Delay (lambda (expression_) (vector 'Delay expression_)))
(define is-Delay? (lambda (record%470) (if (vector? record%470) (if (= (vector-length record%470) 2) (eqv? (vector-ref record%470 0) 'Delay) #f) #f)))
(define make-Quotation (lambda (expression_) (vector 'Quotation expression_)))
(define is-Quotation? (lambda (record%471) (if (vector? record%471) (if (= (vector-length record%471) 2) (eqv? (vector-ref record%471 0) 'Quotation) #f) #f)))
(define make-Integer (lambda (i_) (vector 'Integer i_)))
(define is-Integer? (lambda (record%472) (if (vector? record%472) (if (= (vector-length record%472) 2) (eqv? (vector-ref record%472 0) 'Integer) #f) #f)))
(define make-Boolean (lambda (b_) (vector 'Boolean b_)))
(define is-Boolean? (lambda (record%473) (if (vector? record%473) (if (= (vector-length record%473) 2) (eqv? (vector-ref record%473 0) 'Boolean) #f) #f)))
(define make-String (lambda (s_) (vector 'String s_)))
(define is-String? (lambda (record%474) (if (vector? record%474) (if (= (vector-length record%474) 2) (eqv? (vector-ref record%474 0) 'String) #f) #f)))
(define make-Character (lambda (s_) (vector 'Character s_)))
(define is-Character? (lambda (record%475) (if (vector? record%475) (if (= (vector-length record%475) 2) (eqv? (vector-ref record%475 0) 'Character) #f) #f)))
(define make-Symbol (lambda (s_) (vector 'Symbol s_)))
(define is-Symbol? (lambda (record%476) (if (vector? record%476) (if (= (vector-length record%476) 2) (eqv? (vector-ref record%476 0) 'Symbol) #f) #f)))
(define make-Nil (lambda () (vector 'Nil)))
(define is-Nil? (lambda (record%477) (if (vector? record%477) (if (= (vector-length record%477) 1) (eqv? (vector-ref record%477 0) 'Nil) #f) #f)))
(define make-Void (lambda () (vector 'Void)))
(define is-Void? (lambda (record%478) (if (vector? record%478) (if (= (vector-length record%478) 1) (eqv? (vector-ref record%478 0) 'Void) #f) #f)))
(define immutable%480 (cons 'define (cons 'lambda (cons 'if (cons 'set! (cons 'let (cons 'let* (cons 'letrec (cons 'cond (cons 'case (cons 'else (cons 'and (cons 'or (cons 'begin (cons 'delay (cons 'suspend (cons 'define-record (cons 'case-record (cons 'quote '())))))))))))))))))))
(define variable? (lambda (e%479) (if (symbol? e%479) (not (member e%479 immutable%480)) #f)))
(define all-different? (lambda (xs%481) (let ([or%482 (null? xs%481)]) (if or%482 or%482 (if (not (memq (car xs%481) (cdr xs%481))) (all-different? (cdr xs%481)) #f)))))
(define is-load? (lambda (exp%483) (if (pair? exp%483) (if (eqv? (car exp%483) 'load) (if (pair? (cdr exp%483)) (if (string? (cadr exp%483)) (null? (cddr exp%483)) #f) #f) #f) #f)))
(define is-load-relative? (lambda (exp%484) (if (pair? exp%484) (if (eqv? (car exp%484) 'load-relative) (if (pair? (cdr exp%484)) (if (string? (cadr exp%484)) (null? (cddr exp%484)) #f) #f) #f) #f)))
(define proper-list++? (lambda (e%485 n%486) (letrec ([loop%487 (lambda (e%488 n%489) (if (zero? n%489) (null? e%488) (if (pair? e%488) (loop%487 (cdr e%488) (- n%489 1)) #f)))]) (loop%487 e%485 n%486))))
(define is-define-record? (lambda (d%490) (if (proper-list++? d%490 2) (if (equal? (car d%490) 'define-record) (if (andmap1 variable? (cadr d%490)) (all-different? (cadr d%490)) #f) #f) #f)))
(define is-definition? (lambda (d%491) (if (proper-list++? d%491 3) (if (equal? (car d%491) 'define) (variable? (cadr d%491)) #f) #f)))
(define quote-ok? (lambda (e%492) (proper-list++? e%492 2)))
(define lambda-ok? (lambda (e%493) (if (proper-list++? e%493 3) (if (equal? (car e%493) 'lambda) (let ([or%494 (variable? (cadr e%493))]) (if or%494 or%494 (if (andmap1 variable? (cadr e%493)) (all-different? (cadr e%493)) #f))) #f) #f)))
(define if-ok? (lambda (e%495) (proper-list++? e%495 4)))
(define cond-ok? (lambda (e%496) (if (proper-list? e%496) (if (andmap1 (lambda (clause%497) (proper-list++? clause%497 2)) (cdr e%496)) (equal? (caar (last-pair e%496)) 'else) #f) #f)))
(define case-ok? (lambda (e%498) (if (proper-list? e%498) (if (pair? (cdr e%498)) (if (pair? (cddr e%498)) (if (andmap1 (lambda (clause%499) (if (proper-list++? clause%499 2) (let ([or%504 (eqv? (car clause%499) 'else)]) (if or%504 or%504 (if (proper-list? (car clause%499)) (andmap1 (lambda (v%500) (let ([or%503 (symbol? v%500)]) (if or%503 or%503 (let ([or%502 (integer? v%500)]) (if or%502 or%502 (let ([or%501 (boolean? v%500)]) (if or%501 or%501 (char? v%500)))))))) (car clause%499)) #f))) #f)) (cddr e%498)) (equal? (caar (last-pair e%498)) 'else) #f) #f) #f) #f)))
(define case-record-ok? (lambda (e%505) (if (proper-list? e%505) (if (pair? (cdr e%505)) (if (pair? (cddr e%505)) (if (andmap1 (lambda (clause%506) (if (proper-list++? clause%506 2) (let ([or%507 (eqv? (car clause%506) 'else)]) (if or%507 or%507 (if (proper-list? (car clause%506)) (if (andmap1 variable? (car clause%506)) (all-different? (car clause%506)) #f) #f))) #f)) (cddr e%505)) (equal? (caar (last-pair e%505)) 'else) #f) #f) #f) #f)))
(define and-ok? (lambda (e%508) (proper-list? e%508)))
(define or-ok? and-ok?)
(define let-ok? (lambda (e%509) (if (proper-list++? e%509 3) (let ([clauses%510 (cadr e%509)]) (if (proper-list? clauses%510) (if (andmap1 (lambda (e%511) (proper-list++? e%511 2)) clauses%510) (let ([xs%512 (map car clauses%510)]) (if (andmap1 variable? xs%512) (all-different? xs%512) #f)) #f) #f)) #f)))
(define let*-ok? (lambda (e%513) (if (proper-list++? e%513 3) (let ([clauses%514 (cadr e%513)]) (if (proper-list? clauses%514) (if (andmap1 (lambda (e%515) (proper-list++? e%515 2)) clauses%514) (let ([xs%516 (map car clauses%514)]) (andmap1 variable? xs%516)) #f) #f)) #f)))
(define letrec-ok? (lambda (e%517) (if (proper-list++? e%517 3) (let ([clauses%518 (cadr e%517)]) (if (proper-list? clauses%518) (if (andmap1 (lambda (e%519) (proper-list++? e%519 2)) clauses%518) (if (andmap1 lambda-ok? (map cadr clauses%518)) (let ([xs%520 (map car clauses%518)]) (if (andmap1 variable? xs%520) (all-different? xs%520) #f)) #f) #f) #f)) #f)))
(define suspend-ok? (lambda (e%521) (proper-list++? e%521 2)))
(define delay-ok? (lambda (e%522) (proper-list++? e%522 2)))
(define begin-ok? (lambda (e%523) (if (pair? (cdr e%523)) (proper-list? e%523) #f)))
(define call-ok? (lambda (e%524) (if (pair? e%524) (proper-list? e%524) #f)))
(define set!-ok? (lambda (e%525) (if (proper-list++? e%525 3) (variable? (cadr e%525)) #f)))
(define parse-record (lambda (r%526) (let ([h%527 (cadr r%526)]) (make-DefRec (car h%527) (cdr h%527)))))
(define parse-quote (lambda (e%528) (make-Quotation e%528)))
(define parse-expression (lambda (e%529) (if (pair? e%529) (let ([case%530 (car e%529)]) (if (eqv? case%530 'quote) (if (quote-ok? e%529) (parse-quote (cadr e%529)) (error 'parse-expression "Illegal quote: ~s" e%529)) (if (eqv? case%530 'lambda) (if (lambda-ok? e%529) (make-Abstraction (cadr e%529) (parse-expression (caddr e%529))) (error 'parse-expression "Illegal lambda: ~s" e%529)) (if (eqv? case%530 'if) (if (if-ok? e%529) (make-IfThenElse (parse-expression (cadr e%529)) (parse-expression (caddr e%529)) (parse-expression (cadddr e%529))) (error 'parse-expression "Illegal if: ~s" e%529)) (if (eqv? case%530 'cond) (if (cond-ok? e%529) (make-CondExpr (letrec ([walk%531 (lambda (es%532) (let ([e%533 (car (car es%532))] [es%534 (cdr es%532)]) (if (null? es%534) (list e%533) (cons (parse-expression e%533) (walk%531 es%534)))))]) (walk%531 (cdr e%529))) (map (compose parse-expression cadr) (cdr e%529))) (error 'parse-expression "Illegal cond: ~s" e%529)) (if (eqv? case%530 'case) (if (case-ok? e%529) (make-CaseExpr (parse-expression (cadr e%529)) (map car (cddr e%529)) (map (compose parse-expression cadr) (cddr e%529))) (error 'parse-expression "Illegal case: ~s" e%529)) (if (eqv? case%530 'case-record) (if (case-record-ok? e%529) (make-CaseRecordExpr (parse-expression (cadr e%529)) (map car (cddr e%529)) (map (compose parse-expression cadr) (cddr e%529))) (error 'parse-expression "Illegal case-record: ~s" e%529)) (if (eqv? case%530 'and) (if (and-ok? e%529) (make-ConjExpr (map parse-expression (cdr e%529))) (error 'parse-expression "Illegal and: ~s" e%529)) (if (eqv? case%530 'or) (if (or-ok? e%529) (make-DisjExpr (map parse-expression (cdr e%529))) (error 'parse-expression "Illegal or: ~s" e%529)) (if (eqv? case%530 'let) (if (let-ok? e%529) (let ([clauses%535 (cadr e%529)]) (if (null? clauses%535) (parse-expression (caddr e%529)) (make-LetExpr (map car clauses%535) (map (compose parse-expression cadr) clauses%535) (parse-expression (caddr e%529))))) (error 'parse-expression "Illegal let: ~s" e%529)) (if (eqv? case%530 'let*) (if (let*-ok? e%529) (let ([clauses%536 (cadr e%529)]) (if (null? clauses%536) (parse-expression (caddr e%529)) (make-SLetExpr (map car clauses%536) (map (compose parse-expression cadr) clauses%536) (parse-expression (caddr e%529))))) (error 'parse-expression "Illegal let*: ~s" e%529)) (if (eqv? case%530 'letrec) (if (letrec-ok? e%529) (let ([clauses%537 (cadr e%529)]) (if (null? clauses%537) (parse-expression (caddr e%529)) (make-LetRecExpr (map car clauses%537) (map (compose parse-expression cadr) clauses%537) (parse-expression (caddr e%529))))) (error 'parse-expression "Illegal letrec: ~s" e%529)) (if (eqv? case%530 'begin) (if (begin-ok? e%529) (make-SequenceExpr (map parse-expression (cdr e%529))) (error 'parse-expression "Illegal begin: ~s" e%529)) (if (eqv? case%530 'suspend) (if (suspend-ok? e%529) (make-Suspend (parse-expression (cadr e%529))) (error 'parse-expression "Illegal suspend: ~s" e%529)) (if (eqv? case%530 'delay) (if (delay-ok? e%529) (make-Delay (parse-expression (cadr e%529))) (error 'parse-expression "Illegal delay: ~s" e%529)) (if (eqv? case%530 'set!) (if (set!-ok? e%529) (make-Assign (cadr e%529) (parse-expression (caddr e%529))) (error 'parse-expression "Illegal set!: ~s" e%529)) (if (call-ok? e%529) (make-Application (parse-expression (car e%529)) (map parse-expression (cdr e%529))) (error 'parse-expression "Illegal call: ~s" e%529)))))))))))))))))) (if (integer? e%529) (make-Literal (make-Integer e%529)) (if (boolean? e%529) (make-Literal (make-Boolean e%529)) (if (string? e%529) (make-Literal (make-String e%529)) (if (char? e%529) (make-Literal (make-Character e%529)) (if (variable? e%529) (make-Variable e%529) (error 'parse-expression "Unrecognized expression: ~s" e%529)))))))))
(define parse-definition (lambda (d%538) (make-DefExp (cadr d%538) (parse-expression (caddr d%538)))))
(define parse-program (lambda (p%539) (letrec ([traverse%540 (lambda (p%541 the-definitions%542) (if (null? (cdr p%541)) (make-Parsed-Program (reverse the-definitions%542) (parse-expression (car p%541))) (if (is-define-record? (car p%541)) (traverse%540 (cdr p%541) (cons (parse-record (car p%541)) the-definitions%542)) (if (is-definition? (car p%541)) (traverse%540 (cdr p%541) (cons (parse-definition (car p%541)) the-definitions%542)) (error 'parse-program "quasar: ~s" p%541)))))]) (begin (warn "Parsing") (let ([q%543 (traverse%540 p%539 '())]) (begin (warnl " / Parsed") q%543))))))
(define read-file (letrec ([read-the-file%544 (lambda (f%545 fs%546 d%547) (begin (warn (string-append "(" f%545)) (let ([q%548 (call-with-input-file f%545 (lambda (port%549) (letrec ([next%550 (lambda () (let ([x%551 (read port%549)]) (if (eof-object? x%551) '() (if (is-load? x%551) (let ([f%552 (cadr x%551)]) (if (member f%552 fs%546) (error 'read-file "circular load: ~s" f%552) (let ([stuff%553 (read-the-file%544 f%552 (cons f%552 fs%546) "")]) (append stuff%553 (next%550))))) (if (is-load-relative? x%551) (let ([f%554 (cadr x%551)]) (if (member f%554 fs%546) (error 'read-file "circular load-relative: ~s" f%554) (let* ([actual-f%555 (if (char=? (string-ref f%554 0) #\/) f%554 (string-append d%547 f%554))] [stuff%556 (read-the-file%544 actual-f%555 (cons f%554 fs%546) (extract-directory-name actual-f%555))]) (append stuff%556 (next%550))))) (cons x%551 (next%550)))))))]) (next%550))))]) (begin (warn ")") q%548))))]) (lambda (f%557) (let ([res%558 (read-the-file%544 f%557 '() (extract-directory-name f%557))]) (begin (newline (current-output-port)) res%558)))))
(define make-Desugared-Program (lambda (the-definitions_ the-expression_) (vector 'Desugared-Program the-definitions_ the-expression_)))
(define is-Desugared-Program? (lambda (record%559) (if (vector? record%559) (if (= (vector-length record%559) 3) (eqv? (vector-ref record%559 0) 'Desugared-Program) #f) #f)))
(define make-SequenceExpr2 (lambda (e_ es_) (vector 'SequenceExpr2 e_ es_)))
(define is-SequenceExpr2? (lambda (record%560) (if (vector? record%560) (if (= (vector-length record%560) 3) (eqv? (vector-ref record%560 0) 'SequenceExpr2) #f) #f)))
(define transmogrify-quoted-pair-expression (lambda (e%561) (make-Application (make-Variable 'cons) (list (transmogrify-quoted-expression (car e%561)) (transmogrify-quoted-expression (cdr e%561))))))
(define transmogrify-quoted-non-pair-expression (lambda (e%562) (if (integer? e%562) (make-Literal (make-Integer e%562)) (if (boolean? e%562) (make-Literal (make-Boolean e%562)) (if (string? e%562) (make-Literal (make-String e%562)) (if (char? e%562) (make-Literal (make-Character e%562)) (if (symbol? e%562) (make-Literal (make-Symbol e%562)) (if (null? e%562) (make-Literal (make-Nil)) (error 'transmogrify-quoted-non-pair-expression "Quasar: ~s" e%562)))))))))
(define transmogrify-quoted-expression (lambda (e%563) (if (pair? e%563) (transmogrify-quoted-pair-expression e%563) (transmogrify-quoted-non-pair-expression e%563))))
(define *immutable* '())
(define file-immutable! (lambda (name%564 expression%565) (set! *immutable* (cons (make-DefExp name%564 expression%565) *immutable*))))
(define simple-expression? (lambda (e%566) (if (is-Literal? e%566) (let ([l_ (vector-ref e%566 1)]) #t) (if (is-Variable? e%566) (let ([x_ (vector-ref e%566 1)]) #t) (if (is-Abstraction? e%566) (let ([xs_ (vector-ref e%566 1)] [b_ (vector-ref e%566 2)]) #t) (if (is-IfThenElse? e%566) (let ([test-exp_ (vector-ref e%566 1)] [then-exp_ (vector-ref e%566 2)] [else-exp_ (vector-ref e%566 3)]) #f) (if (is-Application? e%566) (let ([e_ (vector-ref e%566 1)] [es_ (vector-ref e%566 2)]) #f) (if (is-CondExpr? e%566) (let ([ts_ (vector-ref e%566 1)] [es_ (vector-ref e%566 2)]) #f) (if (is-CaseExpr? e%566) (let ([e_ (vector-ref e%566 1)] [ls_ (vector-ref e%566 2)] [es_ (vector-ref e%566 3)]) #f) (if (is-CaseRecordExpr? e%566) (let ([e_ (vector-ref e%566 1)] [ls_ (vector-ref e%566 2)] [es_ (vector-ref e%566 3)]) #f) (if (is-ConjExpr? e%566) (let ([es_ (vector-ref e%566 1)]) #f) (if (is-DisjExpr? e%566) (let ([es_ (vector-ref e%566 1)]) #f) (if (is-LetExpr? e%566) (let ([xs_ (vector-ref e%566 1)] [es_ (vector-ref e%566 2)] [b_ (vector-ref e%566 3)]) #f) (if (is-SLetExpr? e%566) (let ([xs_ (vector-ref e%566 1)] [es_ (vector-ref e%566 2)] [b_ (vector-ref e%566 3)]) #f) (if (is-LetRecExpr? e%566) (let ([xs_ (vector-ref e%566 1)] [ls_ (vector-ref e%566 2)] [b_ (vector-ref e%566 3)]) #f) (if (is-SequenceExpr? e%566) (let ([es_ (vector-ref e%566 1)]) #f) (if (is-Suspend? e%566) (let ([e_ (vector-ref e%566 1)]) #f) (if (is-Delay? e%566) (let ([e_ (vector-ref e%566 1)]) #f) (if (is-Assign? e%566) (let ([x_ (vector-ref e%566 1)] [e_ (vector-ref e%566 2)]) #f) (if (is-Quotation? e%566) (let ([e_ (vector-ref e%566 1)]) #t) (error 'simple-expression? "quasar: ~s" e%566)))))))))))))))))))))
(define extend-substitution (lambda (xs%567 vs%568 env%569) (variadic-left-fold (lambda (env%570 var%571 val%572) (cons (cons var%571 val%572) env%570)) env%569 xs%567 vs%568)))
(define desugar-expression (lambda (e%573) (letrec ([substitute%574 (lambda (e%575 env%576) (if (is-Literal? e%575) (let ([l_ (vector-ref e%575 1)]) e%575) (if (is-Variable? e%575) (let ([x_ (vector-ref e%575 1)]) (let ([a%577 (assq x_ env%576)]) (if a%577 (cdr a%577) e%575))) (if (is-Abstraction? e%575) (let ([xs_ (vector-ref e%575 1)] [b_ (vector-ref e%575 2)]) (let ([ys%578 (if (symbol? xs_) (gensym! (string-append (symbol->string xs_) "%")) (map (lambda (x%579) (gensym! (string-append (symbol->string x%579) "%"))) xs_))]) (make-Abstraction ys%578 (substitute%574 b_ (if (symbol? xs_) (cons (cons xs_ (make-Variable ys%578)) env%576) (extend-substitution xs_ (map make-Variable ys%578) env%576)))))) (if (is-IfThenElse? e%575) (let ([test-exp_ (vector-ref e%575 1)] [then-exp_ (vector-ref e%575 2)] [else-exp_ (vector-ref e%575 3)]) (make-IfThenElse-if-you-really-have-to (substitute%574 test-exp_ env%576) (lambda () (substitute%574 then-exp_ env%576)) (lambda () (substitute%574 else-exp_ env%576)))) (if (is-Application? e%575) (let ([e_ (vector-ref e%575 1)] [es_ (vector-ref e%575 2)]) (make-Application-and-check-arity-if-possible (substitute%574 e_ env%576) (map (lambda (e%580) (substitute%574 e%580 env%576)) es_))) (if (is-CondExpr? e%575) (let ([ts_ (vector-ref e%575 1)] [es_ (vector-ref e%575 2)]) (letrec ([loop%581 (lambda (ts%582 es%583) (if (null? (cdr ts%582)) (substitute%574 (car es%583) env%576) (make-IfThenElse-if-you-really-have-to (substitute%574 (car ts%582) env%576) (lambda () (substitute%574 (car es%583) env%576)) (lambda () (loop%581 (cdr ts%582) (cdr es%583))))))]) (loop%581 ts_ es_))) (if (is-CaseExpr? e%575) (let ([e_ (vector-ref e%575 1)] [ls_ (vector-ref e%575 2)] [es_ (vector-ref e%575 3)]) (let* ([d%584 (substitute%574 e_ env%576)] [f%585 (lambda (d%586) (letrec ([loop%587 (lambda (ls%588 es%589) (if (null? (cdr ls%588)) (substitute%574 (car es%589) env%576) (if (null? (car ls%588)) (loop%587 (cdr ls%588) (cdr es%589)) (make-IfThenElse (letrec ([traverse%590 (lambda (ls%591) (if (null? (cdr ls%591)) (make-Application (make-Variable 'eqv?) (list d%586 (transmogrify-quoted-expression (car ls%591)))) (make-IfThenElse (make-Application (make-Variable 'eqv?) (list d%586 (transmogrify-quoted-expression (car ls%591)))) (make-Literal (make-Boolean #t)) (traverse%590 (cdr ls%591)))))]) (traverse%590 (car ls%588))) (substitute%574 (car es%589) env%576) (loop%587 (cdr ls%588) (cdr es%589))))))]) (loop%587 ls_ es_)))]) (if (simple-expression? d%584) (f%585 d%584) (let ([new%592 (gensym! "case%")]) (make-Application (make-Abstraction (list new%592) (f%585 (make-Variable new%592))) (list d%584)))))) (if (is-CaseRecordExpr? e%575) (let ([e_ (vector-ref e%575 1)] [ls_ (vector-ref e%575 2)] [es_ (vector-ref e%575 3)]) (let* ([d%593 (substitute%574 e_ env%576)] [f%594 (lambda (d%595) (letrec ([loop%596 (lambda (ls%597 es%598) (if (null? (cdr ls%597)) (substitute%574 (car es%598) env%576) (let ([name%599 (car (car ls%597))] [fields%600 (cdr (car ls%597))]) (let ([new-fields%601 (map (lambda (field%602) (gensym! (string-append (symbol->string field%602) "%"))) fields%600)]) (make-IfThenElse (make-Application (make-Variable (string->symbol (string-append "is-" (string-append (symbol->string name%599) "?")))) (list d%595)) (make-Application (make-Abstraction new-fields%601 (substitute%574 (car es%598) (extend-substitution fields%600 (map make-Variable new-fields%601) env%576))) (letrec ([process%603 (lambda (fields%604 offset%605) (if (null? fields%604) '() (cons (make-Application (make-Variable 'vector-ref) (list d%595 (make-Literal (make-Integer offset%605)))) (process%603 (cdr fields%604) (+ offset%605 1)))))]) (process%603 fields%600 1))) (loop%596 (cdr ls%597) (cdr es%598)))))))]) (loop%596 ls_ es_)))]) (if (simple-expression? d%593) (f%594 d%593) (let ([new%606 (gensym! "case-record%")]) (make-Application (make-Abstraction (list new%606) (f%594 (make-Variable new%606))) (list d%593)))))) (if (is-ConjExpr? e%575) (let ([es_ (vector-ref e%575 1)]) (letrec ([loop%607 (lambda (es%608) (if (null? (cdr es%608)) (substitute%574 (car es%608) env%576) (make-IfThenElse-if-you-really-have-to (substitute%574 (car es%608) env%576) (lambda () (loop%607 (cdr es%608))) (lambda () (make-Literal (make-Boolean #f))))))]) (if (null? es_) (make-Literal (make-Boolean #t)) (loop%607 es_)))) (if (is-DisjExpr? e%575) (let ([es_ (vector-ref e%575 1)]) (letrec ([loop%609 (lambda (es%610) (let ([d%611 (substitute%574 (car es%610) env%576)]) (if (null? (cdr es%610)) d%611 (if (simple-expression? d%611) (make-IfThenElse-if-you-really-have-to d%611 (lambda () d%611) (lambda () (loop%609 (cdr es%610)))) (let ([new%612 (gensym! "or%")]) (make-Application (make-Abstraction (list new%612) (make-IfThenElse (make-Variable new%612) (make-Variable new%612) (loop%609 (cdr es%610)))) (list d%611)))))))]) (if (null? es_) (make-Literal (make-Boolean #f)) (loop%609 es_)))) (if (is-LetExpr? e%575) (let ([xs_ (vector-ref e%575 1)] [es_ (vector-ref e%575 2)] [b_ (vector-ref e%575 3)]) (let ([ys%613 (map (lambda (x%614) (gensym! (string-append (symbol->string x%614) "%"))) xs_)]) (make-Application (make-Abstraction ys%613 (substitute%574 b_ (extend-substitution xs_ (map make-Variable ys%613) env%576))) (map (lambda (e%615) (substitute%574 e%615 env%576)) es_)))) (if (is-SLetExpr? e%575) (let ([xs_ (vector-ref e%575 1)] [es_ (vector-ref e%575 2)] [b_ (vector-ref e%575 3)]) (letrec ([loop%616 (lambda (xs%617 es%618 env%619) (if (null? xs%617) (substitute%574 b_ env%619) (make-Application (make-Abstraction (list (car xs%617)) (loop%616 (cdr xs%617) (cdr es%618) (cons (cons (car xs%617) (make-Variable (car xs%617))) env%619))) (list (substitute%574 (car es%618) env%619)))))]) (loop%616 xs_ es_ env%576))) (if (is-LetRecExpr? e%575) (let ([xs_ (vector-ref e%575 1)] [ls_ (vector-ref e%575 2)] [b_ (vector-ref e%575 3)]) (let ([ys%620 (map (lambda (x%621) (gensym! (string-append (symbol->string x%621) "%"))) xs_)]) (let ([env%622 (extend-substitution xs_ (map make-Variable ys%620) env%576)]) (make-LetRecExpr ys%620 (map (lambda (l%623) (substitute%574 l%623 env%622)) ls_) (substitute%574 b_ env%622))))) (if (is-SequenceExpr? e%575) (let ([es_ (vector-ref e%575 1)]) (letrec ([flatten%624 (lambda (es%631 a%632) (if (null? es%631) a%632 (let ([case-record%633 (car es%631)]) (if (is-SequenceExpr? case-record%633) (let ([as_ (vector-ref case-record%633 1)]) (flatten%624 as_ (flatten%624 (cdr es%631) a%632))) (cons (car es%631) (flatten%624 (cdr es%631) a%632))))))] [transparent?%625 (lambda (e%634) (if (is-Literal? e%634) (let ([l_ (vector-ref e%634 1)]) #t) (if (is-Variable? e%634) (let ([x_ (vector-ref e%634 1)]) #t) (if (is-Abstraction? e%634) (let ([xs_ (vector-ref e%634 1)] [b_ (vector-ref e%634 2)]) #t) (if (is-IfThenElse? e%634) (let ([test-exp_ (vector-ref e%634 1)] [then-exp_ (vector-ref e%634 2)] [else-exp_ (vector-ref e%634 3)]) (if (transparent?%625 test-exp_) (if (transparent?%625 then-exp_) (transparent?%625 else-exp_) #f) #f)) (if (is-Application? e%634) (let ([e_ (vector-ref e%634 1)] [es_ (vector-ref e%634 2)]) (if (andmap1 transparent?%625 es_) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (transparent?%625 b_)) #f) #f)) (if (is-CondExpr? e%634) (let ([ts_ (vector-ref e%634 1)] [es_ (vector-ref e%634 2)]) (if (andmap1 transparent?%625 ts_) (andmap1 transparent?%625 es_) #f)) (if (is-CaseExpr? e%634) (let ([e_ (vector-ref e%634 1)] [ls_ (vector-ref e%634 2)] [es_ (vector-ref e%634 3)]) (if (transparent?%625 e_) (andmap1 transparent?%625 es_) #f)) (if (is-CaseRecordExpr? e%634) (let ([e_ (vector-ref e%634 1)] [ls_ (vector-ref e%634 2)] [es_ (vector-ref e%634 3)]) (if (transparent?%625 e_) (andmap1 transparent?%625 es_) #f)) (if (is-ConjExpr? e%634) (let ([es_ (vector-ref e%634 1)]) (andmap1 transparent?%625 es_)) (if (is-DisjExpr? e%634) (let ([es_ (vector-ref e%634 1)]) (andmap1 transparent?%625 es_)) (if (is-LetExpr? e%634) (let ([xs_ (vector-ref e%634 1)] [es_ (vector-ref e%634 2)] [b_ (vector-ref e%634 3)]) (if (andmap1 transparent?%625 es_) (transparent?%625 b_) #f)) (if (is-SLetExpr? e%634) (let ([xs_ (vector-ref e%634 1)] [es_ (vector-ref e%634 2)] [b_ (vector-ref e%634 3)]) (if (andmap1 transparent?%625 es_) (transparent?%625 b_) #f)) (if (is-LetRecExpr? e%634) (let ([xs_ (vector-ref e%634 1)] [ls_ (vector-ref e%634 2)] [b_ (vector-ref e%634 3)]) (transparent?%625 b_)) (if (is-SequenceExpr? e%634) (let ([es_ (vector-ref e%634 1)]) (andmap1 transparent?%625 es_)) (if (is-Suspend? e%634) (let ([e_ (vector-ref e%634 1)]) #t) (if (is-Delay? e%634) (let ([e_ (vector-ref e%634 1)]) #t) (if (is-Assign? e%634) (let ([x_ (vector-ref e%634 1)] [e_ (vector-ref e%634 2)]) #f) (if (is-Quotation? e%634) (let ([e_ (vector-ref e%634 1)]) #t) (error 'transparent? "quasar: ~s" e%634))))))))))))))))))))] [clean-up%626 (lambda (es%635) (if (null? (cdr es%635)) es%635 (if (transparent?%625 (car es%635)) (clean-up%626 (cdr es%635)) (cons (car es%635) (clean-up%626 (cdr es%635))))))] [process-1%627 (lambda (es%636) (if (null? (cdr es%636)) (substitute%574 (car es%636) env%576) (if (simple-expression? (car es%636) env%576) (process-1%627 (cdr es%636)) (make-Application (make-Abstraction (list (gensym! "begin%")) (process-1%627 (cdr es%636))) (list (substitute%574 (car es%636) env%576))))))] [process-2%628 (lambda (es%637) (let ([formals%638 (map (lambda (e%639) (gensym! "begin%")) es%637)]) (make-Application (make-Abstraction formals%638 (make-Variable (car (last-pair formals%638)))) (map (lambda (e%640) (substitute%574 e%640 env%576)) es%637))))] [process-3%629 (lambda (es%641) (make-SequenceExpr (map (lambda (e%642) (substitute%574 e%642 env%576)) es%641)))] [process-4%630 (lambda (es%643) (let ([res%644 (map (lambda (e%645) (substitute%574 e%645 env%576)) es%643)]) (make-SequenceExpr2 (car res%644) (cdr res%644))))]) (process-4%630 (clean-up%626 (flatten%624 es_ '()))))) (if (is-Suspend? e%575) (let ([e_ (vector-ref e%575 1)]) (make-Abstraction '() (substitute%574 e_ env%576))) (if (is-Delay? e%575) (let ([e_ (vector-ref e%575 1)]) (let ([flag/result%646 (gensym! "delay%")] [tmp%647 (gensym! "delay-tmp%")]) (make-Application (make-Abstraction (list flag/result%646) (make-Abstraction '() (make-IfThenElse (make-Application (make-Variable 'vector-ref) (list (make-Variable flag/result%646) (make-Literal (make-Integer 0)))) (make-Application (make-Variable 'vector-ref) (list (make-Variable flag/result%646) (make-Literal (make-Integer 1)))) (make-Application (make-Abstraction (list tmp%647) (make-SequenceExpr2 (make-Application (make-Variable 'vector-set!) (list (make-Variable flag/result%646) (make-Literal (make-Integer 1)) (make-Variable tmp%647))) (list (make-Application (make-Variable 'vector-set!) (list (make-Variable flag/result%646) (make-Literal (make-Integer 0)) (make-Literal (make-Boolean #t)))) (make-Variable tmp%647)))) (list (substitute%574 e_ env%576)))))) (list (make-Application (make-Variable 'vector) (list (make-Literal (make-Boolean #f)) (make-Literal (make-String "not computed yet")))))))) (if (is-Assign? e%575) (let ([x_ (vector-ref e%575 1)] [e_ (vector-ref e%575 2)]) (make-Assign (let ([a%648 (assq x_ env%576)]) (if a%648 (vector-ref (cdr a%648) 1) x_)) (substitute%574 e_ env%576))) (if (is-Quotation? e%575) (let ([e_ (vector-ref e%575 1)]) (if (pair? e_) (let ([q%649 (gensym! "immutable%")]) (begin (file-immutable! q%649 (transmogrify-quoted-pair-expression e_)) (make-Variable q%649))) (transmogrify-quoted-non-pair-expression e_))) (error 'desugar-expression "quasar: ~s" e%575))))))))))))))))))))]) (substitute%574 e%573 '()))))
(define make-IfThenElse-if-you-really-have-to (lambda (test-exp%650 thunk-then-exp%651 thunk-else-exp%652) (if (is-Literal? test-exp%650) (let ([l_ (vector-ref test-exp%650 1)]) (if (is-Boolean? l_) (let ([b_ (vector-ref l_ 1)]) (if b_ (thunk-then-exp%651) (thunk-else-exp%652))) (thunk-then-exp%651))) (make-IfThenElse test-exp%650 (thunk-then-exp%651) (thunk-else-exp%652)))))
(define make-Application-and-check-arity-if-possible (lambda (e%653 es%654) (if (is-Abstraction? e%653) (let ([xs_ (vector-ref e%653 1)] [b_ (vector-ref e%653 2)]) (if (let ([or%655 (symbol? xs_)]) (if or%655 or%655 (= (length xs_) (length es%654)))) (make-Application e%653 es%654) (error 'desugar-expression "arity mismatch in beta-redex: ~s and ~s" xs_ es%654))) (make-Application e%653 es%654))))
(define desugar-definition (lambda (d%656) (if (is-DefRec? d%656) (let ([name_ (vector-ref d%656 1)] [fields_ (vector-ref d%656 2)]) (let ([sname%657 (symbol->string name_)] [len%658 (+ (length fields_) 1)]) (let ([make-name%659 (string->symbol (string-append "make-" sname%657))] [name?%660 (string->symbol (string-append "is-" (string-append sname%657 "?")))] [indices%661 (letrec ([loop%662 (lambda (i%663) (if (= i%663 len%658) '() (cons i%663 (loop%662 (add1 i%663)))))]) (loop%662 1))] [v%664 (gensym! "record%")]) (list (make-DefExp make-name%659 (let ([fresh-fields%665 (map (lambda (x%666) (string->symbol (string-append (symbol->string x%666) "_"))) fields_)]) (make-Abstraction fresh-fields%665 (make-Application (make-Variable 'vector) (cons (make-Literal (make-Symbol name_)) (map make-Variable fresh-fields%665)))))) (make-DefExp name?%660 (make-Abstraction (list v%664) (make-IfThenElse (make-Application (make-Variable 'vector?) (list (make-Variable v%664))) (make-IfThenElse (make-Application (make-Variable '=) (list (make-Application (make-Variable 'vector-length) (list (make-Variable v%664))) (make-Literal (make-Integer len%658)))) (make-Application (make-Variable 'eqv?) (list (make-Application (make-Variable 'vector-ref) (list (make-Variable v%664) (make-Literal (make-Integer 0)))) (make-Literal (make-Symbol name_)))) (make-Literal (make-Boolean #f))) (make-Literal (make-Boolean #f))))))))) (if (is-DefExp? d%656) (let ([name_ (vector-ref d%656 1)] [expression_ (vector-ref d%656 2)]) (list (make-DefExp name_ (desugar-expression expression_)))) (error 'desugar-program "not a definition: ~s" d%656)))))
(define check-for-multiple-definitions! (lambda (ds%667) (letrec ([loop%668 (lambda (xs%669) (if (null? xs%669) '() (if (memq (car xs%669) (cdr xs%669)) (cons (car xs%669) (loop%668 (cdr xs%669))) (loop%668 (cdr xs%669)))))]) (let ([duplicates%670 (loop%668 (map (lambda (d%671) (if (is-DefExp? d%671) (let ([name_ (vector-ref d%671 1)] [expression_ (vector-ref d%671 2)]) name_) (error 'check-for-multiple-definitions! "not a definition: ~s" d%671))) ds%667))]) (if (null? duplicates%670) 'ok (error 'check-for-multiple-definitions! "multiple definitions: ~s" duplicates%670))))))
(define desugar-program (lambda (p%672) (if (is-Parsed-Program? p%672) (let ([the-definitions_ (vector-ref p%672 1)] [the-expression_ (vector-ref p%672 2)]) (begin (warn "Desugaring") (set! *immutable* '()) (let* ([ds%673 (map-append desugar-definition the-definitions_)] [e%674 (desugar-expression the-expression_)]) (begin (warnl " / Desugared") (make-Desugared-Program (append (reverse *immutable*) ds%673) e%674))))) (error 'desugar-program "not a parsed program"))))
(define make-Boxed-Program (lambda (the-definitions_ the-expression_) (vector 'Boxed-Program the-definitions_ the-expression_)))
(define is-Boxed-Program? (lambda (record%675) (if (vector? record%675) (if (= (vector-length record%675) 3) (eqv? (vector-ref record%675 0) 'Boxed-Program) #f) #f)))
(define make-Boxed-Abstraction (lambda (formals_ body_ mutated_) (vector 'Boxed-Abstraction formals_ body_ mutated_)))
(define is-Boxed-Abstraction? (lambda (record%676) (if (vector? record%676) (if (= (vector-length record%676) 4) (eqv? (vector-ref record%676 0) 'Boxed-Abstraction) #f) #f)))
(define make-Boxed-Variable (lambda (x_) (vector 'Boxed-Variable x_)))
(define is-Boxed-Variable? (lambda (record%677) (if (vector? record%677) (if (= (vector-length record%677) 2) (eqv? (vector-ref record%677 0) 'Boxed-Variable) #f) #f)))
(define make-Boxed-LetRecExpr (lambda (formals_ lambdas_ body_ mutated_) (vector 'Boxed-LetRecExpr formals_ lambdas_ body_ mutated_)))
(define is-Boxed-LetRecExpr? (lambda (record%678) (if (vector? record%678) (if (= (vector-length record%678) 5) (eqv? (vector-ref record%678 0) 'Boxed-LetRecExpr) #f) #f)))
(define make-Abstraction-val (lambda (lam_) (vector 'Abstraction-val lam_)))
(define is-Abstraction-val? (lambda (record%679) (if (vector? record%679) (if (= (vector-length record%679) 2) (eqv? (vector-ref record%679 0) 'Abstraction-val) #f) #f)))
(define make-Abstraction-box (lambda (lam_) (vector 'Abstraction-box lam_)))
(define is-Abstraction-box? (lambda (record%680) (if (vector? record%680) (if (= (vector-length record%680) 2) (eqv? (vector-ref record%680 0) 'Abstraction-box) #f) #f)))
(define scan-expression (lambda (e%681 globals%682) (letrec ([walks%683 (lambda (es%686 locals%687 updates%688 k%689) (if (null? es%686) (k%689 '() updates%688) (walk%684 (car es%686) locals%687 updates%688 (lambda (e%690 updates%691) (walks%683 (cdr es%686) locals%687 updates%691 (lambda (es%692 updates%693) (k%689 (cons e%690 es%692) updates%693)))))))] [walk%684 (lambda (e%694 locals%695 updates%696 k%697) (if (is-Literal? e%694) (let ([l_ (vector-ref e%694 1)]) (k%697 e%694 updates%696)) (if (is-Variable? e%694) (let ([x_ (vector-ref e%694 1)]) (k%697 e%694 updates%696)) (if (is-Abstraction? e%694) (let ([xs_ (vector-ref e%694 1)] [b_ (vector-ref e%694 2)]) (walk%684 b_ (cons (if (symbol? xs_) (list xs_) xs_) locals%695) (cons '() updates%696) (lambda (b%698 updates%699) (k%697 (make-Boxed-Abstraction xs_ b%698 (car updates%699)) (cdr updates%699))))) (if (is-IfThenElse? e%694) (let ([test-exp_ (vector-ref e%694 1)] [then-exp_ (vector-ref e%694 2)] [else-exp_ (vector-ref e%694 3)]) (walk%684 test-exp_ locals%695 updates%696 (lambda (test-exp%700 updates%701) (walk%684 then-exp_ locals%695 updates%701 (lambda (then-exp%702 updates%703) (walk%684 else-exp_ locals%695 updates%703 (lambda (else-exp%704 updates%705) (k%697 (make-IfThenElse test-exp%700 then-exp%702 else-exp%704) updates%705)))))))) (if (is-Application? e%694) (let ([e_ (vector-ref e%694 1)] [es_ (vector-ref e%694 2)]) (walk%684 e_ locals%695 updates%696 (lambda (e%706 updates%707) (walks%683 es_ locals%695 updates%707 (lambda (es%708 updates%709) (k%697 (make-Application e%706 es%708) updates%709)))))) (if (is-SequenceExpr2? e%694) (let ([e_ (vector-ref e%694 1)] [es_ (vector-ref e%694 2)]) (walk%684 e_ locals%695 updates%696 (lambda (e%710 updates%711) (walks%683 es_ locals%695 updates%711 (lambda (es%712 updates%713) (k%697 (make-SequenceExpr2 e%710 es%712) updates%713)))))) (if (is-LetRecExpr? e%694) (let ([xs_ (vector-ref e%694 1)] [ls_ (vector-ref e%694 2)] [b_ (vector-ref e%694 3)]) (let ([locals%714 (cons xs_ locals%695)] [updates%715 (cons '() updates%696)]) (walks%683 ls_ locals%714 updates%715 (lambda (ls%716 updates%717) (walk%684 b_ locals%714 updates%717 (lambda (b%718 updates%719) (k%697 (make-Boxed-LetRecExpr xs_ ls%716 b%718 (car updates%719)) (cdr updates%719)))))))) (if (is-Assign? e%694) (let ([x_ (vector-ref e%694 1)] [e_ (vector-ref e%694 2)]) (walk%684 e_ locals%695 (insert%685 x_ locals%695 updates%696 globals%682) (lambda (e%720 updates%721) (k%697 (if (ormap1 (lambda (xs%722) (member x_ xs%722)) locals%695) (make-Application (make-Variable 'vector-set!) (list (make-Boxed-Variable x_) (make-Literal (make-Integer 0)) e%720)) (make-Assign x_ e%720)) updates%721)))) (error 'scan-expression "quasar: ~s" e%694))))))))))] [insert%685 (lambda (x%723 locals%724 updates%725 globals%726) (letrec ([traverse%727 (lambda (locals%728 updates%729) (if (null? locals%728) (if (let ([or%730 (member x%723 globals%726)]) (if or%730 or%730 (member x%723 predefined-procedures))) '() (error 'scan-expression "undeclared variable: ~s" x%723)) (if (member x%723 (car locals%728)) (if (member x%723 (car updates%729)) updates%729 (cons (cons x%723 (car updates%729)) (cdr updates%729))) (cons (car updates%729) (traverse%727 (cdr locals%728) (cdr updates%729))))))]) (traverse%727 locals%724 updates%725)))]) (walk%684 e%681 '() '() (lambda (e%731 updates%732) (if (null? updates%732) e%731 (error 'scan-expression "non-null updates on return: ~s" updates%732)))))))
(define box-expression (lambda (e%733 globals%734) (letrec ([wrap-let-expression%735 (lambda (mutables%739 e%740) (if (null? mutables%739) e%740 (make-Application (make-Abstraction mutables%739 e%740) (map (lambda (mutable%741) (make-Application (make-Variable 'vector) (list (make-Variable mutable%741)))) mutables%739))))] [walk-application%736 (lambda (e%742 es%743) (if (is-Abstraction? e%742) (let ([xs_ (vector-ref e%742 1)] [b_ (vector-ref e%742 2)]) (if (symbol? xs_) (make-Application (make-Abstraction (list xs_) b_) (letrec ([walk%744 (lambda (es%745) (if (null? es%745) (make-Literal (make-Nil)) (make-Application (make-Variable 'cons) (list (car es%745) (walk%744 (cdr es%745))))))]) (list (walk%744 es%743)))) (make-Application e%742 es%743))) (make-Application e%742 es%743)))] [walk%737 (lambda (e%746 env-var%747 env-mut%748) (if (is-Literal? e%746) (let ([l_ (vector-ref e%746 1)]) e%746) (if (is-Variable? e%746) (let ([x_ (vector-ref e%746 1)]) (if (mutable?%738 x_ env-var%747 env-mut%748) (make-Application (make-Variable 'vector-ref) (list (make-Variable x_) (make-Literal (make-Integer 0)))) e%746)) (if (is-Boxed-Variable? e%746) (let ([x_ (vector-ref e%746 1)]) (make-Variable x_)) (if (is-Boxed-Abstraction? e%746) (let ([xs_ (vector-ref e%746 1)] [b_ (vector-ref e%746 2)] [mutables_ (vector-ref e%746 3)]) (make-Abstraction xs_ (wrap-let-expression%735 mutables_ (walk%737 b_ (cons (if (symbol? xs_) (list xs_) xs_) env-var%747) (cons mutables_ env-mut%748))))) (if (is-IfThenElse? e%746) (let ([test-exp_ (vector-ref e%746 1)] [then-exp_ (vector-ref e%746 2)] [else-exp_ (vector-ref e%746 3)]) (make-IfThenElse (walk%737 test-exp_ env-var%747 env-mut%748) (walk%737 then-exp_ env-var%747 env-mut%748) (walk%737 else-exp_ env-var%747 env-mut%748))) (if (is-Application? e%746) (let ([e_ (vector-ref e%746 1)] [es_ (vector-ref e%746 2)]) (walk-application%736 (walk%737 e_ env-var%747 env-mut%748) (map1 (lambda (e%749) (walk%737 e%749 env-var%747 env-mut%748)) es_))) (if (is-SequenceExpr2? e%746) (let ([e_ (vector-ref e%746 1)] [es_ (vector-ref e%746 2)]) (make-SequenceExpr2 (walk%737 e_ env-var%747 env-mut%748) (map1 (lambda (e%750) (walk%737 e%750 env-var%747 env-mut%748)) es_))) (if (is-Boxed-LetRecExpr? e%746) (let ([xs_ (vector-ref e%746 1)] [ls_ (vector-ref e%746 2)] [b_ (vector-ref e%746 3)] [mutables_ (vector-ref e%746 4)]) (let ([env-var%751 (cons xs_ env-var%747)] [env-mut%752 (cons mutables_ env-mut%748)]) (make-LetRecExpr xs_ (map (lambda (x%753 l%754) (if (member x%753 mutables_) (make-Abstraction-box (walk%737 l%754 env-var%751 env-mut%752)) (make-Abstraction-val (walk%737 l%754 env-var%751 env-mut%752)))) xs_ ls_) (walk%737 b_ env-var%751 env-mut%752)))) (if (is-Assign? e%746) (let ([x_ (vector-ref e%746 1)] [e_ (vector-ref e%746 2)]) (make-Assign x_ (walk%737 e_ env-var%747 env-mut%748))) (error 'box-expression "quasar: ~s" e%746)))))))))))] [mutable?%738 (lambda (x%755 env-var%756 env-mut%757) (letrec ([loop%758 (lambda (vars%759 muts%760) (if (null? muts%760) (if (null? vars%759) #f (error 'box-expression "mismatch between ~s and ~s" env-var%756 env-mut%757)) (if (null? vars%759) (error 'box-expression "mismatch between ~s and ~s" env-var%756 env-mut%757) (if (member x%755 (car muts%760)) (if (member x%755 (car vars%759)) #t (error 'box-expression "~x in ~s but not in ~s" x%755 env-var%756 env-mut%757)) (loop%758 (cdr vars%759) (cdr muts%760))))))]) (loop%758 env-var%756 env-mut%757)))]) (walk%737 (scan-expression e%733 globals%734) '() '()))))
(define box-definitions (lambda (ds%761 globals%762) (letrec ([walk%763 (lambda (ds%764) (if (null? ds%764) '() (let ([case-record%765 (car ds%764)]) (if (is-DefExp? case-record%765) (let ([name_ (vector-ref case-record%765 1)] [expression_ (vector-ref case-record%765 2)]) (cons (make-DefExp name_ (box-expression expression_ globals%762)) (walk%763 (cdr ds%764)))) (error 'box-definitions "not a definition: ~s" (car ds%764))))))]) (walk%763 ds%761))))
(define box-program (lambda (p%766) (if (is-Desugared-Program? p%766) (let ([the-definitions_ (vector-ref p%766 1)] [the-expression_ (vector-ref p%766 2)]) (begin (warn "Boxing") (let* ([globals%767 (map1 (lambda (d%768) (if (is-DefExp? d%768) (let ([name_ (vector-ref d%768 1)] [expression_ (vector-ref d%768 2)]) name_) (error 'box-program "not a definition: ~s" d%768))) the-definitions_)] [ds%769 (box-definitions the-definitions_ globals%767)] [e%770 (box-expression the-expression_ globals%767)]) (begin (warnl " / Boxed") (make-Boxed-Program ds%769 e%770))))) (error 'box-program "not a desugared program"))))
(define make-Linearized-Program (lambda (the-definitions_ the-expression_) (vector 'Linearized-Program the-definitions_ the-expression_)))
(define is-Linearized-Program? (lambda (record%771) (if (vector? record%771) (if (= (vector-length record%771) 3) (eqv? (vector-ref record%771 0) 'Linearized-Program) #f) #f)))
(define make-LinDefExp (lambda (x_ e_) (vector 'LinDefExp x_ e_)))
(define is-LinDefExp? (lambda (record%772) (if (vector? record%772) (if (= (vector-length record%772) 3) (eqv? (vector-ref record%772 0) 'LinDefExp) #f) #f)))
(define make-LinLiteral (lambda (l_) (vector 'LinLiteral l_)))
(define is-LinLiteral? (lambda (record%773) (if (vector? record%773) (if (= (vector-length record%773) 2) (eqv? (vector-ref record%773 0) 'LinLiteral) #f) #f)))
(define make-LinVariable (lambda (x_) (vector 'LinVariable x_)))
(define is-LinVariable? (lambda (record%774) (if (vector? record%774) (if (= (vector-length record%774) 2) (eqv? (vector-ref record%774 0) 'LinVariable) #f) #f)))
(define make-LinVariableTmp (lambda (int_) (vector 'LinVariableTmp int_)))
(define is-LinVariableTmp? (lambda (record%775) (if (vector? record%775) (if (= (vector-length record%775) 2) (eqv? (vector-ref record%775 0) 'LinVariableTmp) #f) #f)))
(define make-LinVariableJoin (lambda (int_) (vector 'LinVariableJoin int_)))
(define is-LinVariableJoin? (lambda (record%776) (if (vector? record%776) (if (= (vector-length record%776) 2) (eqv? (vector-ref record%776 0) 'LinVariableJoin) #f) #f)))
(define make-LinAbstraction (lambda (xs_ b_) (vector 'LinAbstraction xs_ b_)))
(define is-LinAbstraction? (lambda (record%777) (if (vector? record%777) (if (= (vector-length record%777) 3) (eqv? (vector-ref record%777 0) 'LinAbstraction) #f) #f)))
(define make-LinIfThenElse (lambda (test-exp_ then-exp_ else-exp_) (vector 'LinIfThenElse test-exp_ then-exp_ else-exp_)))
(define is-LinIfThenElse? (lambda (record%778) (if (vector? record%778) (if (= (vector-length record%778) 4) (eqv? (vector-ref record%778 0) 'LinIfThenElse) #f) #f)))
(define make-LinApplication (lambda (e_ es_) (vector 'LinApplication e_ es_)))
(define is-LinApplication? (lambda (record%779) (if (vector? record%779) (if (= (vector-length record%779) 3) (eqv? (vector-ref record%779 0) 'LinApplication) #f) #f)))
(define make-LinLetRecExpr (lambda (xs_ ls_ b_) (vector 'LinLetRecExpr xs_ ls_ b_)))
(define is-LinLetRecExpr? (lambda (record%780) (if (vector? record%780) (if (= (vector-length record%780) 4) (eqv? (vector-ref record%780 0) 'LinLetRecExpr) #f) #f)))
(define make-LinAssign (lambda (x_ e_) (vector 'LinAssign x_ e_)))
(define is-LinAssign? (lambda (record%781) (if (vector? record%781) (if (= (vector-length record%781) 3) (eqv? (vector-ref record%781 0) 'LinAssign) #f) #f)))
(define make-LinAssignLam (lambda (x_ l_) (vector 'LinAssignLam x_ l_)))
(define is-LinAssignLam? (lambda (record%782) (if (vector? record%782) (if (= (vector-length record%782) 3) (eqv? (vector-ref record%782 0) 'LinAssignLam) #f) #f)))
(define make-LinAssignApp (lambda (x_ c_) (vector 'LinAssignApp x_ c_)))
(define is-LinAssignApp? (lambda (record%783) (if (vector? record%783) (if (= (vector-length record%783) 3) (eqv? (vector-ref record%783 0) 'LinAssignApp) #f) #f)))
(define make-LinBindCmp (lambda (int_ c_ b_) (vector 'LinBindCmp int_ c_ b_)))
(define is-LinBindCmp? (lambda (record%784) (if (vector? record%784) (if (= (vector-length record%784) 4) (eqv? (vector-ref record%784 0) 'LinBindCmp) #f) #f)))
(define make-LinBindVal (lambda (int_ v_ b_) (vector 'LinBindVal int_ v_ b_)))
(define is-LinBindVal? (lambda (record%785) (if (vector? record%785) (if (= (vector-length record%785) 4) (eqv? (vector-ref record%785 0) 'LinBindVal) #f) #f)))
(define make-LinReturn (lambda (v_) (vector 'LinReturn v_)))
(define is-LinReturn? (lambda (record%786) (if (vector? record%786) (if (= (vector-length record%786) 2) (eqv? (vector-ref record%786 0) 'LinReturn) #f) #f)))
(define make-LinBindJoin (lambda (int_ c_ b_) (vector 'LinBindJoin int_ c_ b_)))
(define is-LinBindJoin? (lambda (record%787) (if (vector? record%787) (if (= (vector-length record%787) 4) (eqv? (vector-ref record%787 0) 'LinBindJoin) #f) #f)))
(define make-LinSeq (lambda (int_ c1_ c2_) (vector 'LinSeq int_ c1_ c2_)))
(define is-LinSeq? (lambda (record%788) (if (vector? record%788) (if (= (vector-length record%788) 4) (eqv? (vector-ref record%788 0) 'LinSeq) #f) #f)))
(define linearize-expression0 (lambda (e%789) (if (is-Literal? e%789) (let ([l_ (vector-ref e%789 1)]) (make-LinReturn (make-LinLiteral l_))) (if (is-Variable? e%789) (let ([x_ (vector-ref e%789 1)]) (make-LinReturn (make-LinVariable x_))) (if (is-Abstraction? e%789) (let ([xs_ (vector-ref e%789 1)] [b_ (vector-ref e%789 2)]) (make-LinReturn (make-LinAbstraction xs_ (linearize-expression0 b_)))) (if (is-IfThenElse? e%789) (let ([test-exp_ (vector-ref e%789 1)] [then-exp_ (vector-ref e%789 2)] [else-exp_ (vector-ref e%789 3)]) (linearize-expression22 test-exp_ 0 (lambda () (linearize-expression0 then-exp_)) (lambda () (linearize-expression0 else-exp_)))) (if (is-Application? e%789) (let ([e_ (vector-ref e%789 1)] [es_ (vector-ref e%789 2)]) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (linearize-expression2s es_ 0 (lambda (vs%790 level%791) (make-LinApplication (make-LinAbstraction xs_ (linearize-expression0 b_)) vs%790)))) (linearize-expression2 e_ 0 (lambda (v%792 level%793) (linearize-expression2s es_ level%793 (lambda (vs%794 level%795) (make-LinApplication v%792 vs%794))))))) (if (is-SequenceExpr2? e%789) (let ([e_ (vector-ref e%789 1)] [es_ (vector-ref e%789 2)]) (linearize-expression0-seq e_ es_)) (if (is-LetRecExpr? e%789) (let ([xs_ (vector-ref e%789 1)] [ls_ (vector-ref e%789 2)] [b_ (vector-ref e%789 3)]) (make-LinLetRecExpr xs_ (map1 (lambda (l%796) (if (is-Abstraction-val? l%796) (let ([lam_ (vector-ref l%796 1)]) (make-Abstraction-val (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression0 "invalid letrec header: ~s" l%796)))) (if (is-Abstraction-box? l%796) (let ([lam_ (vector-ref l%796 1)]) (make-Abstraction-box (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression0 "invalid letrec header: ~s" l%796)))) (error 'linearize-expression0 "invalid letrec header: ~s" l%796)))) ls_) (linearize-expression0 b_))) (if (is-Assign? e%789) (let ([x_ (vector-ref e%789 1)] [e_ (vector-ref e%789 2)]) (linearize-expression2 e_ 0 (lambda (v%797 level%798) (make-LinSeq 0 (make-LinAssign x_ v%797) (make-LinReturn (make-LinLiteral (make-Void))))))) (error 'linearize-expression0 "quasar: ~s" e%789)))))))))))
(define linearize-expression0-seq (lambda (e%799 es%800) (if (null? es%800) (linearize-expression0 e%799) (linearize-expression3 e%799 0 (lambda () (linearize-expression0-seq (car es%800) (cdr es%800)))))))
(define linearize-expression1 (lambda (e%801 level%802 k%803) (if (is-Literal? e%801) (let ([l_ (vector-ref e%801 1)]) (make-LinApplication (make-LinVariableJoin k%803) (list (make-LinLiteral l_)))) (if (is-Variable? e%801) (let ([x_ (vector-ref e%801 1)]) (make-LinApplication (make-LinVariableJoin k%803) (list (make-LinVariable x_)))) (if (is-Abstraction? e%801) (let ([xs_ (vector-ref e%801 1)] [b_ (vector-ref e%801 2)]) (make-LinBindCmp level%802 (make-LinAbstraction xs_ (linearize-expression0 b_)) (make-LinApplication (make-LinVariableJoin k%803) (list (make-LinVariableTmp level%802))))) (if (is-IfThenElse? e%801) (let ([test-exp_ (vector-ref e%801 1)] [then-exp_ (vector-ref e%801 2)] [else-exp_ (vector-ref e%801 3)]) (linearize-expression22 test-exp_ level%802 (lambda () (linearize-expression1 then-exp_ level%802 k%803)) (lambda () (linearize-expression1 else-exp_ level%802 k%803)))) (if (is-Application? e%801) (let ([e_ (vector-ref e%801 1)] [es_ (vector-ref e%801 2)]) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (linearize-expression2s es_ level%802 (lambda (vs%804 level_vs%805) (make-LinApplication (make-LinAbstraction xs_ (linearize-expression1 b_ level%802 k%803)) vs%804)))) (linearize-expression2 e_ level%802 (lambda (v%806 level_e%807) (linearize-expression2s es_ level_e%807 (lambda (vs%808 level_es%809) (make-LinBindCmp level%802 (make-LinApplication v%806 vs%808) (make-LinApplication (make-LinVariableJoin k%803) (list (make-LinVariableTmp level%802)))))))))) (if (is-SequenceExpr2? e%801) (let ([e_ (vector-ref e%801 1)] [es_ (vector-ref e%801 2)]) (linearize-expression1-seq e_ es_ level%802 k%803)) (if (is-LetRecExpr? e%801) (let ([xs_ (vector-ref e%801 1)] [ls_ (vector-ref e%801 2)] [b_ (vector-ref e%801 3)]) (make-LinLetRecExpr xs_ (map1 (lambda (l%810) (if (is-Abstraction-val? l%810) (let ([lam_ (vector-ref l%810 1)]) (make-Abstraction-val (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%810)))) (if (is-Abstraction-box? l%810) (let ([lam_ (vector-ref l%810 1)]) (make-Abstraction-box (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%810)))) (error 'linearize-expression1 "invalid letrec header: ~s" l%810)))) ls_) (linearize-expression1 b_ level%802 k%803))) (if (is-Assign? e%801) (let ([x_ (vector-ref e%801 1)] [e_ (vector-ref e%801 2)]) (linearize-expression2 e_ level%802 (lambda (v%811 new-level%812) (make-LinBindCmp level%802 (make-LinAssign x_ v%811) (make-LinApplication (make-LinVariableJoin k%803) (list (make-LinVariableTmp level%802))))))) (error 'linearize-expression1 "quasar: ~s" e%801)))))))))))
(define linearize-expression1-seq (lambda (e%813 es%814 level%815 k%816) (letrec ([traverse%817 (lambda (e%818 es%819) (if (null? es%819) (linearize-expression1 e%818 level%815 k%816) (linearize-expression3 e%818 level%815 (lambda () (traverse%817 (car es%819) (cdr es%819))))))]) (traverse%817 e%813 es%814))))
(define linearize-expression2 (lambda (e%820 level%821 kappa%822) (if (is-Literal? e%820) (let ([l_ (vector-ref e%820 1)]) (kappa%822 (make-LinLiteral l_) level%821)) (if (is-Variable? e%820) (let ([x_ (vector-ref e%820 1)]) (kappa%822 (make-LinVariable x_) level%821)) (if (is-Abstraction? e%820) (let ([xs_ (vector-ref e%820 1)] [b_ (vector-ref e%820 2)]) (make-LinBindVal level%821 (make-LinAbstraction xs_ (linearize-expression0 b_)) (kappa%822 (make-LinVariableTmp level%821) (+ level%821 1)))) (if (is-IfThenElse? e%820) (let ([test-exp_ (vector-ref e%820 1)] [then-exp_ (vector-ref e%820 2)] [else-exp_ (vector-ref e%820 3)]) (let ([x%823 (gensym! "join%")]) (make-LinBindJoin level%821 (make-LinAbstraction (list x%823) (kappa%822 (make-LinVariable x%823) 0)) (let ([new-level%824 (+ level%821 1)]) (linearize-expression22 test-exp_ new-level%824 (lambda () (linearize-expression1 then-exp_ new-level%824 level%821)) (lambda () (linearize-expression1 else-exp_ new-level%824 level%821))))))) (if (is-Application? e%820) (let ([e_ (vector-ref e%820 1)] [es_ (vector-ref e%820 2)]) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (linearize-expression2s es_ level%821 (lambda (vs%825 level_vs%826) (make-LinApplication (make-LinAbstraction xs_ (linearize-expression2 b_ level%821 kappa%822)) vs%825)))) (linearize-expression2 e_ level%821 (lambda (v%827 level_e%828) (linearize-expression2s es_ level_e%828 (lambda (vs%829 level_es%830) (make-LinBindCmp level%821 (make-LinApplication v%827 vs%829) (kappa%822 (make-LinVariableTmp level%821) (+ level%821 1))))))))) (if (is-SequenceExpr2? e%820) (let ([e_ (vector-ref e%820 1)] [es_ (vector-ref e%820 2)]) (linearize-expression2seq e_ es_ level%821 kappa%822)) (if (is-LetRecExpr? e%820) (let ([xs_ (vector-ref e%820 1)] [ls_ (vector-ref e%820 2)] [b_ (vector-ref e%820 3)]) (make-LinLetRecExpr xs_ (map1 (lambda (l%831) (if (is-Abstraction-val? l%831) (let ([lam_ (vector-ref l%831 1)]) (make-Abstraction-val (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%831)))) (if (is-Abstraction-box? l%831) (let ([lam_ (vector-ref l%831 1)]) (make-Abstraction-box (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%831)))) (error 'linearize-expression2 "invalid letrec header: ~s" l%831)))) ls_) (linearize-expression2 b_ level%821 kappa%822))) (if (is-Assign? e%820) (let ([x_ (vector-ref e%820 1)] [e_ (vector-ref e%820 2)]) (linearize-expression2 e_ level%821 (lambda (v%832 new-level%833) (make-LinBindCmp level%821 (make-LinAssign x_ v%832) (kappa%822 (make-LinVariableTmp level%821) level%821))))) (error 'linearize-expression2 "quasar: ~s" e%820)))))))))))
(define linearize-expression2s (lambda (es%834 level%835 kappa%836) (if (null? es%834) (kappa%836 '() level%835) (linearize-expression2 (car es%834) level%835 (lambda (v%837 new-level%838) (linearize-expression2s (cdr es%834) new-level%838 (lambda (vs%839 resulting-level%840) (kappa%836 (cons v%837 vs%839) resulting-level%840))))))))
(define linearize-expression2seq (lambda (e%841 es%842 level%843 kappa%844) (letrec ([traverse%845 (lambda (e%846 es%847) (if (null? es%847) (linearize-expression2 e%846 level%843 kappa%844) (linearize-expression3 e%846 level%843 (lambda () (traverse%845 (car es%847) (cdr es%847))))))]) (traverse%845 e%841 es%842))))
(define linearize-expression22 (lambda (e%848 level%849 thunk-if-true%850 thunk-if-false%851) (if (is-Literal? e%848) (let ([l_ (vector-ref e%848 1)]) (if (is-Boolean? l_) (let ([b_ (vector-ref l_ 1)]) (if b_ (thunk-if-true%850) (thunk-if-false%851))) (thunk-if-true%850))) (if (is-Variable? e%848) (let ([x_ (vector-ref e%848 1)]) (make-LinIfThenElse (make-LinVariable x_) (thunk-if-true%850) (thunk-if-false%851))) (if (is-Abstraction? e%848) (let ([xs_ (vector-ref e%848 1)] [b_ (vector-ref e%848 2)]) (thunk-if-true%850)) (if (is-IfThenElse? e%848) (let ([test-exp_ (vector-ref e%848 1)] [then-exp_ (vector-ref e%848 2)] [else-exp_ (vector-ref e%848 3)]) (let ([x%852 (gensym! "join%")]) (make-LinBindJoin level%849 (make-LinAbstraction (list x%852) (make-LinIfThenElse (make-LinVariable x%852) (thunk-if-true%850) (thunk-if-false%851))) (let ([new-level%853 (+ level%849 1)]) (linearize-expression22 test-exp_ new-level%853 (lambda () (linearize-expression1 then-exp_ new-level%853 level%849)) (lambda () (linearize-expression1 else-exp_ new-level%853 level%849))))))) (if (is-Application? e%848) (let ([e_ (vector-ref e%848 1)] [es_ (vector-ref e%848 2)]) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (linearize-expression2s es_ level%849 (lambda (vs%854 level_vs%855) (make-LinApplication (make-LinAbstraction xs_ (linearize-expression22 b_ level%849 thunk-if-true%850 thunk-if-false%851)) vs%854)))) (linearize-expression2 e_ level%849 (lambda (v%856 level_e%857) (linearize-expression2s es_ level_e%857 (lambda (vs%858 level_es%859) (make-LinBindCmp level%849 (make-LinApplication v%856 vs%858) (make-LinIfThenElse (make-LinVariableTmp level%849) (thunk-if-true%850) (thunk-if-false%851))))))))) (if (is-SequenceExpr2? e%848) (let ([e_ (vector-ref e%848 1)] [es_ (vector-ref e%848 2)]) (linearize-expression22-seq e_ es_ level%849 thunk-if-true%850 thunk-if-false%851)) (if (is-LetRecExpr? e%848) (let ([xs_ (vector-ref e%848 1)] [ls_ (vector-ref e%848 2)] [b_ (vector-ref e%848 3)]) (make-LinLetRecExpr xs_ (map1 (lambda (l%860) (if (is-Abstraction-val? l%860) (let ([lam_ (vector-ref l%860 1)]) (make-Abstraction-val (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%860)))) (if (is-Abstraction-box? l%860) (let ([lam_ (vector-ref l%860 1)]) (make-Abstraction-box (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%860)))) (error 'linearize-expression22 "invalid letrec header: ~s" l%860)))) ls_) (linearize-expression22 b_ level%849 thunk-if-true%850 thunk-if-false%851))) (if (is-Assign? e%848) (let ([x_ (vector-ref e%848 1)] [e_ (vector-ref e%848 2)]) (linearize-expression2 e_ level%849 (lambda (v%861 new-level%862) (make-LinBindCmp level%849 (make-LinAssign x_ v%861) (thunk-if-true%850))))) (error 'linearize-expression22 "quasar: ~s" e%848)))))))))))
(define linearize-expression22-seq (lambda (e%863 es%864 level%865 thunk-if-true%866 thunk-if-false%867) (letrec ([traverse%868 (lambda (e%869 es%870) (if (null? es%870) (linearize-expression22 e%869 level%865 thunk-if-true%866 thunk-if-false%867) (linearize-expression3 e%869 level%865 (lambda () (traverse%868 (car es%870) (cdr es%870))))))]) (traverse%868 e%863 es%864))))
(define linearize-expression3 (lambda (e%871 level%872 kappa%873) (if (is-Literal? e%871) (let ([l_ (vector-ref e%871 1)]) (kappa%873)) (if (is-Variable? e%871) (let ([x_ (vector-ref e%871 1)]) (kappa%873)) (if (is-Abstraction? e%871) (let ([xs_ (vector-ref e%871 1)] [b_ (vector-ref e%871 2)]) (kappa%873)) (if (is-IfThenElse? e%871) (let ([test-exp_ (vector-ref e%871 1)] [then-exp_ (vector-ref e%871 2)] [else-exp_ (vector-ref e%871 3)]) (let ([x%874 (gensym! "join%")]) (make-LinBindJoin level%872 (make-LinAbstraction (list x%874) (kappa%873)) (let ([new-level%875 (+ level%872 1)]) (linearize-expression22 test-exp_ new-level%875 (lambda () (linearize-expression1 then-exp_ new-level%875 level%872)) (lambda () (linearize-expression1 else-exp_ new-level%875 level%872))))))) (if (is-Application? e%871) (let ([e_ (vector-ref e%871 1)] [es_ (vector-ref e%871 2)]) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (linearize-expression2s es_ level%872 (lambda (vs%876 level_vs%877) (make-LinApplication (make-LinAbstraction xs_ (linearize-expression3 b_ level%872 kappa%873)) vs%876)))) (linearize-expression2 e_ level%872 (lambda (v%878 level_e%879) (linearize-expression2s es_ level_e%879 (lambda (vs%880 level_es%881) (make-LinSeq level%872 (make-LinApplication v%878 vs%880) (kappa%873)))))))) (if (is-SequenceExpr2? e%871) (let ([e_ (vector-ref e%871 1)] [es_ (vector-ref e%871 2)]) (letrec ([traverse%882 (lambda (e%883 es%884) (if (null? es%884) (linearize-expression3 e%883 level%872 kappa%873) (linearize-expression3 e%883 level%872 (lambda () (traverse%882 (car es%884) (cdr es%884))))))]) (traverse%882 e_ es_))) (if (is-LetRecExpr? e%871) (let ([xs_ (vector-ref e%871 1)] [ls_ (vector-ref e%871 2)] [b_ (vector-ref e%871 3)]) (make-LinLetRecExpr xs_ (map1 (lambda (l%885) (if (is-Abstraction-val? l%885) (let ([lam_ (vector-ref l%885 1)]) (make-Abstraction-val (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%885)))) (if (is-Abstraction-box? l%885) (let ([lam_ (vector-ref l%885 1)]) (make-Abstraction-box (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%885)))) (error 'linearize-expression2 "invalid letrec header: ~s" l%885)))) ls_) (linearize-expression3 b_ level%872 kappa%873))) (if (is-Assign? e%871) (let ([x_ (vector-ref e%871 1)] [e_ (vector-ref e%871 2)]) (linearize-expression2 e_ level%872 (lambda (v%886 new-level%887) (make-LinSeq level%872 (make-LinAssign x_ v%886) (kappa%873))))) (error 'linearize-expression3 "quasar: ~s" e%871)))))))))))
(define linearize-definitions (lambda (ds%888) (letrec ([walk%889 (lambda (ds%890) (if (null? ds%890) '() (let ([case-record%891 (car ds%890)]) (if (is-DefExp? case-record%891) (let ([name_ (vector-ref case-record%891 1)] [expression_ (vector-ref case-record%891 2)]) (cons (make-LinDefExp name_ (linearize-definiens expression_ name_)) (walk%889 (cdr ds%890)))) (error 'linearize-definitions "not a definition: ~s" (car ds%890))))))]) (walk%889 ds%888))))
(define linearize-definiens (lambda (e%892 x%893) (if (is-Literal? e%892) (let ([l_ (vector-ref e%892 1)]) (make-LinAssign x%893 (make-LinLiteral l_))) (if (is-Variable? e%892) (let ([xp_ (vector-ref e%892 1)]) (make-LinAssign x%893 (make-LinVariable xp_))) (if (is-Abstraction? e%892) (let ([xs_ (vector-ref e%892 1)] [b_ (vector-ref e%892 2)]) (make-LinAssignLam x%893 (make-LinAbstraction xs_ (linearize-expression0 b_)))) (if (is-IfThenElse? e%892) (let ([test-exp_ (vector-ref e%892 1)] [then-exp_ (vector-ref e%892 2)] [else-exp_ (vector-ref e%892 3)]) (make-LinBindVal 0 (make-LinAbstraction '() (linearize-expression22 test-exp_ 0 (lambda () (linearize-expression0 then-exp_)) (lambda () (linearize-expression0 else-exp_)))) (make-LinAssignApp x%893 (make-LinApplication (make-LinVariableTmp 0) '())))) (if (is-Application? e%892) (let ([e_ (vector-ref e%892 1)] [es_ (vector-ref e%892 2)]) (if (is-Abstraction? e_) (let ([xs_ (vector-ref e_ 1)] [b_ (vector-ref e_ 2)]) (linearize-expression2s es_ 0 (lambda (vs%894 level_vs%895) (make-LinApplication (make-LinAbstraction xs_ (linearize-definiens b_ x%893)) vs%894)))) (linearize-expression2 e_ 0 (lambda (v%896 level_e%897) (linearize-expression2s es_ level_e%897 (lambda (vs%898 level_es%899) (make-LinAssignApp x%893 (make-LinApplication v%896 vs%898)))))))) (if (is-SequenceExpr2? e%892) (let ([e_ (vector-ref e%892 1)] [es_ (vector-ref e%892 2)]) (letrec ([traverse%900 (lambda (e%901 es%902) (if (null? es%902) (linearize-definiens e%901 x%893) (linearize-expression3 e%901 0 (lambda () (traverse%900 (car es%902) (cdr es%902))))))]) (traverse%900 e_ es_))) (if (is-LetRecExpr? e%892) (let ([xs_ (vector-ref e%892 1)] [ls_ (vector-ref e%892 2)] [b_ (vector-ref e%892 3)]) (make-LinLetRecExpr xs_ (map1 (lambda (l%903) (if (is-Abstraction-val? l%903) (let ([lam_ (vector-ref l%903 1)]) (make-Abstraction-val (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%903)))) (if (is-Abstraction-box? l%903) (let ([lam_ (vector-ref l%903 1)]) (make-Abstraction-box (if (is-Abstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-LinAbstraction xs_ (linearize-expression0 b_))) (error 'linearize-expression1 "invalid letrec header: ~s" l%903)))) (error 'linearize-expression2 "invalid letrec header: ~s" l%903)))) ls_) (linearize-definiens b_ x%893))) (if (is-Assign? e%892) (let ([x_ (vector-ref e%892 1)] [e_ (vector-ref e%892 2)]) (linearize-expression2 e_ 0 (lambda (v%904 new-level%905) (make-LinBindCmp 0 (make-LinAssign x_ v%904) (make-LinAssign x_ (make-LinLiteral (make-Nil))))))) (error 'linearize-definiens "quasar: ~s" e%892)))))))))))
(define linearize-program (lambda (p%906) (if (is-Boxed-Program? p%906) (let ([the-definitions_ (vector-ref p%906 1)] [the-expression_ (vector-ref p%906 2)]) (begin (warn "Linearizing") (let* ([ds%907 (linearize-definitions the-definitions_)] [e%908 (linearize-expression0 the-expression_)]) (begin (warnl " / Linearized") (make-Linearized-Program ds%907 e%908))))) (error 'linearized-program "not a boxed program"))))
(define make-Scoped-Program (lambda (the-definitions_ the-expression_) (vector 'Scoped-Program the-definitions_ the-expression_)))
(define is-Scoped-Program? (lambda (record%909) (if (vector? record%909) (if (= (vector-length record%909) 3) (eqv? (vector-ref record%909 0) 'Scoped-Program) #f) #f)))
(define make-ScoDefExp (lambda (x_ e_) (vector 'ScoDefExp x_ e_)))
(define is-ScoDefExp? (lambda (record%910) (if (vector? record%910) (if (= (vector-length record%910) 3) (eqv? (vector-ref record%910 0) 'ScoDefExp) #f) #f)))
(define make-ScoLiteral (lambda (l_) (vector 'ScoLiteral l_)))
(define is-ScoLiteral? (lambda (record%911) (if (vector? record%911) (if (= (vector-length record%911) 2) (eqv? (vector-ref record%911 0) 'ScoLiteral) #f) #f)))
(define make-ScoVariable (lambda (x_ kind_ offset_) (vector 'ScoVariable x_ kind_ offset_)))
(define is-ScoVariable? (lambda (record%912) (if (vector? record%912) (if (= (vector-length record%912) 4) (eqv? (vector-ref record%912 0) 'ScoVariable) #f) #f)))
(define make-ScoVariableTmp (lambda (int_) (vector 'ScoVariableTmp int_)))
(define is-ScoVariableTmp? (lambda (record%913) (if (vector? record%913) (if (= (vector-length record%913) 2) (eqv? (vector-ref record%913 0) 'ScoVariableTmp) #f) #f)))
(define make-ScoVariableJoin (lambda (int_) (vector 'ScoVariableJoin int_)))
(define is-ScoVariableJoin? (lambda (record%914) (if (vector? record%914) (if (= (vector-length record%914) 2) (eqv? (vector-ref record%914 0) 'ScoVariableJoin) #f) #f)))
(define make-ScoAbstraction-deep (lambda (xs_ b_) (vector 'ScoAbstraction-deep xs_ b_)))
(define is-ScoAbstraction-deep? (lambda (record%915) (if (vector? record%915) (if (= (vector-length record%915) 3) (eqv? (vector-ref record%915 0) 'ScoAbstraction-deep) #f) #f)))
(define make-ScoAbstraction-flat (lambda (xs_ b_ freevars_) (vector 'ScoAbstraction-flat xs_ b_ freevars_)))
(define is-ScoAbstraction-flat? (lambda (record%916) (if (vector? record%916) (if (= (vector-length record%916) 4) (eqv? (vector-ref record%916 0) 'ScoAbstraction-flat) #f) #f)))
(define make-ScoIfThenElse (lambda (test-exp_ then-exp_ else-exp_) (vector 'ScoIfThenElse test-exp_ then-exp_ else-exp_)))
(define is-ScoIfThenElse? (lambda (record%917) (if (vector? record%917) (if (= (vector-length record%917) 4) (eqv? (vector-ref record%917 0) 'ScoIfThenElse) #f) #f)))
(define make-ScoApplication (lambda (e_ es_) (vector 'ScoApplication e_ es_)))
(define is-ScoApplication? (lambda (record%918) (if (vector? record%918) (if (= (vector-length record%918) 3) (eqv? (vector-ref record%918 0) 'ScoApplication) #f) #f)))
(define make-ScoLetRecExpr (lambda (xs_ ls_ b_) (vector 'ScoLetRecExpr xs_ ls_ b_)))
(define is-ScoLetRecExpr? (lambda (record%919) (if (vector? record%919) (if (= (vector-length record%919) 4) (eqv? (vector-ref record%919 0) 'ScoLetRecExpr) #f) #f)))
(define make-ScoAssign (lambda (int_ v_) (vector 'ScoAssign int_ v_)))
(define is-ScoAssign? (lambda (record%920) (if (vector? record%920) (if (= (vector-length record%920) 3) (eqv? (vector-ref record%920 0) 'ScoAssign) #f) #f)))
(define make-ScoAssignLam (lambda (int_ l_) (vector 'ScoAssignLam int_ l_)))
(define is-ScoAssignLam? (lambda (record%921) (if (vector? record%921) (if (= (vector-length record%921) 3) (eqv? (vector-ref record%921 0) 'ScoAssignLam) #f) #f)))
(define make-ScoAssignApp (lambda (int_ c_) (vector 'ScoAssignApp int_ c_)))
(define is-ScoAssignApp? (lambda (record%922) (if (vector? record%922) (if (= (vector-length record%922) 3) (eqv? (vector-ref record%922 0) 'ScoAssignApp) #f) #f)))
(define make-ScoBindCmp (lambda (int_ c_ b_) (vector 'ScoBindCmp int_ c_ b_)))
(define is-ScoBindCmp? (lambda (record%923) (if (vector? record%923) (if (= (vector-length record%923) 4) (eqv? (vector-ref record%923 0) 'ScoBindCmp) #f) #f)))
(define make-ScoBindVal (lambda (int_ v_ b_) (vector 'ScoBindVal int_ v_ b_)))
(define is-ScoBindVal? (lambda (record%924) (if (vector? record%924) (if (= (vector-length record%924) 4) (eqv? (vector-ref record%924 0) 'ScoBindVal) #f) #f)))
(define make-ScoReturn (lambda (v_) (vector 'ScoReturn v_)))
(define is-ScoReturn? (lambda (record%925) (if (vector? record%925) (if (= (vector-length record%925) 2) (eqv? (vector-ref record%925 0) 'ScoReturn) #f) #f)))
(define make-ScoBindJoin (lambda (int_ c_ b_) (vector 'ScoBindJoin int_ c_ b_)))
(define is-ScoBindJoin? (lambda (record%926) (if (vector? record%926) (if (= (vector-length record%926) 4) (eqv? (vector-ref record%926 0) 'ScoBindJoin) #f) #f)))
(define make-ScoSeq (lambda (int_ c1_ c2_) (vector 'ScoSeq int_ c1_ c2_)))
(define is-ScoSeq? (lambda (record%927) (if (vector? record%927) (if (= (vector-length record%927) 4) (eqv? (vector-ref record%927 0) 'ScoSeq) #f) #f)))
(define compute-freevars (lambda (e%928 r%929 globals%930) (letrec ([walk-expression%931 (lambda (e%936 locals%937 a%938) (if (is-LinIfThenElse? e%936) (let ([test-exp_ (vector-ref e%936 1)] [then-exp_ (vector-ref e%936 2)] [else-exp_ (vector-ref e%936 3)]) (walk-value%932 test-exp_ locals%937 (walk-expression%931 then-exp_ locals%937 (walk-expression%931 else-exp_ locals%937 a%938)))) (if (is-LinApplication? e%936) (let ([v_ (vector-ref e%936 1)] [vs_ (vector-ref e%936 2)]) (walk-values%933 vs_ locals%937 (walk-value%932 v_ locals%937 a%938))) (if (is-LinLetRecExpr? e%936) (let ([xs_ (vector-ref e%936 1)] [ls_ (vector-ref e%936 2)] [b_ (vector-ref e%936 3)]) (let ([locals%939 (cons xs_ locals%937)]) (walk-expression%931 b_ locals%939 (walk-values-rec%934 ls_ locals%939 a%938)))) (if (is-LinBindCmp? e%936) (let ([i_ (vector-ref e%936 1)] [e_ (vector-ref e%936 2)] [b_ (vector-ref e%936 3)]) (walk-expression%931 b_ locals%937 (walk-named%935 e_ locals%937 a%938))) (if (is-LinBindVal? e%936) (let ([i_ (vector-ref e%936 1)] [v_ (vector-ref e%936 2)] [b_ (vector-ref e%936 3)]) (walk-expression%931 b_ locals%937 (walk-value%932 v_ locals%937 a%938))) (if (is-LinSeq? e%936) (let ([i_ (vector-ref e%936 1)] [e_ (vector-ref e%936 2)] [b_ (vector-ref e%936 3)]) (walk-expression%931 b_ locals%937 (walk-named%935 e_ locals%937 a%938))) (if (is-LinReturn? e%936) (let ([v_ (vector-ref e%936 1)]) (walk-value%932 v_ locals%937 a%938)) (if (is-LinBindJoin? e%936) (let ([i_ (vector-ref e%936 1)] [l_ (vector-ref e%936 2)] [b_ (vector-ref e%936 3)]) (walk-expression%931 b_ locals%937 (walk-value%932 l_ locals%937 a%938))) (if (is-LinAssign? e%936) (let ([x_ (vector-ref e%936 1)] [v_ (vector-ref e%936 2)]) (walk-value%932 v_ locals%937 a%938)) (if (is-LinAssignLam? e%936) (let ([x_ (vector-ref e%936 1)] [l_ (vector-ref e%936 2)]) (walk-value%932 l_ locals%937 a%938)) (if (is-LinAssignApp? e%936) (let ([x_ (vector-ref e%936 1)] [c_ (vector-ref e%936 2)]) (walk-expression%931 c_ locals%937 a%938)) (error 'compute-freevars "quasar: ~s" e%936)))))))))))))] [walk-value%932 (lambda (v%940 locals%941 a%942) (if (is-LinLiteral? v%940) (let ([l_ (vector-ref v%940 1)]) a%942) (if (is-LinVariable? v%940) (let ([x_ (vector-ref v%940 1)]) (if (ormap1 (lambda (xs%943) (member x_ xs%943)) locals%941) a%942 (if (ormap1 (lambda (xs%944) (member x_ xs%944)) r%929) (if (memq x_ a%942) a%942 (cons x_ a%942)) a%942))) (if (is-LinVariableTmp? v%940) (let ([i_ (vector-ref v%940 1)]) a%942) (if (is-LinVariableJoin? v%940) (let ([i_ (vector-ref v%940 1)]) a%942) (if (is-LinAbstraction? v%940) (let ([xs_ (vector-ref v%940 1)] [b_ (vector-ref v%940 2)]) (walk-expression%931 b_ (if (symbol? xs_) (cons (list xs_) locals%941) (cons xs_ locals%941)) a%942)) (error 'compute-freevars "quasar: ~s" e%928)))))))] [walk-values%933 (lambda (vs%945 locals%946 a%947) (if (null? vs%945) a%947 (walk-values%933 (cdr vs%945) locals%946 (walk-value%932 (car vs%945) locals%946 a%947))))] [walk-values-rec%934 (lambda (vs%948 locals%949 a%950) (if (null? vs%948) a%950 (walk-values-rec%934 (cdr vs%948) locals%949 (walk-value%932 (let ([case-record%951 (car vs%948)]) (if (is-Abstraction-val? case-record%951) (let ([lam_ (vector-ref case-record%951 1)]) lam_) (if (is-Abstraction-box? case-record%951) (let ([lam_ (vector-ref case-record%951 1)]) lam_) (error 'walk-values-rec "illegal header: ~s" (car vs%948))))) locals%949 a%950))))] [walk-named%935 (lambda (c%952 locals%953 a%954) (if (is-LinApplication? c%952) (let ([v_ (vector-ref c%952 1)] [vs_ (vector-ref c%952 2)]) (walk-values%933 vs_ locals%953 (walk-value%932 v_ locals%953 a%954))) (if (is-LinAssign? c%952) (let ([x_ (vector-ref c%952 1)] [v_ (vector-ref c%952 2)]) (walk-value%932 v_ locals%953 a%954)) (if (is-LinAbstraction? c%952) (let ([xs_ (vector-ref c%952 1)] [b_ (vector-ref c%952 2)]) (walk-expression%931 b_ (if (symbol? xs_) (cons (list xs_) locals%953) (cons xs_ locals%953)) a%954)) (error 'walk-named "not a named computation: ~s" c%952)))))]) (if (is-LinAbstraction? e%928) (let ([xs_ (vector-ref e%928 1)] [b_ (vector-ref e%928 2)]) (walk-expression%931 b_ (list (if (symbol? xs_) (list xs_) xs_)) '())) (error 'compute-freevars "not a lambda-abstraction: ~s" e%928)))))
(define extend-for (lambda (xs%955 r%956) (if (symbol? xs%955) (cons (list xs%955) r%956) (cons xs%955 r%956))))
(define ref-list-kind (lambda (xs%957 x%958) (letrec ([loop%959 (lambda (ys%960 offset%961) (if (null? ys%960) -1 (if (eqv? (car ys%960) x%958) offset%961 (loop%959 (cdr ys%960) (+ offset%961 1)))))]) (loop%959 xs%957 0))))
(define scope-lookup (lambda (x%962 r-orig%963 globals%964) (letrec ([walk%965 (lambda (lex%966 r%967) (if (null? r%967) (let ([offset%968 (ref-list-kind globals%964 x%962)]) (if (= offset%968 -1) (let ([offset%969 (ref-list-kind predefined-procedures x%962)]) (if (= offset%969 -1) (error 'scope-lookup "undeclared variable: ~s in ~s" x%962 r-orig%963) (make-ScoVariable x%962 'lib offset%969))) (make-ScoVariable x%962 'glo offset%968))) (let ([offset%970 (ref-list-kind (car r%967) x%962)]) (if (= offset%970 -1) (walk%965 (+ lex%966 1) (cdr r%967)) (make-ScoVariable x%962 lex%966 offset%970)))))]) (walk%965 0 r-orig%963))))
(define scope-value (lambda (e%971 r%972 globals%973) (if (is-LinLiteral? e%971) (let ([l_ (vector-ref e%971 1)]) (make-ScoLiteral l_)) (if (is-LinVariable? e%971) (let ([x_ (vector-ref e%971 1)]) (scope-lookup x_ r%972 globals%973)) (if (is-LinVariableTmp? e%971) (let ([i_ (vector-ref e%971 1)]) (make-ScoVariableTmp i_)) (if (is-LinVariableJoin? e%971) (let ([i_ (vector-ref e%971 1)]) (make-ScoVariableJoin i_)) (if (is-LinAbstraction? e%971) (let ([xs_ (vector-ref e%971 1)] [b_ (vector-ref e%971 2)]) (let ([freevars%974 (compute-freevars e%971 r%972 globals%973)]) (make-ScoAbstraction-flat xs_ (scope-expression b_ (list (if (symbol? xs_) (list xs_) xs_) freevars%974) globals%973) (map (lambda (freevar%975) (scope-lookup freevar%975 r%972 '())) freevars%974)))) (error 'scope-value "quasar: ~s" e%971))))))))
(define scope-expression (lambda (e%976 r%977 globals%978) (if (is-LinIfThenElse? e%976) (let ([test-exp_ (vector-ref e%976 1)] [then-exp_ (vector-ref e%976 2)] [else-exp_ (vector-ref e%976 3)]) (make-ScoIfThenElse (scope-value test-exp_ r%977 globals%978) (scope-expression then-exp_ r%977 globals%978) (scope-expression else-exp_ r%977 globals%978))) (if (is-LinApplication? e%976) (let ([v_ (vector-ref e%976 1)] [vs_ (vector-ref e%976 2)]) (scope-application v_ (map (lambda (v%979) (scope-value v%979 r%977 globals%978)) vs_) r%977 globals%978)) (if (is-LinLetRecExpr? e%976) (let ([xs_ (vector-ref e%976 1)] [ls_ (vector-ref e%976 2)] [b_ (vector-ref e%976 3)]) (let ([ext-r%980 (cons xs_ r%977)]) (make-ScoLetRecExpr xs_ (map (lambda (l%981) (if (is-Abstraction-val? l%981) (let ([lam_ (vector-ref l%981 1)]) (make-Abstraction-val (if (is-LinAbstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-ScoAbstraction-deep xs_ (scope-expression b_ (extend-for xs_ ext-r%980) globals%978))) (error 'scope-expression "illegal header: ~s" lam_)))) (if (is-Abstraction-box? l%981) (let ([lam_ (vector-ref l%981 1)]) (make-Abstraction-box (if (is-LinAbstraction? lam_) (let ([xs_ (vector-ref lam_ 1)] [b_ (vector-ref lam_ 2)]) (make-ScoAbstraction-deep xs_ (scope-expression b_ (extend-for xs_ ext-r%980) globals%978))) (error 'scope-expression "illegal header: ~s" lam_)))) (error 'scope-expression "quasar: ~s" l%981)))) ls_) (scope-expression b_ ext-r%980 globals%978)))) (if (is-LinAssign? e%976) (let ([x_ (vector-ref e%976 1)] [v_ (vector-ref e%976 2)]) (let ([offset%982 (ref-list-kind globals%978 x_)]) (if (= offset%982 -1) (let ([offset%983 (ref-list-kind predefined-procedures x_)]) (if (= offset%983 -1) (error 'scope-expression "unrecognized variable: ~s" x_) (make-ScoAssign (cons 'lib offset%983) (scope-value v_ r%977 globals%978)))) (make-ScoAssign (cons 'glo offset%982) (scope-value v_ r%977 globals%978))))) (if (is-LinAssignLam? e%976) (let ([x_ (vector-ref e%976 1)] [l_ (vector-ref e%976 2)]) (let ([offset%984 (ref-list-kind globals%978 x_)]) (if (= offset%984 -1) (let ([offset%985 (ref-list-kind predefined-procedures x_)]) (if (= offset%985 -1) (error 'scope-expression "unrecognized variable: ~s" x_) (make-ScoAssignLam (cons 'lib offset%985) (if (is-LinAbstraction? l_) (let ([xs_ (vector-ref l_ 1)] [b_ (vector-ref l_ 2)]) (make-ScoAbstraction-deep xs_ (scope-expression b_ (extend-for xs_ r%977) globals%978))) (error 'scope-expression "not a lambda: ~s" l_))))) (make-ScoAssignLam (cons 'glo offset%984) (if (is-LinAbstraction? l_) (let ([xs_ (vector-ref l_ 1)] [b_ (vector-ref l_ 2)]) (make-ScoAbstraction-deep xs_ (scope-expression b_ (extend-for xs_ r%977) globals%978))) (error 'scope-expression "not a lambda: ~s" l_)))))) (if (is-LinAssignApp? e%976) (let ([x_ (vector-ref e%976 1)] [c_ (vector-ref e%976 2)]) (let ([offset%986 (ref-list-kind globals%978 x_)]) (if (= offset%986 -1) (let ([offset%987 (ref-list-kind predefined-procedures x_)]) (if (= offset%987 -1) (error 'scope-expression "unrecognized variable: ~s" x_) (make-ScoAssignApp (cons 'lib offset%987) (scope-expression c_ r%977 globals%978)))) (make-ScoAssignApp (cons 'glo offset%986) (scope-expression c_ r%977 globals%978))))) (if (is-LinBindCmp? e%976) (let ([i_ (vector-ref e%976 1)] [c_ (vector-ref e%976 2)] [b_ (vector-ref e%976 3)]) (make-ScoBindCmp i_ (scope-named c_ r%977 globals%978) (scope-expression b_ r%977 globals%978))) (if (is-LinBindVal? e%976) (let ([i_ (vector-ref e%976 1)] [v_ (vector-ref e%976 2)] [b_ (vector-ref e%976 3)]) (make-ScoBindVal i_ (scope-value v_ r%977 globals%978) (scope-expression b_ r%977 globals%978))) (if (is-LinReturn? e%976) (let ([v_ (vector-ref e%976 1)]) (make-ScoReturn (scope-value v_ r%977 globals%978))) (if (is-LinBindJoin? e%976) (let ([i_ (vector-ref e%976 1)] [l_ (vector-ref e%976 2)] [b_ (vector-ref e%976 3)]) (make-ScoBindJoin i_ (if (is-LinAbstraction? l_) (let ([xs_ (vector-ref l_ 1)] [b_ (vector-ref l_ 2)]) (make-ScoAbstraction-deep xs_ (scope-expression b_ (cons xs_ r%977) globals%978))) (error 'scope-expression "unexpected LinBindJoin expression: ~s" e%976)) (scope-expression b_ r%977 globals%978))) (if (is-LinSeq? e%976) (let ([i_ (vector-ref e%976 1)] [c1_ (vector-ref e%976 2)] [c2_ (vector-ref e%976 3)]) (make-ScoSeq i_ (scope-named c1_ r%977 globals%978) (scope-expression c2_ r%977 globals%978))) (error 'scope-expression "quasar: ~s" e%976))))))))))))))
(define scope-application (lambda (raw-v%988 cooked-vs%989 r%990 globals%991) (if (is-LinAbstraction? raw-v%988) (let ([xs_ (vector-ref raw-v%988 1)] [b_ (vector-ref raw-v%988 2)]) (make-ScoApplication (make-ScoAbstraction-deep xs_ (scope-expression b_ (cons xs_ r%990) globals%991)) cooked-vs%989)) (make-ScoApplication (scope-value raw-v%988 r%990 globals%991) cooked-vs%989))))
(define scope-named (lambda (c%992 r%993 globals%994) (if (is-LinApplication? c%992) (let ([v_ (vector-ref c%992 1)] [vs_ (vector-ref c%992 2)]) (scope-application v_ (map (lambda (v%995) (scope-value v%995 r%993 globals%994)) vs_) r%993 globals%994)) (if (is-LinAssign? c%992) (let ([x_ (vector-ref c%992 1)] [v_ (vector-ref c%992 2)]) (make-ScoAssign (let ([offset%996 (ref-list-kind globals%994 x_)]) (if (= offset%996 -1) (let ([offset%997 (ref-list-kind predefined-procedures x_)]) (if (= offset%997 -1) (error 'scope-named "undeclared variable: ~s" x_) (cons 'lib offset%997))) (cons 'glo offset%996))) (scope-value v_ r%993 globals%994))) (if (is-LinAbstraction? c%992) (let ([xs_ (vector-ref c%992 1)] [b_ (vector-ref c%992 2)]) (let ([freevars%998 (compute-freevars c%992 r%993 globals%994)]) (make-ScoAbstraction-flat xs_ (scope-expression b_ (list (if (symbol? xs_) (list xs_) xs_) freevars%998) globals%994) (map (lambda (freevar%999) (scope-lookup freevar%999 r%993 '())) freevars%998)))) (error 'scope-named "not a named computation: ~s" c%992))))))
(define scope-program (lambda (p%1000) (if (is-Linearized-Program? p%1000) (let ([the-definitions_ (vector-ref p%1000 1)] [the-expression_ (vector-ref p%1000 2)]) (begin (warn "Scoping") (let ([globals%1001 (letrec ([walk%1002 (lambda (ds%1003 globals%1004) (if (null? ds%1003) (reverse globals%1004) (let ([case-record%1005 (car ds%1003)]) (if (is-LinDefExp? case-record%1005) (let ([x_ (vector-ref case-record%1005 1)] [e_ (vector-ref case-record%1005 2)]) (walk%1002 (cdr ds%1003) (if (let ([or%1006 (member x_ globals%1004)]) (if or%1006 or%1006 (member x_ predefined-procedures))) (begin (if (let ([or%1007 (eqv? x_ 'call-with-input-file)]) (if or%1007 or%1007 (eqv? x_ 'call-with-output-file))) "Sic transit." (warn (format " Multiple definition for ~s" x_))) globals%1004) (cons x_ globals%1004)))) (error 'scope-program "not a definition: ~s" (car ds%1003))))))]) (walk%1002 the-definitions_ '()))]) (let* ([ds%1008 (map1 (lambda (d%1009) (if (is-LinDefExp? d%1009) (let ([x_ (vector-ref d%1009 1)] [e_ (vector-ref d%1009 2)]) (make-ScoDefExp x_ (scope-expression e_ '() globals%1001))) (error 'scope-program "not a definition: ~s" d%1009))) the-definitions_)] [e%1010 (scope-expression the-expression_ '() globals%1001)]) (begin (warnl " / Scoped") (make-Scoped-Program ds%1008 e%1010)))))) (error 'scope-program "not a linearized program"))))
(define make-Factorized-Program (lambda (the-definitions_ the-expression_ the-lambda-headers_ the-lambda-bodies_) (vector 'Factorized-Program the-definitions_ the-expression_ the-lambda-headers_ the-lambda-bodies_)))
(define is-Factorized-Program? (lambda (record%1011) (if (vector? record%1011) (if (= (vector-length record%1011) 5) (eqv? (vector-ref record%1011 0) 'Factorized-Program) #f) #f)))
(define make-FacDefExp (lambda (x_ e_) (vector 'FacDefExp x_ e_)))
(define is-FacDefExp? (lambda (record%1012) (if (vector? record%1012) (if (= (vector-length record%1012) 3) (eqv? (vector-ref record%1012 0) 'FacDefExp) #f) #f)))
(define make-FacLiteral (lambda (l_) (vector 'FacLiteral l_)))
(define is-FacLiteral? (lambda (record%1013) (if (vector? record%1013) (if (= (vector-length record%1013) 2) (eqv? (vector-ref record%1013 0) 'FacLiteral) #f) #f)))
(define make-FacVariable (lambda (x_ kind_ offset_) (vector 'FacVariable x_ kind_ offset_)))
(define is-FacVariable? (lambda (record%1014) (if (vector? record%1014) (if (= (vector-length record%1014) 4) (eqv? (vector-ref record%1014 0) 'FacVariable) #f) #f)))
(define make-FacVariableTmp (lambda (int_) (vector 'FacVariableTmp int_)))
(define is-FacVariableTmp? (lambda (record%1015) (if (vector? record%1015) (if (= (vector-length record%1015) 2) (eqv? (vector-ref record%1015 0) 'FacVariableTmp) #f) #f)))
(define make-FacVariableJoin (lambda (int_) (vector 'FacVariableJoin int_)))
(define is-FacVariableJoin? (lambda (record%1016) (if (vector? record%1016) (if (= (vector-length record%1016) 2) (eqv? (vector-ref record%1016 0) 'FacVariableJoin) #f) #f)))
(define make-FacAbstraction-stay (lambda (xs_ body_) (vector 'FacAbstraction-stay xs_ body_)))
(define is-FacAbstraction-stay? (lambda (record%1017) (if (vector? record%1017) (if (= (vector-length record%1017) 3) (eqv? (vector-ref record%1017 0) 'FacAbstraction-stay) #f) #f)))
(define make-FacAbstraction-deep (lambda (index-in-global-table-of-lambdas_) (vector 'FacAbstraction-deep index-in-global-table-of-lambdas_)))
(define is-FacAbstraction-deep? (lambda (record%1018) (if (vector? record%1018) (if (= (vector-length record%1018) 2) (eqv? (vector-ref record%1018 0) 'FacAbstraction-deep) #f) #f)))
(define make-FacAbstraction-flat (lambda (index-in-global-table-of-lambdas_ freevars_) (vector 'FacAbstraction-flat index-in-global-table-of-lambdas_ freevars_)))
(define is-FacAbstraction-flat? (lambda (record%1019) (if (vector? record%1019) (if (= (vector-length record%1019) 3) (eqv? (vector-ref record%1019 0) 'FacAbstraction-flat) #f) #f)))
(define make-FacIfThenElse (lambda (test-exp_ then-exp_ else-exp_) (vector 'FacIfThenElse test-exp_ then-exp_ else-exp_)))
(define is-FacIfThenElse? (lambda (record%1020) (if (vector? record%1020) (if (= (vector-length record%1020) 4) (eqv? (vector-ref record%1020 0) 'FacIfThenElse) #f) #f)))
(define make-FacApplication (lambda (v_ vs_) (vector 'FacApplication v_ vs_)))
(define is-FacApplication? (lambda (record%1021) (if (vector? record%1021) (if (= (vector-length record%1021) 3) (eqv? (vector-ref record%1021 0) 'FacApplication) #f) #f)))
(define make-FacLetRecExpr (lambda (xs_ ls_ b_) (vector 'FacLetRecExpr xs_ ls_ b_)))
(define is-FacLetRecExpr? (lambda (record%1022) (if (vector? record%1022) (if (= (vector-length record%1022) 4) (eqv? (vector-ref record%1022 0) 'FacLetRecExpr) #f) #f)))
(define make-FacAssign (lambda (int_ v_) (vector 'FacAssign int_ v_)))
(define is-FacAssign? (lambda (record%1023) (if (vector? record%1023) (if (= (vector-length record%1023) 3) (eqv? (vector-ref record%1023 0) 'FacAssign) #f) #f)))
(define make-FacAssignLam (lambda (int_ l_) (vector 'FacAssignLam int_ l_)))
(define is-FacAssignLam? (lambda (record%1024) (if (vector? record%1024) (if (= (vector-length record%1024) 3) (eqv? (vector-ref record%1024 0) 'FacAssignLam) #f) #f)))
(define make-FacAssignApp (lambda (int_ c_) (vector 'FacAssignApp int_ c_)))
(define is-FacAssignApp? (lambda (record%1025) (if (vector? record%1025) (if (= (vector-length record%1025) 3) (eqv? (vector-ref record%1025 0) 'FacAssignApp) #f) #f)))
(define make-FacBindCmp (lambda (int_ c_ b_) (vector 'FacBindCmp int_ c_ b_)))
(define is-FacBindCmp? (lambda (record%1026) (if (vector? record%1026) (if (= (vector-length record%1026) 4) (eqv? (vector-ref record%1026 0) 'FacBindCmp) #f) #f)))
(define make-FacBindVal (lambda (int_ v_ b_) (vector 'FacBindVal int_ v_ b_)))
(define is-FacBindVal? (lambda (record%1027) (if (vector? record%1027) (if (= (vector-length record%1027) 4) (eqv? (vector-ref record%1027 0) 'FacBindVal) #f) #f)))
(define make-FacReturn (lambda (v_) (vector 'FacReturn v_)))
(define is-FacReturn? (lambda (record%1028) (if (vector? record%1028) (if (= (vector-length record%1028) 2) (eqv? (vector-ref record%1028 0) 'FacReturn) #f) #f)))
(define make-FacBindJoin (lambda (int_ c_ b_) (vector 'FacBindJoin int_ c_ b_)))
(define is-FacBindJoin? (lambda (record%1029) (if (vector? record%1029) (if (= (vector-length record%1029) 4) (eqv? (vector-ref record%1029 0) 'FacBindJoin) #f) #f)))
(define make-FacSeq (lambda (i_ c1_ c2_) (vector 'FacSeq i_ c1_ c2_)))
(define is-FacSeq? (lambda (record%1030) (if (vector? record%1030) (if (= (vector-length record%1030) 4) (eqv? (vector-ref record%1030 0) 'FacSeq) #f) #f)))
(define make-FacInteger (lambda (integer_) (vector 'FacInteger integer_)))
(define is-FacInteger? (lambda (record%1031) (if (vector? record%1031) (if (= (vector-length record%1031) 2) (eqv? (vector-ref record%1031 0) 'FacInteger) #f) #f)))
(define make-FacBoolean (lambda (boolean_) (vector 'FacBoolean boolean_)))
(define is-FacBoolean? (lambda (record%1032) (if (vector? record%1032) (if (= (vector-length record%1032) 2) (eqv? (vector-ref record%1032 0) 'FacBoolean) #f) #f)))
(define make-FacString (lambda (string_) (vector 'FacString string_)))
(define is-FacString? (lambda (record%1033) (if (vector? record%1033) (if (= (vector-length record%1033) 2) (eqv? (vector-ref record%1033 0) 'FacString) #f) #f)))
(define make-FacCharacter (lambda (character_) (vector 'FacCharacter character_)))
(define is-FacCharacter? (lambda (record%1034) (if (vector? record%1034) (if (= (vector-length record%1034) 2) (eqv? (vector-ref record%1034 0) 'FacCharacter) #f) #f)))
(define make-FacSymbol (lambda (symbol_) (vector 'FacSymbol symbol_)))
(define is-FacSymbol? (lambda (record%1035) (if (vector? record%1035) (if (= (vector-length record%1035) 2) (eqv? (vector-ref record%1035 0) 'FacSymbol) #f) #f)))
(define make-FacNil (lambda () (vector 'FacNil)))
(define is-FacNil? (lambda (record%1036) (if (vector? record%1036) (if (= (vector-length record%1036) 1) (eqv? (vector-ref record%1036 0) 'FacNil) #f) #f)))
(define make-FacVoid (lambda () (vector 'FacVoid)))
(define is-FacVoid? (lambda (record%1037) (if (vector? record%1037) (if (= (vector-length record%1037) 1) (eqv? (vector-ref record%1037 0) 'FacVoid) #f) #f)))
(define factorize-expression (lambda (e%1038 ilam%1039 lams%1040 k%1041) (if (is-ScoIfThenElse? e%1038) (let ([test-exp_ (vector-ref e%1038 1)] [then-exp_ (vector-ref e%1038 2)] [else-exp_ (vector-ref e%1038 3)]) (factorize-value test-exp_ ilam%1039 lams%1040 (lambda (test-exp%1042 ilam%1043 lams%1044) (factorize-expression then-exp_ ilam%1043 lams%1044 (lambda (then-exp%1045 ilam%1046 lams%1047) (factorize-expression else-exp_ ilam%1046 lams%1047 (lambda (else-exp%1048 ilam%1049 lams%1050) (k%1041 (make-FacIfThenElse test-exp%1042 then-exp%1045 else-exp%1048) ilam%1049 lams%1050)))))))) (if (is-ScoApplication? e%1038) (let ([v_ (vector-ref e%1038 1)] [vs_ (vector-ref e%1038 2)]) (if (is-ScoAbstraction-deep? v_) (let ([xs_ (vector-ref v_ 1)] [b_ (vector-ref v_ 2)]) (factorize-values vs_ ilam%1039 lams%1040 (lambda (vs%1051 ilam%1052 lams%1053) (factorize-expression b_ ilam%1052 lams%1053 (lambda (b%1054 ilam%1055 lams%1056) (k%1041 (make-FacApplication (make-FacAbstraction-stay xs_ b%1054) vs%1051) ilam%1055 lams%1056)))))) (factorize-value v_ ilam%1039 lams%1040 (lambda (v%1057 ilam%1058 lams%1059) (factorize-values vs_ ilam%1058 lams%1059 (lambda (vs%1060 ilam%1061 lams%1062) (k%1041 (make-FacApplication v%1057 vs%1060) ilam%1061 lams%1062))))))) (if (is-ScoLetRecExpr? e%1038) (let ([xs_ (vector-ref e%1038 1)] [ls_ (vector-ref e%1038 2)] [b_ (vector-ref e%1038 3)]) (factorize-expression b_ (+ ilam%1039 (length xs_)) (letrec ([append-reverse%1063 (lambda (ls%1064 lams%1065) (if (null? ls%1064) lams%1065 (append-reverse%1063 (cdr ls%1064) (cons (vector-ref (car ls%1064) 1) lams%1065))))]) (append-reverse%1063 ls_ lams%1040)) (lambda (b%1066 new-ilam%1067 new-lams%1068) (k%1041 (make-FacLetRecExpr xs_ (letrec ([make-list-of-lambdas%1069 (lambda (ls%1070 ilam%1071) (if (null? ls%1070) '() (cons (vector (vector-ref (car ls%1070) 0) ilam%1071) (make-list-of-lambdas%1069 (cdr ls%1070) (+ ilam%1071 1)))))]) (make-list-of-lambdas%1069 ls_ ilam%1039)) b%1066) new-ilam%1067 new-lams%1068)))) (if (is-ScoAssign? e%1038) (let ([x_ (vector-ref e%1038 1)] [v_ (vector-ref e%1038 2)]) (factorize-value v_ ilam%1039 lams%1040 (lambda (v%1072 ilam%1073 lams%1074) (k%1041 (make-FacAssign x_ v%1072) ilam%1073 lams%1074)))) (if (is-ScoAssignLam? e%1038) (let ([x_ (vector-ref e%1038 1)] [v_ (vector-ref e%1038 2)]) (factorize-value v_ ilam%1039 lams%1040 (lambda (v%1075 ilam%1076 lams%1077) (k%1041 (make-FacAssignLam x_ v%1075) ilam%1076 lams%1077)))) (if (is-ScoAssignApp? e%1038) (let ([x_ (vector-ref e%1038 1)] [c_ (vector-ref e%1038 2)]) (factorize-expression c_ ilam%1039 lams%1040 (lambda (c%1078 ilam%1079 lams%1080) (k%1041 (make-FacAssignApp x_ c%1078) ilam%1079 lams%1080)))) (if (is-ScoBindCmp? e%1038) (let ([i_ (vector-ref e%1038 1)] [c_ (vector-ref e%1038 2)] [b_ (vector-ref e%1038 3)]) (factorize-named c_ ilam%1039 lams%1040 (lambda (c%1081 ilam%1082 lams%1083) (factorize-expression b_ ilam%1082 lams%1083 (lambda (b%1084 ilam%1085 lams%1086) (k%1041 (make-FacBindCmp i_ c%1081 b%1084) ilam%1085 lams%1086)))))) (if (is-ScoBindVal? e%1038) (let ([i_ (vector-ref e%1038 1)] [v_ (vector-ref e%1038 2)] [b_ (vector-ref e%1038 3)]) (factorize-value v_ ilam%1039 lams%1040 (lambda (v%1087 ilam%1088 lams%1089) (factorize-expression b_ ilam%1088 lams%1089 (lambda (b%1090 ilam%1091 lams%1092) (k%1041 (make-FacBindVal i_ v%1087 b%1090) ilam%1091 lams%1092)))))) (if (is-ScoReturn? e%1038) (let ([v_ (vector-ref e%1038 1)]) (factorize-value v_ ilam%1039 lams%1040 (lambda (v%1093 ilam%1094 lams%1095) (k%1041 (make-FacReturn v%1093) ilam%1094 lams%1095)))) (if (is-ScoBindJoin? e%1038) (let ([i_ (vector-ref e%1038 1)] [l_ (vector-ref e%1038 2)] [b_ (vector-ref e%1038 3)]) (factorize-expression b_ (+ ilam%1039 1) (cons l_ lams%1040) (lambda (b%1096 new-ilam%1097 new-lams%1098) (k%1041 (make-FacBindJoin i_ (make-FacAbstraction-deep ilam%1039) b%1096) new-ilam%1097 new-lams%1098)))) (if (is-ScoSeq? e%1038) (let ([i_ (vector-ref e%1038 1)] [c1_ (vector-ref e%1038 2)] [c2_ (vector-ref e%1038 3)]) (factorize-named c1_ ilam%1039 lams%1040 (lambda (c1%1099 ilam%1100 lams%1101) (factorize-expression c2_ ilam%1100 lams%1101 (lambda (c2%1102 ilam%1103 lams%1104) (k%1041 (make-FacSeq i_ c1%1099 c2%1102) ilam%1103 lams%1104)))))) (error 'factorize-expression "quasar: ~s" e%1038))))))))))))))
(define factorize-value (lambda (v%1105 ilam%1106 lams%1107 k%1108) (if (is-ScoLiteral? v%1105) (let ([l_ (vector-ref v%1105 1)]) (if (is-Integer? l_) (let ([i_ (vector-ref l_ 1)]) (k%1108 (make-FacLiteral (make-FacInteger i_)) ilam%1106 lams%1107)) (if (is-Boolean? l_) (let ([b_ (vector-ref l_ 1)]) (k%1108 (make-FacLiteral (make-FacBoolean b_)) ilam%1106 lams%1107)) (if (is-String? l_) (let ([s_ (vector-ref l_ 1)]) (k%1108 (make-FacLiteral (make-FacString s_)) ilam%1106 lams%1107)) (if (is-Character? l_) (let ([c_ (vector-ref l_ 1)]) (k%1108 (make-FacLiteral (make-FacCharacter c_)) ilam%1106 lams%1107)) (if (is-Symbol? l_) (let ([s_ (vector-ref l_ 1)]) (k%1108 (make-FacLiteral (make-FacSymbol s_)) ilam%1106 lams%1107)) (if (is-Nil? l_) (let () (k%1108 (make-FacLiteral (make-FacNil)) ilam%1106 lams%1107)) (if (is-Void? l_) (let () (k%1108 (make-FacLiteral (make-FacVoid)) ilam%1106 lams%1107)) (error 'factorize-value "quasar: ~s" l_))))))))) (if (is-ScoVariable? v%1105) (let ([x_ (vector-ref v%1105 1)] [kind_ (vector-ref v%1105 2)] [offset_ (vector-ref v%1105 3)]) (k%1108 (make-FacVariable x_ kind_ offset_) ilam%1106 lams%1107)) (if (is-ScoVariableTmp? v%1105) (let ([i_ (vector-ref v%1105 1)]) (k%1108 (make-FacVariableTmp i_) ilam%1106 lams%1107)) (if (is-ScoVariableJoin? v%1105) (let ([i_ (vector-ref v%1105 1)]) (k%1108 (make-FacVariableJoin i_) ilam%1106 lams%1107)) (if (is-ScoAbstraction-flat? v%1105) (let ([xs_ (vector-ref v%1105 1)] [b_ (vector-ref v%1105 2)] [freevars_ (vector-ref v%1105 3)]) (k%1108 (make-FacAbstraction-flat ilam%1106 freevars_) (+ ilam%1106 1) (cons v%1105 lams%1107))) (if (is-ScoAbstraction-deep? v%1105) (let ([xs_ (vector-ref v%1105 1)] [b_ (vector-ref v%1105 2)]) (k%1108 (make-FacAbstraction-deep ilam%1106) (+ ilam%1106 1) (cons v%1105 lams%1107))) (error 'factorize-value "quasar: ~s" v%1105)))))))))
(define factorize-values (lambda (vs%1109 ilam%1110 lams%1111 k%1112) (if (null? vs%1109) (k%1112 '() ilam%1110 lams%1111) (factorize-value (car vs%1109) ilam%1110 lams%1111 (lambda (v%1113 ilam%1114 lams%1115) (factorize-values (cdr vs%1109) ilam%1114 lams%1115 (lambda (vs%1116 ilam%1117 lams%1118) (k%1112 (cons v%1113 vs%1116) ilam%1117 lams%1118))))))))
(define factorize-named (lambda (c%1119 ilam%1120 lams%1121 k%1122) (if (is-ScoApplication? c%1119) (let ([v_ (vector-ref c%1119 1)] [vs_ (vector-ref c%1119 2)]) (factorize-value v_ ilam%1120 lams%1121 (lambda (v%1123 ilam%1124 lams%1125) (factorize-values vs_ ilam%1124 lams%1125 (lambda (vs%1126 ilam%1127 lams%1128) (k%1122 (make-FacApplication v%1123 vs%1126) ilam%1127 lams%1128)))))) (if (is-ScoAssign? c%1119) (let ([x_ (vector-ref c%1119 1)] [v_ (vector-ref c%1119 2)]) (factorize-value v_ ilam%1120 lams%1121 (lambda (v%1129 ilam%1130 lams%1131) (k%1122 (make-FacAssign x_ v%1129) ilam%1130 lams%1131)))) (if (is-ScoAbstraction-flat? c%1119) (let ([xs_ (vector-ref c%1119 1)] [b_ (vector-ref c%1119 2)] [freevars_ (vector-ref c%1119 3)]) (k%1122 (make-FacAbstraction-flat ilam%1120 freevars_) (+ ilam%1120 1) (cons c%1119 lams%1121))) (error 'factorize-named "not a named computation: ~s" c%1119))))))
(define factorize-definitions (lambda (ds%1132 ilam%1133 lams%1134 k%1135) (letrec ([walk%1136 (lambda (ds%1137 ilam%1138 lams%1139 a%1140) (if (null? ds%1137) (k%1135 a%1140 ilam%1138 lams%1139) (let ([case-record%1141 (car ds%1137)]) (if (is-ScoDefExp? case-record%1141) (let ([x_ (vector-ref case-record%1141 1)] [e_ (vector-ref case-record%1141 2)]) (factorize-expression e_ ilam%1138 lams%1139 (lambda (e%1142 ilam%1143 lams%1144) (walk%1136 (cdr ds%1137) ilam%1143 lams%1144 (cons (make-FacDefExp x_ e%1142) a%1140))))) (error 'factorize-definitions "not a scoped definition: ~s" (car ds%1137))))))]) (walk%1136 ds%1132 ilam%1133 lams%1134 '()))))
(define factorize-finalize (lambda (ilam%1145 lams%1146 k%1147) (letrec ([iterate%1148 (lambda (index%1149 ls%1150 a%1151 ilam%1152 lams%1153 rest%1154) (if (null? ls%1150) (if (null? lams%1153) (if (= index%1149 ilam%1152) (k%1147 ilam%1152 a%1151 rest%1154) (error 'factorize-finalize "mismatching indices: ~s and ~s" index%1149 ilam%1152)) (iterate%1148 index%1149 (reverse lams%1153) a%1151 ilam%1152 '() rest%1154)) (let ([case-record%1155 (car ls%1150)]) (if (is-ScoAbstraction-flat? case-record%1155) (let ([xs_ (vector-ref case-record%1155 1)] [b_ (vector-ref case-record%1155 2)] [freevars_ (vector-ref case-record%1155 3)]) (factorize-expression b_ ilam%1152 lams%1153 (lambda (b%1156 ilam%1157 lams%1158) (let ([label%1159 (string->symbol (string-append "lambda-flat%" (integer->string index%1149)))]) (iterate%1148 (+ index%1149 1) (cdr ls%1150) (cons (list (if (symbol? xs_) -1 (length xs_)) label%1159) a%1151) ilam%1157 lams%1158 (cons (cons label%1159 b%1156) rest%1154)))))) (if (is-ScoAbstraction-deep? case-record%1155) (let ([xs_ (vector-ref case-record%1155 1)] [b_ (vector-ref case-record%1155 2)]) (factorize-expression b_ ilam%1152 lams%1153 (lambda (b%1160 ilam%1161 lams%1162) (let ([label%1163 (string->symbol (string-append "lambda-deep%" (integer->string index%1149)))]) (iterate%1148 (+ index%1149 1) (cdr ls%1150) (cons (list (if (symbol? xs_) -1 (length xs_)) label%1163) a%1151) ilam%1161 lams%1162 (cons (cons label%1163 b%1160) rest%1154)))))) (error 'factorize-program "not a lambda-abstraction: ~s" (car ls%1150)))))))]) (iterate%1148 0 (reverse lams%1146) '() ilam%1145 '() '()))))
(define factorize-program (lambda (p%1164) (if (is-Scoped-Program? p%1164) (let ([the-definitions_ (vector-ref p%1164 1)] [the-expression_ (vector-ref p%1164 2)]) (begin (warn "Factorizing") (factorize-definitions the-definitions_ 0 '() (lambda (ds%1165 ilam%1166 lams%1167) (factorize-expression the-expression_ ilam%1166 lams%1167 (lambda (e%1168 ilam%1169 lams%1170) (factorize-finalize ilam%1169 lams%1170 (lambda (ilam%1171 lams%1172 rest%1173) (begin (warnl " / Factorized") (make-Factorized-Program (reverse ds%1165) e%1168 (reverse lams%1172) (reverse rest%1173))))))))))) (error 'factorize-program "not a scoped program"))))
(define make-Compiled-Program (lambda (number-of-global-definitions_ number-of-temporaries_ number-of-results_ the-lambdas_ the-code_ the-tag_) (vector 'Compiled-Program number-of-global-definitions_ number-of-temporaries_ number-of-results_ the-lambdas_ the-code_ the-tag_)))
(define is-Compiled-Program? (lambda (record%1174) (if (vector? record%1174) (if (= (vector-length record%1174) 7) (eqv? (vector-ref record%1174 0) 'Compiled-Program) #f) #f)))
(define codegen-abstraction-flat (lambda (freevars%1175 a%1176) (letrec ([walk%1177 (lambda (xs%1178 i%1179) (if (null? xs%1178) a%1176 (cons (let ([case-record%1180 (car xs%1178)]) (if (is-ScoVariable? case-record%1180) (let ([x_ (vector-ref case-record%1180 1)] [lex_ (vector-ref case-record%1180 2)] [offset_ (vector-ref case-record%1180 3)]) (list 'move lex_ offset_ 'vec i%1179)) (error 'codegen-abstraction-flat "illegal free variable: ~s" (car xs%1178)))) (walk%1177 (cdr xs%1178) (+ i%1179 1)))))]) (walk%1177 freevars%1175 0))))
(define codegen-application (lambda (vs%1181 a%1182) (letrec ([walk%1183 (lambda (vs%1184 j%1185) (if (null? vs%1184) a%1182 (codegen-value (car vs%1184) (lambda (what%1186 S%1187 i%1188) (cons (list what%1186 S%1187 i%1188 'vec j%1185) (walk%1183 (cdr vs%1184) (+ j%1185 1)))))))]) (walk%1183 vs%1181 0))))
(define immutable%1196 (cons 'new-vec (cons 1 '())))
(define codegen-letrec (lambda (ls%1189 a%1190) (letrec ([walk%1191 (lambda (ls%1192 i%1193) (if (null? ls%1192) a%1190 (let ([case-record%1194 (car ls%1192)]) (if (is-Abstraction-val? case-record%1194) (let ([j_ (vector-ref case-record%1194 1)]) (cons (list 'load 'close-deep j_ 0 i%1193) (walk%1191 (cdr ls%1192) (+ i%1193 1)))) (if (is-Abstraction-box? case-record%1194) (let ([j_ (vector-ref case-record%1194 1)]) (let ([label%1195 (gensym! "letrec%")]) (cons immutable%1196 (cons (list 'load 'close-deep j_ 'vec 0) (cons (list 'call 'lib (ref-list-kind predefined-procedures 'vector) 0) (cons (list 'move 'res 0 0 i%1193) (walk%1191 (cdr ls%1192) (+ i%1193 1)))))))) (error 'codegen-letrec "not a deep abstraction: ~s" (car ls%1192)))))))]) (walk%1191 ls%1189 0))))
(define immutable%1222 (cons 'return '()))
(define immutable%1206 (cons 'extend '()))
(define immutable%1202 (cons 'extend '()))
(define codegen-expression (lambda (e%1197) (if (is-FacIfThenElse? e%1197) (let ([test-exp_ (vector-ref e%1197 1)] [then-exp_ (vector-ref e%1197 2)] [else-exp_ (vector-ref e%1197 3)]) (let ([else-label%1198 (gensym! "else%")]) (codegen-value test-exp_ (lambda (what%1199 S%1200 i%1201) (cons (list 'jump-if-false S%1200 i%1201 else-label%1198) (append (codegen-expression then-exp_) (cons (list 'label else-label%1198) (codegen-expression else-exp_)))))))) (if (is-FacApplication? e%1197) (let ([v_ (vector-ref e%1197 1)] [vs_ (vector-ref e%1197 2)]) (cons (list 'new-vec (length vs_)) (if (is-FacAbstraction-stay? v_) (let ([xs_ (vector-ref v_ 1)] [b_ (vector-ref v_ 2)]) (codegen-application vs_ (cons immutable%1202 (codegen-expression b_)))) (codegen-application vs_ (codegen-value v_ (lambda (what%1203 S%1204 i%1205) (if (eqv? what%1203 'move) (list (list 'tail-call S%1204 i%1205)) (error 'codegen-expression "unexpected tag: ~s" what%1203)))))))) (if (is-FacLetRecExpr? e%1197) (let ([xs_ (vector-ref e%1197 1)] [ls_ (vector-ref e%1197 2)] [b_ (vector-ref e%1197 3)]) (cons (list 'new-vec (length xs_)) (cons immutable%1206 (codegen-letrec ls_ (codegen-expression b_))))) (if (is-FacAssign? e%1197) (let ([x_ (vector-ref e%1197 1)] [v_ (vector-ref e%1197 2)]) (codegen-value v_ (lambda (what%1207 S%1208 i%1209) (list (list what%1207 S%1208 i%1209 (car x_) (cdr x_)))))) (if (is-FacAssignLam? e%1197) (let ([x_ (vector-ref e%1197 1)] [v_ (vector-ref e%1197 2)]) (codegen-value v_ (lambda (what%1210 S%1211 i%1212) (cons (list what%1210 S%1211 i%1212 (car x_) (cdr x_)) '())))) (if (is-FacAssignApp? e%1197) (let ([x_ (vector-ref e%1197 1)] [c_ (vector-ref e%1197 2)]) (if (is-FacApplication? c_) (let ([v_ (vector-ref c_ 1)] [vs_ (vector-ref c_ 2)]) (cons (list 'new-vec (length vs_)) (codegen-application vs_ (codegen-value v_ (lambda (what%1213 S%1214 i%1215) (if (eqv? what%1213 'move) (cons (list 'call S%1214 i%1215 0) (cons (list 'move 'res 0 (car x_) (cdr x_)) '())) (error 'codegen-named "unexpected tag: ~s" what%1213))))))) (error 'codegen-expression "not an assigned application: ~s" c_))) (if (is-FacBindCmp? e%1197) (let ([i_ (vector-ref e%1197 1)] [c_ (vector-ref e%1197 2)] [b_ (vector-ref e%1197 3)]) (codegen-named c_ i_ (codegen-expression b_))) (if (is-FacBindVal? e%1197) (let ([j_ (vector-ref e%1197 1)] [v_ (vector-ref e%1197 2)] [b_ (vector-ref e%1197 3)]) (codegen-value v_ (lambda (what%1216 S%1217 i%1218) (cons (list what%1216 S%1217 i%1218 'tmp j_) (codegen-expression b_))))) (if (is-FacReturn? e%1197) (let ([v_ (vector-ref e%1197 1)]) (codegen-value v_ (lambda (what%1219 S%1220 i%1221) (list (list what%1219 S%1220 i%1221 'res 0) immutable%1222)))) (if (is-FacBindJoin? e%1197) (let ([i_ (vector-ref e%1197 1)] [v_ (vector-ref e%1197 2)] [b_ (vector-ref e%1197 3)]) (if (is-FacAbstraction-deep? v_) (let ([offset_ (vector-ref v_ 1)]) (cons (list 'load 'close-deep offset_ 'tmp i_) (codegen-expression b_))) (error 'codegen-expression "not a deep abstraction: ~s" v_))) (if (is-FacSeq? e%1197) (let ([j_ (vector-ref e%1197 1)] [c1_ (vector-ref e%1197 2)] [c2_ (vector-ref e%1197 3)]) (if (is-FacApplication? c1_) (let ([v_ (vector-ref c1_ 1)] [vs_ (vector-ref c1_ 2)]) (cons (list 'new-vec (length vs_)) (codegen-application vs_ (codegen-value v_ (lambda (what%1223 S%1224 i%1225) (if (eqv? what%1223 'move) (cons (list 'call S%1224 i%1225 j_) (codegen-expression c2_)) (error 'codegen-expression "unexpected tag: ~s" what%1223))))))) (if (is-FacAssign? c1_) (let ([x_ (vector-ref c1_ 1)] [v_ (vector-ref c1_ 2)]) (codegen-value v_ (lambda (what%1226 S%1227 i%1228) (cons (list what%1226 S%1227 i%1228 (car x_) (cdr x_)) (codegen-expression c2_))))) (error 'codegen-expression "not a sequenced computation: ~s" c1_)))) (error 'codegen-expression "quasar: ~s" e%1197))))))))))))))
(define codegen-value (lambda (v%1229 k%1230) (if (is-FacLiteral? v%1229) (let ([l_ (vector-ref v%1229 1)]) (if (is-FacInteger? l_) (let ([i_ (vector-ref l_ 1)]) (k%1230 'load 'int i_)) (if (is-FacBoolean? l_) (let ([b_ (vector-ref l_ 1)]) (k%1230 'load 'bool (if b_ 1 0))) (if (is-FacString? l_) (let ([s_ (vector-ref l_ 1)]) (k%1230 'load 'str s_)) (if (is-FacCharacter? l_) (let ([c_ (vector-ref l_ 1)]) (k%1230 'load 'char (char->integer c_))) (if (is-FacSymbol? l_) (let ([s_ (vector-ref l_ 1)]) (k%1230 'load 'sym s_)) (if (is-FacNil? l_) (let () (k%1230 'load 'nil '_)) (if (is-FacVoid? l_) (let () (k%1230 'load 'void '_)) (error 'codegen-value "quasar: ~s" l_))))))))) (if (is-FacVariable? v%1229) (let ([x_ (vector-ref v%1229 1)] [kind_ (vector-ref v%1229 2)] [offset_ (vector-ref v%1229 3)]) (k%1230 'move kind_ offset_)) (if (is-FacVariableTmp? v%1229) (let ([i_ (vector-ref v%1229 1)]) (k%1230 'move 'tmp i_)) (if (is-FacVariableJoin? v%1229) (let ([i_ (vector-ref v%1229 1)]) (k%1230 'move 'tmp i_)) (if (is-FacAbstraction-flat? v%1229) (let ([offset_ (vector-ref v%1229 1)] [freevars_ (vector-ref v%1229 2)]) (cons (list 'new-vec (length freevars_)) (codegen-abstraction-flat freevars_ (k%1230 'load 'close-flat offset_)))) (if (is-FacAbstraction-deep? v%1229) (let ([offset_ (vector-ref v%1229 1)]) (k%1230 'load 'close-deep offset_)) (error 'codegen-value "quasar: ~s" v%1229)))))))))
(define codegen-named (lambda (c%1231 j%1232 a%1233) (if (is-FacApplication? c%1231) (let ([v_ (vector-ref c%1231 1)] [vs_ (vector-ref c%1231 2)]) (cons (list 'new-vec (length vs_)) (codegen-application vs_ (codegen-value v_ (lambda (what%1234 S%1235 i%1236) (if (eqv? what%1234 'move) (cons (list 'call S%1235 i%1236 j%1232) (if (if (not (null? a%1233)) (let ([q%1237 (car a%1233)]) (let ([q1%1238 (car q%1237)] [q%1239 (cdr q%1237)]) (if (eqv? q1%1238 'move) (let ([q2%1240 (car q%1239)]) (if (eqv? q2%1240 'tmp) (eqv? (car (cdr q%1239)) j%1232) #f)) #f))) #f) (cons (list 'move 'res 0 (list-ref (car a%1233) 3) (list-ref (car a%1233) 4)) (cdr a%1233)) (cons (list 'move 'res 0 'tmp j%1232) a%1233))) (error 'codegen-named "unexpected tag: ~s" what%1234))))))) (if (is-FacAssign? c%1231) (let ([x_ (vector-ref c%1231 1)] [v_ (vector-ref c%1231 2)]) (codegen-value v_ (lambda (what%1241 S%1242 i%1243) (cons (list what%1241 S%1242 i%1243 (car x_) (cdr x_)) (cons (list 'load 'void '_ 'tmp j%1232) a%1233))))) (if (is-FacAbstraction-flat? c%1231) (let ([offset_ (vector-ref c%1231 1)] [freevars_ (vector-ref c%1231 2)]) (cons (list 'new-vec (length freevars_)) (codegen-abstraction-flat freevars_ (cons (list 'load 'close-flat offset_ 'tmp j%1232) a%1233)))) (error 'codegen-named "not a named computation: ~s" c%1231))))))
(define codegen-definitions (lambda (ds%1244) (map-append1 (lambda (d%1245) (if (is-FacDefExp? d%1245) (let ([x_ (vector-ref d%1245 1)] [e_ (vector-ref d%1245 2)]) (codegen-expression e_)) (error 'codegen-definitions "not a factorized definition: ~s" d%1245))) ds%1244)))
(define codegen-bodies (lambda (bodies%1246) (map-append1 (lambda (body%1247) (cons (list 'label (car body%1247)) (codegen-expression (cdr body%1247)))) bodies%1246)))
(define how-many-tmp (lambda (is%1248) (letrec ([walk%1249 (lambda (is%1250 n%1251) (if (null? is%1250) (1+ n%1251) (let ([i%1252 (car is%1250)]) (if (if (let ([or%1253 (eqv? (car i%1252) 'move)]) (if or%1253 or%1253 (eqv? (car i%1252) 'load))) (eqv? (cadddr i%1252) 'tmp) #f) (walk%1249 (cdr is%1250) (max n%1251 (caddddr i%1252))) (walk%1249 (cdr is%1250) n%1251)))))]) (walk%1249 is%1248 -1))))
(define codegen-program (lambda (p%1254) (if (is-Factorized-Program? p%1254) (let ([ds_ (vector-ref p%1254 1)] [e_ (vector-ref p%1254 2)] [lambda-headers_ (vector-ref p%1254 3)] [lambda-bodies_ (vector-ref p%1254 4)]) (begin (warn "Generating code") (let* ([code-ds%1255 (codegen-definitions ds_)] [code-e%1256 (codegen-expression e_)] [code-bodies%1257 (codegen-bodies lambda-bodies_)]) (begin (warnl " / Code generated") (let ([code%1258 (append code-ds%1255 code-e%1256 code-bodies%1257)]) (make-Compiled-Program (length ds_) (how-many-tmp code%1258) 1 lambda-headers_ code%1258 the-tag)))))) (error 'codegen-program "not a factorized program"))))
(define dump-compiled-program (lambda (p%1259 port%1260) (if (is-Compiled-Program? p%1259) (let ([number-of-global-definitions_ (vector-ref p%1259 1)] [number-of-temporaries_ (vector-ref p%1259 2)] [number-of-results_ (vector-ref p%1259 3)] [the-lambdas_ (vector-ref p%1259 4)] [the-code_ (vector-ref p%1259 5)] [the-tag_ (vector-ref p%1259 6)]) (begin (display "(DAIMI-SchemeE03" port%1260) (newline port%1260) (display "  (" port%1260) (write number-of-global-definitions_ port%1260) (write-char char:space port%1260) (write number-of-temporaries_ port%1260) (write-char char:space port%1260) (write number-of-results_ port%1260) (write-char #\) port%1260) (newline port%1260) (if (null? the-lambdas_) (display "  ()" port%1260) (begin (display "  (" port%1260) (write (car the-lambdas_) port%1260) (for-each1 (lambda (a-lambda%1261) (begin (newline port%1260) (display "   " port%1260) (write a-lambda%1261 port%1260))) (cdr the-lambdas_)) (display ")" port%1260))) (newline port%1260) (display "  (" port%1260) (write (car the-code_) port%1260) (for-each1 (lambda (instruction%1262) (begin (newline port%1260) (if (if (eqv? (car instruction%1262) 'label) (char=? (string-ref (symbol->string (cadr instruction%1262)) 0) #\l) #f) (newline port%1260) 'ikke-noget) (display "   " port%1260) (write instruction%1262 port%1260))) (cdr the-code_)) (display ")" port%1260) (newline port%1260) (display "  " port%1260) (write the-tag_ port%1260) (display ")" port%1260) (newline port%1260))) (error 'dump-compiled-program "not a compiled program: ~s" p%1259))))
(define make-DS-nil (lambda () (vector 'DS-nil)))
(define is-DS-nil? (lambda (record%1263) (if (vector? record%1263) (if (= (vector-length record%1263) 1) (eqv? (vector-ref record%1263 0) 'DS-nil) #f) #f)))
(define make-DS-false (lambda () (vector 'DS-false)))
(define is-DS-false? (lambda (record%1264) (if (vector? record%1264) (if (= (vector-length record%1264) 1) (eqv? (vector-ref record%1264 0) 'DS-false) #f) #f)))
(define make-DS-true (lambda () (vector 'DS-true)))
(define is-DS-true? (lambda (record%1265) (if (vector? record%1265) (if (= (vector-length record%1265) 1) (eqv? (vector-ref record%1265 0) 'DS-true) #f) #f)))
(define make-DS-integer (lambda (i_) (vector 'DS-integer i_)))
(define is-DS-integer? (lambda (record%1266) (if (vector? record%1266) (if (= (vector-length record%1266) 2) (eqv? (vector-ref record%1266 0) 'DS-integer) #f) #f)))
(define make-DS-char (lambda (c_) (vector 'DS-char c_)))
(define is-DS-char? (lambda (record%1267) (if (vector? record%1267) (if (= (vector-length record%1267) 2) (eqv? (vector-ref record%1267 0) 'DS-char) #f) #f)))
(define make-DS-string (lambda (s_) (vector 'DS-string s_)))
(define is-DS-string? (lambda (record%1268) (if (vector? record%1268) (if (= (vector-length record%1268) 2) (eqv? (vector-ref record%1268 0) 'DS-string) #f) #f)))
(define make-DS-symbol (lambda (s_) (vector 'DS-symbol s_)))
(define is-DS-symbol? (lambda (record%1269) (if (vector? record%1269) (if (= (vector-length record%1269) 2) (eqv? (vector-ref record%1269 0) 'DS-symbol) #f) #f)))
(define make-DS-closure (lambda (label_ env-lex_ unique-tag_) (vector 'DS-closure label_ env-lex_ unique-tag_)))
(define is-DS-closure? (lambda (record%1270) (if (vector? record%1270) (if (= (vector-length record%1270) 4) (eqv? (vector-ref record%1270 0) 'DS-closure) #f) #f)))
(define make-DS-primitive (lambda (name_ arity_ procedure_) (vector 'DS-primitive name_ arity_ procedure_)))
(define is-DS-primitive? (lambda (record%1271) (if (vector? record%1271) (if (= (vector-length record%1271) 4) (eqv? (vector-ref record%1271 0) 'DS-primitive) #f) #f)))
(define make-DS-continuation (lambda (cont_) (vector 'DS-continuation cont_)))
(define is-DS-continuation? (lambda (record%1272) (if (vector? record%1272) (if (= (vector-length record%1272) 2) (eqv? (vector-ref record%1272 0) 'DS-continuation) #f) #f)))
(define make-DS-pair (lambda (a_ d_) (vector 'DS-pair a_ d_)))
(define is-DS-pair? (lambda (record%1273) (if (vector? record%1273) (if (= (vector-length record%1273) 3) (eqv? (vector-ref record%1273 0) 'DS-pair) #f) #f)))
(define make-DS-vector (lambda (v_) (vector 'DS-vector v_)))
(define is-DS-vector? (lambda (record%1274) (if (vector? record%1274) (if (= (vector-length record%1274) 2) (eqv? (vector-ref record%1274 0) 'DS-vector) #f) #f)))
(define make-DS-input-port (lambda (v_) (vector 'DS-input-port v_)))
(define is-DS-input-port? (lambda (record%1275) (if (vector? record%1275) (if (= (vector-length record%1275) 2) (eqv? (vector-ref record%1275 0) 'DS-input-port) #f) #f)))
(define make-DS-output-port (lambda (v_) (vector 'DS-output-port v_)))
(define is-DS-output-port? (lambda (record%1276) (if (vector? record%1276) (if (= (vector-length record%1276) 2) (eqv? (vector-ref record%1276 0) 'DS-output-port) #f) #f)))
(define make-DS-eof-object (lambda () (vector 'DS-eof-object)))
(define is-DS-eof-object? (lambda (record%1277) (if (vector? record%1277) (if (= (vector-length record%1277) 1) (eqv? (vector-ref record%1277 0) 'DS-eof-object) #f) #f)))
(define make-DS-undefined (lambda () (vector 'DS-undefined)))
(define is-DS-undefined? (lambda (record%1278) (if (vector? record%1278) (if (= (vector-length record%1278) 1) (eqv? (vector-ref record%1278 0) 'DS-undefined) #f) #f)))
(define make-DS-void (lambda () (vector 'DS-void)))
(define is-DS-void? (lambda (record%1279) (if (vector? record%1279) (if (= (vector-length record%1279) 1) (eqv? (vector-ref record%1279 0) 'DS-void) #f) #f)))
(define DS-nil (make-DS-nil))
(define DS-false (make-DS-false))
(define DS-true (make-DS-true))
(define DS-undefined (make-DS-undefined))
(define DS-void (make-DS-void))
(define DS2S (lambda (v%1280) (if (is-DS-nil? v%1280) (let () '()) (if (is-DS-false? v%1280) (let () #f) (if (is-DS-true? v%1280) (let () #t) (if (is-DS-integer? v%1280) (let ([i_ (vector-ref v%1280 1)]) i_) (if (is-DS-char? v%1280) (let ([c_ (vector-ref v%1280 1)]) c_) (if (is-DS-string? v%1280) (let ([s_ (vector-ref v%1280 1)]) s_) (if (is-DS-symbol? v%1280) (let ([s_ (vector-ref v%1280 1)]) s_) (if (is-DS-closure? v%1280) (let ([label_ (vector-ref v%1280 1)] [env-lex_ (vector-ref v%1280 2)] [unique-tag_ (vector-ref v%1280 3)]) "#<user-defined procedure>") (if (is-DS-primitive? v%1280) (let ([name_ (vector-ref v%1280 1)] [arity_ (vector-ref v%1280 2)] [procedure_ (vector-ref v%1280 3)]) (string-append "#<predefined procedure " (string-append (if (string? name_) name_ (symbol->string name_)) ">"))) (if (is-DS-continuation? v%1280) (let ([cont_ (vector-ref v%1280 1)]) "#<continuation procedure>") (if (is-DS-pair? v%1280) (let ([a_ (vector-ref v%1280 1)] [d_ (vector-ref v%1280 2)]) (cons (DS2S a_) (DS2S d_))) (if (is-DS-vector? v%1280) (let ([v_ (vector-ref v%1280 1)]) (cons 'vector (map1 DS2S (vector->list v_)))) (if (is-DS-input-port? v%1280) (let ([v_ (vector-ref v%1280 1)]) "#<input port>") (if (is-DS-output-port? v%1280) (let ([v_ (vector-ref v%1280 1)]) "#<output port>") (if (is-DS-eof-object? v%1280) (let () "#<eof object>") (if (is-DS-void? v%1280) (let () "#<void object>") (error 'DS2S "not a DAIMI-Scheme value: ~s" v%1280)))))))))))))))))))
(define check-arity (lambda (name%1281 arity%1282 vec%1283) (if (let ([or%1284 (= arity%1282 -1)]) (if or%1284 or%1284 (= arity%1282 (vector-length vec%1283)))) 'OK (error 'check-arity "~s(~s): wrong arity: ~s" name%1281 arity%1282 vec%1283))))
(define check-type-one (lambda (check-type%1285 op%1286 actual%1287 type%1288) (let ([tag%1289 (vector-ref actual%1287 0)]) (if (if (eqv? tag%1289 'DS-nil) #f (if (eqv? tag%1289 'DS-false) (eqv? type%1288 'boolean) (if (eqv? tag%1289 'DS-true) (eqv? type%1288 'boolean) (if (eqv? tag%1289 'DS-integer) (eqv? type%1288 'integer) (if (eqv? tag%1289 'DS-char) (eqv? type%1288 'char) (if (eqv? tag%1289 'DS-string) (eqv? type%1288 'string) (if (eqv? tag%1289 'DS-symbol) (eqv? type%1288 'symbol) (if (eqv? tag%1289 'DS-closure) (eqv? type%1288 'procedure) (if (eqv? tag%1289 'DS-primitive) (eqv? type%1288 'procedure) (if (eqv? tag%1289 'DS-continuation) (eqv? type%1288 'procedure) (if (eqv? tag%1289 'DS-pair) (eqv? type%1288 'pair) (if (eqv? tag%1289 'DS-vector) (eqv? type%1288 'vector) (if (eqv? tag%1289 'DS-input-port) (eqv? type%1288 'input-port) (if (eqv? tag%1289 'DS-output-port) (eqv? type%1288 'output-port) (if (eqv? tag%1289 'DS-eof-object) #f (error 'check-type-one "not a DAIMI-Scheme value: ~s" actual%1287)))))))))))))))) 'OK (error check-type%1285 "~s / not a ~s: ~s" op%1286 type%1288 actual%1287)))))
(define check-type (lambda (op%1290 actuals%1291 type%1292) (check-type-one 'check-type op%1290 (vector-ref actuals%1291 0) type%1292)))
(define check-type2 (lambda (op%1293 actuals%1294 type%1295) (check-type-one 'check-type2 op%1293 (vector-ref actuals%1294 1) type%1295)))
(define check-types (lambda (op%1296 actuals%1297 type%1298) (let ([len%1299 (vector-length actuals%1297)]) (letrec ([walk%1300 (lambda (i%1301) (if (= i%1301 len%1299) 'OK (begin (check-type-one 'check-types op%1296 (vector-ref actuals%1297 i%1301) type%1298) (walk%1300 (+ i%1301 1)))))]) (walk%1300 0)))))
(define check-DS-proper-list? (lambda (v%1302) (if (DS-proper-list? v%1302) 'OK (error 'check-DS-proper-list? "not a proper list: ~s" v%1302))))
(define DS-eqv? (lambda (x%1303 y%1304) (if (is-DS-nil? x%1303) (let () (if (is-DS-nil? y%1304) (let () #t) #f)) (if (is-DS-false? x%1303) (let () (if (is-DS-false? y%1304) (let () #t) #f)) (if (is-DS-true? x%1303) (let () (if (is-DS-true? y%1304) (let () #t) #f)) (if (is-DS-integer? x%1303) (let ([ix_ (vector-ref x%1303 1)]) (if (is-DS-integer? y%1304) (let ([iy_ (vector-ref y%1304 1)]) (= ix_ iy_)) #f)) (if (is-DS-char? x%1303) (let ([cx_ (vector-ref x%1303 1)]) (if (is-DS-char? y%1304) (let ([cy_ (vector-ref y%1304 1)]) (eqv? cx_ cy_)) #f)) (if (is-DS-string? x%1303) (let ([sx_ (vector-ref x%1303 1)]) (if (is-DS-string? y%1304) (let ([sy_ (vector-ref y%1304 1)]) (eqv? x%1303 y%1304)) #f)) (if (is-DS-symbol? x%1303) (let ([sx_ (vector-ref x%1303 1)]) (if (is-DS-symbol? y%1304) (let ([sy_ (vector-ref y%1304 1)]) (eqv? sx_ sy_)) #f)) (if (is-DS-closure? x%1303) (let ([labelx_ (vector-ref x%1303 1)] [env-lexx_ (vector-ref x%1303 2)] [unique-tagx_ (vector-ref x%1303 3)]) (if (is-DS-closure? y%1304) (let ([labely_ (vector-ref y%1304 1)] [env-lexy_ (vector-ref y%1304 2)] [unique-tagy_ (vector-ref y%1304 3)]) (eqv? unique-tagx_ unique-tagy_)) #f)) (if (is-DS-primitive? x%1303) (let ([namex_ (vector-ref x%1303 1)] [arityx_ (vector-ref x%1303 2)] [procedurex_ (vector-ref x%1303 3)]) (if (is-DS-primitive? y%1304) (let ([namey_ (vector-ref y%1304 1)] [arityy_ (vector-ref y%1304 2)] [procedurey_ (vector-ref y%1304 3)]) (eqv? namex_ namey_)) #f)) (if (is-DS-continuation? x%1303) (let ([cx_ (vector-ref x%1303 1)]) (if (is-DS-continuation? y%1304) (let ([cy_ (vector-ref y%1304 1)]) (eqv? cx_ cy_)) #f)) (if (is-DS-pair? x%1303) (let ([ax_ (vector-ref x%1303 1)] [dx_ (vector-ref x%1303 2)]) (if (is-DS-pair? y%1304) (let ([ay_ (vector-ref y%1304 1)] [dy_ (vector-ref y%1304 2)]) (eqv? x%1303 y%1304)) #f)) (if (is-DS-vector? x%1303) (let ([vx_ (vector-ref x%1303 1)]) (if (is-DS-vector? y%1304) (let ([vy_ (vector-ref y%1304 1)]) (eqv? x%1303 y%1304)) #f)) (if (is-DS-input-port? x%1303) (let ([vx_ (vector-ref x%1303 1)]) (if (is-DS-input-port? y%1304) (let ([vy_ (vector-ref y%1304 1)]) (eqv? x%1303 y%1304)) #f)) (if (is-DS-output-port? x%1303) (let ([vx_ (vector-ref x%1303 1)]) (if (is-DS-output-port? y%1304) (let ([vy_ (vector-ref y%1304 1)]) (eqv? x%1303 y%1304)) #f)) (error 'DS-eqv? "not a DAIMI-Scheme value: ~s" x%1303)))))))))))))))))
(define vector->DS-list (lambda (v%1305) (let ([len%1306 (vector-length v%1305)]) (letrec ([loop%1307 (lambda (offset%1308) (if (= offset%1308 len%1306) DS-nil (make-DS-pair (vector-ref v%1305 offset%1308) (loop%1307 (1+ offset%1308)))))]) (loop%1307 0)))))
(define DS-list->vector (lambda (xs%1309) (letrec ([walk%1310 (lambda (xs%1311) (if (is-DS-nil? xs%1311) (let () '()) (if (is-DS-pair? xs%1311) (let ([a_ (vector-ref xs%1311 1)] [d_ (vector-ref xs%1311 2)]) (cons a_ (walk%1310 d_))) (error 'DS-list->vector "not a list: ~s" xs%1311))))]) (list->vector (walk%1310 xs%1309)))))
(define DS-car (lambda (v%1312) (if (is-DS-pair? v%1312) (let ([a_ (vector-ref v%1312 1)] [d_ (vector-ref v%1312 2)]) a_) (error 'DS-car "not a pair: ~s" v%1312))))
(define DS-cdr (lambda (v%1313) (if (is-DS-pair? v%1313) (let ([a_ (vector-ref v%1313 1)] [d_ (vector-ref v%1313 2)]) d_) (error 'DS-car "not a pair: ~s" v%1313))))
(define DS-null? (lambda (v%1314) (if (is-DS-nil? v%1314) (let () #t) #f)))
(define DS-pair? (lambda (v%1315) (if (is-DS-pair? v%1315) (let ([a_ (vector-ref v%1315 1)] [d_ (vector-ref v%1315 2)]) #t) #f)))
(define DS-proper-list? (lambda (xs%1316) (letrec ([walk%1317 (lambda (xs1%1318 xs2%1319) (let ([or%1322 (DS-null? xs2%1319)]) (if or%1322 or%1322 (if (DS-pair? xs2%1319) (if (not (eqv? xs1%1318 xs2%1319)) (let ([xs2p%1320 (DS-cdr xs2%1319)]) (let ([or%1321 (DS-null? xs2p%1320)]) (if or%1321 or%1321 (if (DS-pair? xs2p%1320) (walk%1317 (DS-cdr xs1%1318) (DS-cdr xs2p%1320)) #f)))) #f) #f))))]) (let ([or%1323 (DS-null? xs%1316)]) (if or%1323 or%1323 (if (DS-pair? xs%1316) (walk%1317 xs%1316 (DS-cdr xs%1316)) #f))))))
(define DS-proper-list?_does_not_work_somehow (lambda (xs%1324) (letrec ([walk%1325 (lambda (xs1%1326 xs2%1327) (if (is-DS-nil? xs2%1327) (let () #t) (if (is-DS-pair? xs2%1327) (let ([a2_ (vector-ref xs2%1327 1)] [d2_ (vector-ref xs2%1327 2)]) (if (not (eqv? xs1%1326 xs2%1327)) (if (is-DS-nil? d2_) (let () #t) (if (is-DS-pair? d2_) (let ([a22_ (vector-ref d2_ 1)] [d22_ (vector-ref d2_ 2)]) (if (is-DS-nil? d22_) (let () #t) (if (is-DS-pair? d22_) (let ([a33_ (vector-ref d22_ 1)] [d33_ (vector-ref d22_ 2)]) (if (is-DS-pair? xs1%1326) (let ([a1_ (vector-ref xs1%1326 1)] [d1_ (vector-ref xs1%1326 2)]) (walk%1325 d1_ d33_)) (error 'DS-proper-list? "im-po-ssi-ble!"))) #f))) #f)) #f)) #f)))]) (if (is-DS-nil? xs%1324) (let () #t) (if (is-DS-pair? xs%1324) (let ([a_ (vector-ref xs%1324 1)] [d_ (vector-ref xs%1324 2)]) (walk%1325 a_ d_)) #f)))))
(define env-lib-reference (vector (make-DS-primitive 'integer? 1 (lambda (actuals%1328 resume%1329) (begin (let ([case%1330 (vector-ref (vector-ref actuals%1328 0) 0)]) (if (eqv? case%1330 'DS-integer) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1329)))) (make-DS-primitive '+ -1 (lambda (actuals%1331 resume%1332) (begin (check-types '+ actuals%1331 'integer) (vector-set! aux-res 0 (make-DS-integer (fold-vec actuals%1331 + 0))) (resume%1332)))) (make-DS-primitive '- 2 (lambda (actuals%1333 resume%1334) (begin (check-types '- actuals%1333 'integer) (vector-set! aux-res 0 (make-DS-integer (- (vector-ref (vector-ref actuals%1333 0) 1) (vector-ref (vector-ref actuals%1333 1) 1)))) (resume%1334)))) (make-DS-primitive '* -1 (lambda (actuals%1335 resume%1336) (begin (check-types '* actuals%1335 'integer) (vector-set! aux-res 0 (make-DS-integer (fold-vec actuals%1335 * 1))) (resume%1336)))) (make-DS-primitive 'quotient 2 (lambda (actuals%1337 resume%1338) (begin (check-types 'quotient actuals%1337 'integer) (vector-set! aux-res 0 (make-DS-integer (quotient (vector-ref (vector-ref actuals%1337 0) 1) (vector-ref (vector-ref actuals%1337 1) 1)))) (resume%1338)))) (make-DS-primitive 'remainder 2 (lambda (actuals%1339 resume%1340) (begin (check-types 'remainder actuals%1339 'integer) (vector-set! aux-res 0 (make-DS-integer (remainder (vector-ref (vector-ref actuals%1339 0) 1) (vector-ref (vector-ref actuals%1339 1) 1)))) (resume%1340)))) (make-DS-primitive '< 2 (lambda (actuals%1341 resume%1342) (begin (check-types '< actuals%1341 'integer) (vector-set! aux-res 0 (if (< (vector-ref (vector-ref actuals%1341 0) 1) (vector-ref (vector-ref actuals%1341 1) 1)) DS-true DS-false)) (resume%1342)))) (make-DS-primitive '<= 2 (lambda (actuals%1343 resume%1344) (begin (check-types '<= actuals%1343 'integer) (vector-set! aux-res 0 (if (<= (vector-ref (vector-ref actuals%1343 0) 1) (vector-ref (vector-ref actuals%1343 1) 1)) DS-true DS-false)) (resume%1344)))) (make-DS-primitive '= 2 (lambda (actuals%1345 resume%1346) (begin (check-types '= actuals%1345 'integer) (vector-set! aux-res 0 (if (= (vector-ref (vector-ref actuals%1345 0) 1) (vector-ref (vector-ref actuals%1345 1) 1)) DS-true DS-false)) (resume%1346)))) (make-DS-primitive '>= 2 (lambda (actuals%1347 resume%1348) (begin (check-types '>= actuals%1347 'integer) (vector-set! aux-res 0 (if (>= (vector-ref (vector-ref actuals%1347 0) 1) (vector-ref (vector-ref actuals%1347 1) 1)) DS-true DS-false)) (resume%1348)))) (make-DS-primitive '> 2 (lambda (actuals%1349 resume%1350) (begin (check-types '> actuals%1349 'integer) (vector-set! aux-res 0 (if (> (vector-ref (vector-ref actuals%1349 0) 1) (vector-ref (vector-ref actuals%1349 1) 1)) DS-true DS-false)) (resume%1350)))) (make-DS-primitive 'boolean? 1 (lambda (actuals%1351 resume%1352) (begin (let ([case%1353 (vector-ref (vector-ref actuals%1351 0) 0)]) (if (eqv? case%1353 'DS-true) (vector-set! aux-res 0 DS-true) (if (eqv? case%1353 'DS-false) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false)))) (resume%1352)))) (make-DS-primitive 'symbol? 1 (lambda (actuals%1354 resume%1355) (begin (let ([case%1356 (vector-ref (vector-ref actuals%1354 0) 0)]) (if (eqv? case%1356 'DS-symbol) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1355)))) (make-DS-primitive 'char? 1 (lambda (actuals%1357 resume%1358) (begin (let ([case%1359 (vector-ref (vector-ref actuals%1357 0) 0)]) (if (eqv? case%1359 'DS-char) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1358)))) (make-DS-primitive 'char->integer 1 (lambda (actuals%1360 resume%1361) (begin (check-type 'char->integer actuals%1360 'char) (vector-set! aux-res 0 (make-DS-integer (char->integer (vector-ref (vector-ref actuals%1360 0) 1)))) (resume%1361)))) (make-DS-primitive 'integer->char 1 (lambda (actuals%1362 resume%1363) (begin (check-type 'integer->char actuals%1362 'integer) (vector-set! aux-res 0 (make-DS-char (integer->char (vector-ref (vector-ref actuals%1362 0) 1)))) (resume%1363)))) (make-DS-primitive 'string -1 (lambda (actuals%1364 resume%1365) (begin (check-types 'string actuals%1364 'char) (vector-set! aux-res 0 (make-DS-string (apply string (map1 (lambda (actual%1366) (vector-ref actual%1366 1)) (vector->list actuals%1364))))) (resume%1365)))) (make-DS-primitive 'make-string 2 (lambda (actuals%1367 resume%1368) (begin (check-type 'make-string actuals%1367 'integer) (check-type2 'make-string actuals%1367 'char) (vector-set! aux-res 0 (make-DS-string (make-string (vector-ref (vector-ref actuals%1367 0) 1) (vector-ref (vector-ref actuals%1367 1) 1)))) (resume%1368)))) (make-DS-primitive 'string? 1 (lambda (actuals%1369 resume%1370) (begin (let ([case%1371 (vector-ref (vector-ref actuals%1369 0) 0)]) (if (eqv? case%1371 'DS-string) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1370)))) (make-DS-primitive 'string-length 1 (lambda (actuals%1372 resume%1373) (begin (check-type 'string-length actuals%1372 'string) (vector-set! aux-res 0 (make-DS-integer (string-length (vector-ref (vector-ref actuals%1372 0) 1)))) (resume%1373)))) (make-DS-primitive 'string-append 2 (lambda (actuals%1374 resume%1375) (begin (check-types 'string-append actuals%1374 'string) (vector-set! aux-res 0 (make-DS-string (string-append (vector-ref (vector-ref actuals%1374 0) 1) (vector-ref (vector-ref actuals%1374 1) 1)))) (resume%1375)))) (make-DS-primitive 'string=? 2 (lambda (actuals%1376 resume%1377) (begin (check-types 'string-=? actuals%1376 'string) (vector-set! aux-res 0 (if (string=? (vector-ref (vector-ref actuals%1376 0) 1) (vector-ref (vector-ref actuals%1376 1) 1)) DS-true DS-false)) (resume%1377)))) (make-DS-primitive 'string-ref 2 (lambda (actuals%1378 resume%1379) (begin (check-type 'string-ref actuals%1378 'string) (check-type2 'string-ref actuals%1378 'integer) (vector-set! aux-res 0 (let ([s%1380 (vector-ref (vector-ref actuals%1378 0) 1)] [i%1381 (vector-ref (vector-ref actuals%1378 1) 1)]) (if (if (>= i%1381 0) (< i%1381 (string-length s%1380)) #f) (make-DS-char (string-ref s%1380 i%1381)) (error 'primitive-string-ref "index out of bounds: ~s and ~s" s%1380 i%1381)))) (resume%1379)))) (make-DS-primitive 'string->symbol 1 (lambda (actuals%1382 resume%1383) (begin (check-type 'string->symbol actuals%1382 'string) (vector-set! aux-res 0 (make-DS-symbol (string->symbol (vector-ref (vector-ref actuals%1382 0) 1)))) (resume%1383)))) (make-DS-primitive 'symbol->string 1 (lambda (actuals%1384 resume%1385) (begin (check-type 'symbol->string actuals%1384 'symbol) (vector-set! aux-res 0 (make-DS-string (symbol->string (vector-ref (vector-ref actuals%1384 0) 1)))) (resume%1385)))) (make-DS-primitive 'pair? 1 (lambda (actuals%1386 resume%1387) (begin (let ([case%1388 (vector-ref (vector-ref actuals%1386 0) 0)]) (if (eqv? case%1388 'DS-pair) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1387)))) (make-DS-primitive 'cons 2 (lambda (actuals%1389 resume%1390) (begin (vector-set! aux-res 0 (make-DS-pair (vector-ref actuals%1389 0) (vector-ref actuals%1389 1))) (resume%1390)))) (make-DS-primitive 'car 1 (lambda (actuals%1391 resume%1392) (begin (check-type 'car actuals%1391 'pair) (vector-set! aux-res 0 (vector-ref (vector-ref actuals%1391 0) 1)) (resume%1392)))) (make-DS-primitive 'cdr 1 (lambda (actuals%1393 resume%1394) (begin (check-type 'cdr actuals%1393 'pair) (vector-set! aux-res 0 (vector-ref (vector-ref actuals%1393 0) 2)) (resume%1394)))) (make-DS-primitive 'set-car! 2 (lambda (actuals%1395 resume%1396) (begin (check-type 'set-car! actuals%1395 'pair) (vector-set! (vector-ref actuals%1395 0) 1 (vector-ref actuals%1395 1)) (vector-set! aux-res 0 DS-void) (resume%1396)))) (make-DS-primitive 'set-cdr! 2 (lambda (actuals%1397 resume%1398) (begin (check-type 'set-car! actuals%1397 'pair) (vector-set! (vector-ref actuals%1397 0) 2 (vector-ref actuals%1397 1)) (vector-set! aux-res 0 DS-void) (resume%1398)))) (make-DS-primitive 'null? 1 (lambda (actuals%1399 resume%1400) (begin (let ([case%1401 (vector-ref (vector-ref actuals%1399 0) 0)]) (if (eqv? case%1401 'DS-nil) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1400)))) (make-DS-primitive 'vector -1 (lambda (actuals%1402 resume%1403) (begin (vector-set! aux-res 0 (make-DS-vector (vector-copy actuals%1402))) (resume%1403)))) (make-DS-primitive 'make-vector 2 (lambda (actuals%1404 resume%1405) (begin (check-type 'make-vector actuals%1404 'integer) (vector-set! aux-res 0 (make-DS-vector (make-vector (vector-ref (vector-ref actuals%1404 0) 1) (vector-ref actuals%1404 1)))) (resume%1405)))) (make-DS-primitive 'vector? 1 (lambda (actuals%1406 resume%1407) (begin (let ([case%1408 (vector-ref (vector-ref actuals%1406 0) 0)]) (if (eqv? case%1408 'DS-vector) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1407)))) (make-DS-primitive 'vector-length 1 (lambda (actuals%1409 resume%1410) (begin (check-type 'vector-length actuals%1409 'vector) (vector-set! aux-res 0 (make-DS-integer (vector-length (vector-ref (vector-ref actuals%1409 0) 1)))) (resume%1410)))) (make-DS-primitive 'vector-ref 2 (lambda (actuals%1411 resume%1412) (begin (check-type 'vector-ref actuals%1411 'vector) (check-type2 'vector-ref actuals%1411 'integer) (vector-set! aux-res 0 (let ([s%1413 (vector-ref (vector-ref actuals%1411 0) 1)] [i%1414 (vector-ref (vector-ref actuals%1411 1) 1)]) (if (if (>= i%1414 0) (< i%1414 (vector-length s%1413)) #f) (vector-ref s%1413 i%1414) (error 'primitive-vector-ref "index out of bounds: ~s and ~s" s%1413 i%1414)))) (resume%1412)))) (make-DS-primitive 'vector-set! 3 (lambda (actuals%1415 resume%1416) (begin (check-type 'vector-set! actuals%1415 'vector) (check-type2 'vector-set! actuals%1415 'integer) (let ([s%1417 (vector-ref (vector-ref actuals%1415 0) 1)] [i%1418 (vector-ref (vector-ref actuals%1415 1) 1)]) (if (if (>= i%1418 0) (< i%1418 (vector-length s%1417)) #f) (vector-set! s%1417 i%1418 (vector-ref actuals%1415 2)) (error 'primitive-vector-set! "index out of bounds: ~s and ~s" s%1417 i%1418))) (vector-set! aux-res 0 DS-void) (resume%1416)))) (make-DS-primitive 'procedure? 1 (lambda (actuals%1419 resume%1420) (begin (let ([case%1421 (vector-ref (vector-ref actuals%1419 0) 0)]) (if (eqv? case%1421 'DS-closure) (vector-set! aux-res 0 DS-true) (if (eqv? case%1421 'DS-primitive) (vector-set! aux-res 0 DS-true) (if (eqv? case%1421 'DS-continuation) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))))) (resume%1420)))) (make-DS-primitive 'apply 2 'apply) (make-DS-primitive 'eqv? 2 (lambda (actuals%1422 resume%1423) (begin (vector-set! aux-res 0 (if (DS-eqv? (vector-ref actuals%1422 0) (vector-ref actuals%1422 1)) DS-true DS-false)) (resume%1423)))) (make-DS-primitive 'call/cc 1 'call/cc) (make-DS-primitive 'exit 1 (lambda (actuals%1424 resume%1425) (begin (check-type 'exit actuals%1424 'integer) (vector-ref actuals%1424 0)))) (make-DS-primitive 'open-input-file 1 (lambda (actuals%1426 resume%1427) (begin (check-type 'open-input-file actuals%1426 'string) (vector-set! aux-res 0 (make-DS-input-port (open-input-file (vector-ref (vector-ref actuals%1426 0) 1)))) (resume%1427)))) (make-DS-primitive 'input-port? 1 (lambda (actuals%1428 resume%1429) (begin (let ([case%1430 (vector-ref (vector-ref actuals%1428 0) 0)]) (if (eqv? case%1430 'DS-input-port) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1429)))) (make-DS-primitive 'close-input-port 1 (lambda (actuals%1431 resume%1432) (begin (check-type 'close-input-port actuals%1431 'input-port) (close-input-port (vector-ref (vector-ref actuals%1431 0) 1)) (vector-set! aux-res 0 DS-void) (resume%1432)))) (make-DS-primitive 'current-input-port 0 (lambda (actuals%1433 resume%1434) (begin (vector-set! aux-res 0 (make-DS-input-port (current-input-port))) (resume%1434)))) (make-DS-primitive 'read-char 1 (lambda (actuals%1435 resume%1436) (begin (check-type 'read-char actuals%1435 'input-port) (vector-set! aux-res 0 (let ([c%1437 (read-char (vector-ref (vector-ref actuals%1435 0) 1))]) (if (eof-object? c%1437) (make-DS-eof-object) (make-DS-char c%1437)))) (resume%1436)))) (make-DS-primitive 'peek-char 1 (lambda (actuals%1438 resume%1439) (begin (check-type 'peek-char actuals%1438 'input-port) (vector-set! aux-res 0 (let ([c%1440 (peek-char (vector-ref (vector-ref actuals%1438 0) 1))]) (if (eof-object? c%1440) (make-DS-eof-object) (make-DS-char c%1440)))) (resume%1439)))) (make-DS-primitive 'eof-object? 1 (lambda (actuals%1441 resume%1442) (begin (let ([case%1443 (vector-ref (vector-ref actuals%1441 0) 0)]) (if (eqv? case%1443 'DS-eof-object) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1442)))) (make-DS-primitive 'open-output-file 1 (lambda (actuals%1444 resume%1445) (begin (check-type 'open-output-file actuals%1444 'string) (vector-set! aux-res 0 (make-DS-output-port (open-output-file (vector-ref (vector-ref actuals%1444 0) 1)))) (resume%1445)))) (make-DS-primitive 'output-port? 1 (lambda (actuals%1446 resume%1447) (begin (let ([case%1448 (vector-ref (vector-ref actuals%1446 0) 0)]) (if (eqv? case%1448 'DS-output-port) (vector-set! aux-res 0 DS-true) (vector-set! aux-res 0 DS-false))) (resume%1447)))) (make-DS-primitive 'close-output-port 1 (lambda (actuals%1449 resume%1450) (begin (check-type 'close-output-port actuals%1449 'output-port) (close-output-port (vector-ref (vector-ref actuals%1449 0) 1)) (vector-set! aux-res 0 DS-void) (resume%1450)))) (make-DS-primitive 'current-output-port 0 (lambda (actuals%1451 resume%1452) (begin (vector-set! aux-res 0 (make-DS-output-port (current-output-port))) (resume%1452)))) (make-DS-primitive 'write-char 2 (lambda (actuals%1453 resume%1454) (begin (check-type 'write-char actuals%1453 'char) (check-type2 'write-char actuals%1453 'output-port) (write-char (vector-ref (vector-ref actuals%1453 0) 1) (vector-ref (vector-ref actuals%1453 1) 1)) (vector-set! aux-res 0 DS-void) (resume%1454))))))
(define fold-vec (lambda (vec%1455 op%1456 a%1457) (let ([len%1458 (vector-length vec%1455)]) (letrec ([loop%1459 (lambda (i%1460 a%1461) (if (= i%1460 len%1458) a%1461 (loop%1459 (+ i%1460 1) (op%1456 (vector-ref (vector-ref vec%1455 i%1460) 1) a%1461))))]) (loop%1459 0 a%1457)))))
(define vector-copy (lambda (v%1462) (let* ([len%1463 (vector-length v%1462)] [w%1464 (make-vector len%1463 '())]) (letrec ([walk%1465 (lambda (n%1466) (if (negative? n%1466) w%1464 (begin (vector-set! w%1464 n%1466 (vector-ref v%1462 n%1466)) (walk%1465 (- n%1466 1)))))]) (walk%1465 (- len%1463 1))))))
(define vector-copy-prefix (lambda (v%1467 len%1468) (let ([w%1469 (make-vector len%1468 '())]) (letrec ([walk%1470 (lambda (n%1471) (if (negative? n%1471) w%1469 (begin (vector-set! w%1469 n%1471 (vector-ref v%1467 n%1471)) (walk%1470 (- n%1471 1)))))]) (walk%1470 (- len%1468 1))))))
(define vector-restore-prefix! (lambda (v%1472 w%1473) (let ([len%1474 (vector-length w%1473)]) (letrec ([walk%1475 (lambda (n%1476) (if (= n%1476 len%1474) v%1472 (begin (vector-set! v%1472 n%1476 (vector-ref w%1473 n%1476)) (walk%1475 (+ n%1476 1)))))]) (walk%1475 0)))))
(define env-lib (vector))
(define env-glo (vector))
(define env-tmp (vector))
(define aux-res (vector))
(define table-lam-arity (vector))
(define table-lam-entry (vector))
(define table-code-rator (vector))
(define table-code-rands (vector))
(define crossref (lambda (the-code%1477 k%1478) (let* ([the-labels%1479 (list->vector (sort (lambda (x%1480 y%1481) (string<? (car x%1480) (car y%1481))) (letrec ([traverse%1482 (lambda (is%1483 n%1484) (if (null? is%1483) '() (let ([i%1485 (car is%1483)] [is%1486 (cdr is%1483)]) (let ([case%1487 (car i%1485)]) (if (eqv? case%1487 'label) (cons (cons (symbol->string (cadr i%1485)) n%1484) (traverse%1482 is%1486 n%1484)) (if (eqv? case%1487 'nop) (traverse%1482 is%1486 n%1484) (traverse%1482 is%1486 (1+ n%1484))))))))]) (traverse%1482 the-code%1477 0))))] [the-number-of-labels%1488 (vector-length the-labels%1479)] [maxi%1489 (1- the-number-of-labels%1488)] [the-number-of-instructions%1490 (- (length the-code%1477) the-number-of-labels%1488)] [the-offsets%1491 (make-vector (vector-length the-labels%1479) -1)] [get-ref%1492 (lambda (label%1493) (let ([s%1494 (symbol->string label%1493)]) (letrec ([loop%1495 (lambda (mini%1496 maxi%1497) (if (< (- maxi%1497 mini%1496) 3) (if (string=? (car (vector-ref the-labels%1479 mini%1496)) s%1494) (cdr (vector-ref the-labels%1479 mini%1496)) (if (string=? (car (vector-ref the-labels%1479 (+ mini%1496 1))) s%1494) (cdr (vector-ref the-labels%1479 (+ mini%1496 1))) (if (string=? (car (vector-ref the-labels%1479 (+ mini%1496 2))) s%1494) (cdr (vector-ref the-labels%1479 (+ mini%1496 2))) (if (string=? (car (vector-ref the-labels%1479 (+ mini%1496 3))) s%1494) (cdr (vector-ref the-labels%1479 (+ mini%1496 3))) (error 'crossref "label not found: ~s" label%1493))))) (let ([median%1498 (quotient (+ mini%1496 maxi%1497) 2)]) (if (string<? (car (vector-ref the-labels%1479 median%1498)) s%1494) (loop%1495 median%1498 maxi%1497) (loop%1495 mini%1496 median%1498)))))]) (loop%1495 0 maxi%1489))))]) (letrec ([loop%1499 (lambda (is%1500 pc%1501) (if (null? is%1500) (if (= pc%1501 the-number-of-instructions%1490) (k%1478 get-ref%1492) (error 'crossref "mismatching numbers: ~s and ~s" pc%1501 the-number-of-instructions%1490)) (let ([i%1502 (car is%1500)] [is%1503 (cdr is%1500)]) (let ([case%1504 (car i%1502)]) (if (eqv? case%1504 'label) (loop%1499 is%1503 pc%1501) (if (eqv? case%1504 'jump) (begin (vector-set! table-code-rator pc%1501 'jump) (vector-set! table-code-rands pc%1501 (get-ref%1492 (cadr i%1502))) (loop%1499 is%1503 (1+ pc%1501))) (if (eqv? case%1504 'jump-if-false) (begin (vector-set! table-code-rator pc%1501 'jump-if-false) (let ([rands%1505 (list->vector (cdr i%1502))]) (begin (vector-set! rands%1505 2 (get-ref%1492 (vector-ref rands%1505 2))) (vector-set! table-code-rands pc%1501 rands%1505))) (loop%1499 is%1503 (1+ pc%1501))) (if (eqv? case%1504 'new-vec) (begin (vector-set! table-code-rator pc%1501 'new-vec) (vector-set! table-code-rands pc%1501 (cadr i%1502)) (loop%1499 is%1503 (1+ pc%1501))) (if (if (eqv? case%1504 'move) #t (if (eqv? case%1504 'load) #t (if (eqv? case%1504 'call) #t (if (eqv? case%1504 'tail-call) #t (if (eqv? case%1504 'extend) #t (eqv? case%1504 'return)))))) (begin (vector-set! table-code-rator pc%1501 (car i%1502)) (vector-set! table-code-rands pc%1501 (list->vector (cdr i%1502))) (loop%1499 is%1503 (1+ pc%1501))) (error 'crossref "Illegal instruction: ~s" i%1502))))))))))]) (begin (set! table-code-rator (make-vector (+ the-number-of-instructions%1490 1) '())) (vector-set! table-code-rator the-number-of-instructions%1490 'halt) (set! table-code-rands (make-vector (+ the-number-of-instructions%1490 1) '())) (vector-set! table-code-rands the-number-of-instructions%1490 (vector)) (loop%1499 the-code%1477 0))))))
(define *tick-tock* 0)
(define tick-tock (lambda () (if (< *tick-tock* 1000) (set! *tick-tock* (+ *tick-tock* 1)) (begin (display "." (current-output-port)) (set! *tick-tock* 0)))))
(define make-Control-frame (lambda (ip_ env-lex_ tmp_ cont_) (vector 'Control-frame ip_ env-lex_ tmp_ cont_)))
(define is-Control-frame? (lambda (record%1506) (if (vector? record%1506) (if (= (vector-length record%1506) 5) (eqv? (vector-ref record%1506 0) 'Control-frame) #f) #f)))
(define make-Control-frame-initial (lambda () (vector 'Control-frame-initial)))
(define is-Control-frame-initial? (lambda (record%1507) (if (vector? record%1507) (if (= (vector-length record%1507) 1) (eqv? (vector-ref record%1507 0) 'Control-frame-initial) #f) #f)))
(define run-instructions (lambda () (letrec ([loop%1508 (lambda (ip%1511 env-lex%1512 vec%1513 cont%1514) (begin (if verbose (if (eqv? trace-vm 0) "Shhh" (if (eqv? trace-vm 1) (begin (write ip%1511) (display ": ") (write (cons (vector-ref table-code-rator ip%1511) (let ([rand%1515 (vector-ref table-code-rands ip%1511)]) (if (vector? rand%1515) (vector->list rand%1515) (list rand%1515)))) (current-output-port)) (if (if (eqv? (vector-ref table-code-rator ip%1511) 'check-and-jump) (eqv? (vector-ref (vector-ref table-code-rands ip%1511) 0) 'lib) #f) (begin (write-char (integer->char 9) (current-output-port)) (display "; " (current-output-port)) (write (list-ref predefined-procedures (vector-ref (vector-ref table-code-rands ip%1511) 1)))) "ikke noget") (newline (current-output-port))) (if (eqv? trace-vm 2) (begin (newline (current-output-port)) (write (cons (vector-ref table-code-rator ip%1511) (let ([rand%1516 (vector-ref table-code-rands ip%1511)]) (if (vector? rand%1516) (vector->list rand%1516) (list rand%1516)))) (current-output-port)) (newline (current-output-port)) (write (map (lambda (v%1517) (map DS2S (vector->list v%1517))) env-lex%1512) (current-output-port)) (newline (current-output-port)) (write (map DS2S (vector->list env-tmp)) (current-output-port)) (newline (current-output-port)) (write cont%1514 (current-output-port)) (newline (current-output-port))) (tick-tock)))) (tick-tock)) (let ([rands%1518 (vector-ref table-code-rands ip%1511)]) (let ([case%1519 (vector-ref table-code-rator ip%1511)]) (if (eqv? case%1519 'jump) (loop%1508 rands%1518 env-lex%1512 vec%1513 cont%1514) (if (eqv? case%1519 'jump-if-false) (if (let ([case-record%1521 (vector-ref (let ([kind%1520 (vector-ref rands%1518 0)]) (if (eqv? kind%1520 'res) aux-res (if (eqv? kind%1520 'tmp) env-tmp (if (eqv? kind%1520 'glo) env-glo (if (eqv? kind%1520 'lib) env-lib (list-ref env-lex%1512 kind%1520)))))) (vector-ref rands%1518 1))]) (if (is-DS-false? case-record%1521) (let () #f) #t)) (loop%1508 (1+ ip%1511) env-lex%1512 vec%1513 cont%1514) (loop%1508 (vector-ref rands%1518 2) env-lex%1512 vec%1513 cont%1514)) (if (eqv? case%1519 'new-vec) (loop%1508 (1+ ip%1511) env-lex%1512 (make-vector (vector-ref table-code-rands ip%1511) DS-nil) cont%1514) (if (eqv? case%1519 'extend) (loop%1508 (+ ip%1511 1) (cons vec%1513 env-lex%1512) vec%1513 cont%1514) (if (eqv? case%1519 'move) (begin (vector-set! (let ([kind%1522 (vector-ref rands%1518 2)]) (if (eqv? kind%1522 'res) aux-res (if (eqv? kind%1522 'tmp) env-tmp (if (eqv? kind%1522 'glo) env-glo (if (eqv? kind%1522 'lib) env-lib (if (eqv? kind%1522 'vec) vec%1513 (list-ref env-lex%1512 kind%1522))))))) (vector-ref rands%1518 3) (vector-ref (let ([kind%1523 (vector-ref rands%1518 0)]) (if (eqv? kind%1523 'res) aux-res (if (eqv? kind%1523 'tmp) env-tmp (if (eqv? kind%1523 'glo) env-glo (if (eqv? kind%1523 'lib) env-lib (list-ref env-lex%1512 kind%1523)))))) (vector-ref rands%1518 1))) (loop%1508 (1+ ip%1511) env-lex%1512 vec%1513 cont%1514)) (if (eqv? case%1519 'load) (begin (vector-set! (let ([kind%1524 (vector-ref rands%1518 2)]) (if (eqv? kind%1524 'res) aux-res (if (eqv? kind%1524 'tmp) env-tmp (if (eqv? kind%1524 'glo) env-glo (if (eqv? kind%1524 'lib) env-lib (if (eqv? kind%1524 'vec) vec%1513 (list-ref env-lex%1512 kind%1524))))))) (vector-ref rands%1518 3) (let ([kind%1525 (vector-ref rands%1518 0)]) (if (eqv? kind%1525 'nil) DS-nil (if (eqv? kind%1525 'bool) (let ([offset%1526 (vector-ref rands%1518 1)]) (if (= offset%1526 0) DS-false (if (= offset%1526 1) DS-true (error 'run "not a boolean: ~s" offset%1526)))) (if (eqv? kind%1525 'int) (make-DS-integer (vector-ref rands%1518 1)) (if (eqv? kind%1525 'char) (make-DS-char (integer->char (vector-ref rands%1518 1))) (if (eqv? kind%1525 'str) (make-DS-string (vector-ref rands%1518 1)) (if (eqv? kind%1525 'sym) (make-DS-symbol (vector-ref rands%1518 1)) (if (eqv? kind%1525 'close-flat) (make-DS-closure (vector-ref rands%1518 1) (list vec%1513) (gensym! "flat-closure%")) (if (eqv? kind%1525 'close-deep) (make-DS-closure (vector-ref rands%1518 1) env-lex%1512 (gensym! "deep-closure%")) (if (eqv? kind%1525 'void) DS-void (list-ref env-lex%1512 kind%1525)))))))))))) (loop%1508 (1+ ip%1511) env-lex%1512 vec%1513 cont%1514)) (if (eqv? case%1519 'tail-call) (application%1509 (vector-ref (let ([kind%1527 (vector-ref rands%1518 0)]) (if (eqv? kind%1527 'res) aux-res (if (eqv? kind%1527 'tmp) env-tmp (if (eqv? kind%1527 'glo) env-glo (if (eqv? kind%1527 'lib) env-lib (list-ref env-lex%1512 kind%1527)))))) (vector-ref rands%1518 1)) vec%1513 cont%1514) (if (eqv? case%1519 'call) (application%1509 (vector-ref (let ([kind%1528 (vector-ref rands%1518 0)]) (if (eqv? kind%1528 'res) aux-res (if (eqv? kind%1528 'tmp) env-tmp (if (eqv? kind%1528 'glo) env-glo (if (eqv? kind%1528 'lib) env-lib (list-ref env-lex%1512 kind%1528)))))) (vector-ref rands%1518 1)) vec%1513 (make-Control-frame (+ ip%1511 1) env-lex%1512 (vector-copy-prefix env-tmp (vector-ref rands%1518 2)) cont%1514)) (if (eqv? case%1519 'return) (continue%1510 cont%1514) (if (eqv? case%1519 'halt) (make-DS-string "halt") (if (eqv? case%1519 'nop) (loop%1508 (+ ip%1511 1) env-lex%1512 vec%1513 cont%1514) (error 'run "Illegal instruction: ~s" (vector-ref table-code-rator ip%1511)))))))))))))))))] [application%1509 (lambda (c%1529 vec%1530 cont%1531) (if (is-DS-closure? c%1529) (let ([offset_ (vector-ref c%1529 1)] [env-lex_ (vector-ref c%1529 2)] [unique-tag_ (vector-ref c%1529 3)]) (let ([arity%1532 (vector-ref table-lam-arity offset_)]) (loop%1508 (vector-ref table-lam-entry offset_) (cons (if (= arity%1532 (vector-length vec%1530)) vec%1530 (if (= arity%1532 -1) (vector (vector->DS-list vec%1530)) (error 'user-procedure-application "arity mismatch for closure number ~s: ~s and ~s" offset_ arity%1532 (vector->list vec%1530)))) env-lex_) (vector) cont%1531))) (if (is-DS-primitive? c%1529) (let ([name_ (vector-ref c%1529 1)] [arity_ (vector-ref c%1529 2)] [p_ (vector-ref c%1529 3)]) (begin (check-arity name_ arity_ vec%1530) (if (eqv? p_ 'apply) (begin (check-type 'apply vec%1530 'procedure) (check-DS-proper-list? (vector-ref vec%1530 1)) (application%1509 (vector-ref vec%1530 0) (DS-list->vector (vector-ref vec%1530 1)) cont%1531)) (if (eqv? p_ 'call/cc) (begin (check-type 'call/cc vec%1530 'procedure) (application%1509 (vector-ref vec%1530 0) (vector (make-DS-continuation cont%1531)) cont%1531)) (p_ vec%1530 (lambda () (continue%1510 cont%1531))))))) (if (is-DS-continuation? c%1529) (let ([cont_ (vector-ref c%1529 1)]) (if (= 1 (vector-length vec%1530)) (begin (vector-set! aux-res 0 (vector-ref vec%1530 0)) (continue%1510 cont_)) (error 'continuation-application "arity mismatch: ~s" (vector->list vec%1530)))) (error 'application "unapplicable value: ~s" c%1529)))))] [continue%1510 (lambda (cont%1533) (if (is-Control-frame? cont%1533) (let ([ip_ (vector-ref cont%1533 1)] [env-lex_ (vector-ref cont%1533 2)] [tmp_ (vector-ref cont%1533 3)] [cont_ (vector-ref cont%1533 4)]) (begin (vector-restore-prefix! env-tmp tmp_) (loop%1508 ip_ env-lex_ (vector) cont_))) (if (is-Control-frame-initial? cont%1533) (let () (vector-ref aux-res 0)) (error 'application "fudged continuation: ~s" cont%1533))))]) (loop%1508 0 '() (vector) (make-Control-frame-initial)))))
(define run-program (lambda (p%1534) (if (is-Compiled-Program? p%1534) (let ([number-of-global-definitions_ (vector-ref p%1534 1)] [number-of-temporaries_ (vector-ref p%1534 2)] [number-of-results_ (vector-ref p%1534 3)] [the-lambdas_ (vector-ref p%1534 4)] [the-code_ (vector-ref p%1534 5)] [the-tag_ (vector-ref p%1534 6)]) (begin (warn "Initializing ") (set! env-lib (vector-copy env-lib-reference)) (set! env-glo (make-vector number-of-global-definitions_ DS-undefined)) (set! env-tmp (make-vector number-of-temporaries_ DS-nil)) (set! aux-res (make-vector number-of-results_ DS-nil)) (let ([number-of-lambdas%1535 (length the-lambdas_)]) (begin (set! table-lam-arity (make-vector number-of-lambdas%1535 0)) (letrec ([walk%1536 (lambda (n%1537 ls%1538) (if (= n%1537 number-of-lambdas%1535) 'done (begin (vector-set! table-lam-arity n%1537 (caar ls%1538)) (walk%1536 (+ n%1537 1) (cdr ls%1538)))))]) (walk%1536 0 the-lambdas_)))) (crossref the-code_ (lambda (lookup-ref%1539) (begin (set! table-lam-arity (list->vector (map1 car the-lambdas_))) (set! table-lam-entry (list->vector (map1 (lambda (a%1540) (lookup-ref%1539 (cadr a%1540))) the-lambdas_))) (warnl "/ initialized") (run-instructions)))))) (error 'run-program "not a compiled program"))))
(define trace-vm 0)
(define verbose #t)
(define pretty #t)
(define strip-Scheme-filename (lambda (filename%1541) (if (not (string? filename%1541)) (error 'strip-Scheme-filename "not a file name: ~s" filename%1541) (if (string-suffix? filename%1541 ".scm") (substring filename%1541 0 (- (string-length filename%1541) 4)) filename%1541))))
(define normalize-Scheme-filename (lambda (filename%1542) (if (string-suffix? filename%1542 ".scm") filename%1542 (string-append filename%1542 ".scm"))))
(define asm (lambda (filename%1543) (begin (reset-gensym!) (codegen-program (factorize-program (scope-program (linearize-program (box-program (desugar-program (parse-program (read-file (normalize-Scheme-filename filename%1543))))))))))))
(define asmp (lambda (filename%1544) (begin (let ([case-record%1545 (asm filename%1544)]) (if (is-Compiled-Program? case-record%1545) (let ([number-of-global-definitions_ (vector-ref case-record%1545 1)] [number-of-temporaries_ (vector-ref case-record%1545 2)] [number-of-results_ (vector-ref case-record%1545 3)] [the-lambdas_ (vector-ref case-record%1545 4)] [the-code_ (vector-ref case-record%1545 5)] [the-tag_ (vector-ref case-record%1545 6)]) (list 'DAIMI-SchemeE03 (list number-of-global-definitions_ number-of-temporaries_ number-of-results_) the-lambdas_ the-code_ the-tag_)) (error asmp "not a compiled program"))))))
(define dump (lambda (filename%1546) (let ([filename%1547 (strip-Scheme-filename filename%1546)]) (let ([p%1548 (asm (string-append filename%1547 ".scm"))]) (call-with-output-file (string-append filename%1547 ".dsa") (lambda (port%1549) (dump-compiled-program p%1548 port%1549)))))))
(define run (lambda (x%1550) ((if pretty DS2S (lambda (a%1551) a%1551)) (run-program (if (string? x%1550) (if (string-suffix? x%1550 ".scm") (asm x%1550) (if (string-suffix? x%1550 ".dsa") (let ([dsa%1552 (call-with-input-file x%1550 read)]) (if (eqv? (car dsa%1552) 'DAIMI-SchemeE03) (let* ([rest%1553 (cdr dsa%1552)] [g%1554 (car rest%1553)] [rest%1555 (cdr rest%1553)] [the-lambdas%1556 (car rest%1555)] [rest%1557 (cdr rest%1555)] [the-code%1558 (car rest%1557)] [the-tag%1559 (car (cdr rest%1557))]) (apply (lambda (number-of-global-definitions%1560 number-of-temporaries%1561 number-of-results%1562) (make-Compiled-Program number-of-global-definitions%1560 number-of-temporaries%1561 number-of-results%1562 the-lambdas%1556 the-code%1558 the-tag%1559)) g%1554)) (error 'run "invalid header in ~s" x%1550))) (asm (string-append x%1550 ".scm")))) x%1550)))))
(dump "tests/Bootstrap/cmp-boxed.scm")
