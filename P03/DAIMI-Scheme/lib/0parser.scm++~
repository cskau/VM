;;; DAIMI-Scheme/lib/0parser.scm++ -*- Scheme -*-
;;; extension

;;; (define (fun-name arg1 ... argn) exp+)
;;; (lambda (arg+) exp+)
;;; (cond (test exp+) ... (else exp+))
;;; (let (binding++) exp++)
;;; (let+ (binding++) exp++)
;;; (letrec (binding++) exp++)
;;; (case exp [(ide+) exp++] ... [[(ide+) exp++] [else exp++]))
;;; (let loop ((arg init)+) body)

;;; (do ((var1 init1 up1)
;;;      ...)
;;;     (test exp1 exp2 ... expn)
;;;   command ...)


;;; DAIMI-Scheme/lib/0parser.scm
;;; a raw parser for DAIMI Scheme
;;; Olivier Danvy <danvy@brics.dk>
;;; October 2002, October 2003


;;;;;;;;;;
;;; AST declarations:

(define-record (Parsed-Program the-definitions the-expression))

(define-record (DefRec name fields))
(define-record (DefExp name expression))

(define-record (Literal literal))
(define-record (Variable variable))
(define-record (Abstraction formals body))
(define-record (IfThenElse test-exp then-exp else-exp))
(define-record (Assign variable expression))
(define-record (Application procedure arguments))

(define-record (CondExpr tests consequents))
(define-record (CaseExpr test headers expressions))
(define-record (CaseRecordExpr test headers expressions))
(define-record (ConjExpr expressions))
(define-record (DisjExpr expressions))
(define-record (LetExpr formals expressions body))
(define-record (SLetExpr formals expressions body))
(define-record (LetRecExpr formals lambdas expression))
(define-record (SequenceExpr expressions))
(define-record (Suspend expression))
(define-record (Delay expression))

(define-record (Quotation expression))

(define-record (Integer i))
(define-record (Boolean b))
(define-record (String s))
(define-record (Character s))
(define-record (Symbol s))
(define-record (Nil))
(define-record (Void))


;;;;;;;;;;
;;; Misc. predicates:

(define variable?
  (lambda (e)
    (and (symbol? e)
	 (not (member e '(define
			  lambda
			  if
			  set!
			  let
			  let*
			  letrec
			  cond
			  case
			  else
			  and
			  or
			  begin
			  delay
			  suspend
			  define-record
			  case-record
			  quote))))))

(define all-different?
  (lambda (xs)
    (or (null? xs)
	(and (not (memq (car xs) (cdr xs)))
	     (all-different? (cdr xs))))))

(define is-load?
  (lambda (exp)
    (and (pair? exp)
	 (eqv? (car exp) 'load)
	 (pair? (cdr exp))
	 (string? (cadr exp))
	 (null? (cddr exp)))))

(define is-load-relative?
  (lambda (exp)
    (and (pair? exp)
	 (eqv? (car exp) 'load-relative)
	 (pair? (cdr exp))
	 (string? (cadr exp))
	 (null? (cddr exp)))))

(define proper-list++?
  (lambda (e n)
    (letrec ([loop (lambda (e n)
		     (if (zero? n)
			 (null? e)
			 (and (pair? e)
			      (loop (cdr e) (- n 1)))))])
      (loop e n))))

(define is-define-record?
  (lambda (d)
    (and (proper-list++? d 2)
	 (equal? (car d) 'define-record)
	 (andmap1 variable? (cadr d))
	 (all-different? (cadr d)))))

(define is-definition?
  (lambda (d)
    (and (proper-list++? d 3)
	 (equal? (car d) 'define)
	 (variable? (cadr d)))))

;;; ++
(define is-sicp-definition?
  (lambda (d)
    (and (proper-list? d)
	 (equal? (car d) 'define)
	 (proper-list? (cadr d)))))

(define quote-ok?
  (lambda (e)
    (proper-list++? e 2)))

(define lambda-ok?
  (lambda (e)
    (and (proper-list++? e 3)
	 (equal? (car e) 'lambda)
	 (or (variable? (cadr e))
	     (and (andmap1 variable? (cadr e))
		  (all-different? (cadr e)))))))

;;; ++
(define lambda-sicp-ok?
  (lambda (e)
    (and (proper-list? e)
	 (equal? (car e) 'lambda)
	 (or (variable? (cadr e))
	     (and (andmap1 variable? (cadr e))
		  (all-different? (cadr e)))))))

(define if-ok?
  (lambda (e)
    (proper-list++? e 4)))

(define cond-ok?
  (lambda (e)
    (and (proper-list? e)
	 (andmap1 (lambda (clause)
		   (proper-list++? clause 2))
		 (cdr e))
	 (equal? (caar (last-pair e)) 'else))))

;;; ++
(define cond-sicp-ok?
  (lambda (e)
    (and (proper-list? e)
	 (andmap1 (lambda (clause)
		   (proper-list? clause))
		 (cdr e))
	 (equal? (caar (last-pair e)) 'else))))

(define case-ok?
  (lambda (e)
    (and (proper-list? e)
	 (pair? (cdr e))
	 (pair? (cddr e))
	 (andmap1 (lambda (clause)
		   (and (proper-list++? clause 2)
			(or (eqv? (car clause) 'else)
			    (and (proper-list? (car clause))
				 (andmap1 (lambda (v)
					   (or (symbol? v)
					       (integer? v)
					       (boolean? v)
					       (char? v)))
					 (car clause))))))
		 (cddr e))
	 (equal? (caar (last-pair e)) 'else))))

;;; ++
(define case-sicp-ok?
  (lambda (e)
    (and (proper-list? e)
	 (pair? (cdr e))
	 (pair? (cddr e))
	 (andmap1 (lambda (clause)
		   (and (proper-list? clause)
			(or (eqv? (car clause) 'else)
			    (and (proper-list? (car clause))
				 (andmap1 (lambda (v)
					   (or (symbol? v)
					       (integer? v)
					       (boolean? v)
					       (char? v)))
					 (car clause))))))
		 (cddr e))
	 (equal? (caar (last-pair e)) 'else))))

(define case-record-ok?
  (lambda (e)
    (and (proper-list? e)
	 (pair? (cdr e))
	 (pair? (cddr e))
	 (andmap1 (lambda (clause)
		   (and (proper-list++? clause 2)
			(or (eqv? (car clause) 'else)
			    (and (proper-list? (car clause))
				 (andmap1 variable? (car clause))
				 (all-different? (car clause))))))
		  (cddr e))
	 (equal? (caar (last-pair e)) 'else))))

(define and-ok?
  (lambda (e)
    (proper-list? e)))

(define or-ok? and-ok?)

(define let-ok?
  (lambda (e)
    (and (proper-list++? e 3)
	 (let ([clauses (cadr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(let ([xs (map car clauses)])
		  (and (andmap1 variable? xs)
		       (all-different? xs))))))))

;;; ++
(define let-sicp-ok?
  (lambda (e)
    (and (proper-list? e)
	 (let ([clauses (cadr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(let ([xs (map car clauses)])
		  (and (andmap1 variable? xs)
		       (all-different? xs))))))))

;;; ++
(define let-named-ok?
  (lambda (e)
    (and (proper-list? e)
	 (let ([name (cadr e)]
	       [clauses (caddr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(let ([xs (map car clauses)])
		  (and (andmap1 variable? xs)
		       (all-different? xs))))))))

(define let*-ok?
  (lambda (e)
    (and (proper-list++? e 3)
	 (let ([clauses (cadr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(let ([xs (map car clauses)])
		  (andmap1 variable? xs)))))))

;;; ++
(define let*-sicp-ok?
  (lambda (e)
    (and (proper-list? e)
	 (let ([clauses (cadr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(let ([xs (map car clauses)])
		  (andmap1 variable? xs)))))))

(define letrec-ok?
  (lambda (e)
    (and (proper-list++? e 3)
	 (let ([clauses (cadr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(andmap1 lambda-ok? (map cadr clauses))
		(let ([xs (map car clauses)])
		  (and (andmap1 variable? xs)
		       (all-different? xs))))))))

;;;
(define letrec-sicp-ok?
  (lambda (e)
    (and (proper-list? e)
	 (let ([clauses (cadr e)])
	   (and (proper-list? clauses)
		(andmap1 (lambda (e)
			  (proper-list++? e 2))
			clauses)
		(andmap1 lambda-ok? (map cadr clauses))
		(let ([xs (map car clauses)])
		  (and (andmap1 variable? xs)
		       (all-different? xs))))))))

(define suspend-ok?
  (lambda (e)
    (proper-list++? e 2)))

(define delay-ok?
  (lambda (e)
    (proper-list++? e 2)))

(define begin-ok?
  (lambda (e)
    (and (pair? (cdr e))
	 (proper-list? e))))

(define call-ok?
  (lambda (e)
    (and (pair? e)
	 (proper-list? e))))

(define set!-ok?
  (lambda (e)
    (and (proper-list++? e 3)
	 (variable? (cadr e)))))

;;; ++
(define do-ok?
  (lambda (e)
    (and (proper-list? e)
	 (>= (length e) 3)
	 (let ([clauses (cadr e)]
	       [increment (caddr e)]
	       [commands (cdddr e)])
	   (and (andmap1 (lambda (clause)
			   (proper-list++? clause 3))
			 clauses)
		(proper-list? increment)
		(pair? increment))))))

;;;;;;;;;;
;;; Main parsing procedures:

(define parse-record
  (lambda (r)
    (let ([h (cadr r)])
      (make-DefRec (car h) (cdr h)))))

(define parse-quote
  (lambda (e)
    (make-Quotation e)))

(define parse-expression
  (lambda (e)
    (cond
      [(pair? e)
       (case (car e)
	 [(quote)
	  (if (quote-ok? e)
	      (parse-quote (cadr e))
	      (error 'parse-expression "Illegal quote: ~s" e))]
         [(lambda)
	  (if (lambda-ok? e)
	      (make-Abstraction (cadr e) (parse-expression (caddr e)))
	      (if (lambda-sicp-ok? e)	;;; ++
		  (make-Abstraction (cadr e) (parse-expression (cons 'begin (cddr e))))
		  (error 'parse-expression "Illegal lambda: ~s" e)))]
         [(if)
	  (if (if-ok? e)
	      (make-IfThenElse (parse-expression (cadr e))
			       (parse-expression (caddr e))
			       (parse-expression (cadddr e)))
	      (error 'parse-expression "Illegal if: ~s" e))]
	 [(cond)
	  (if (cond-ok? e)
	      (make-CondExpr
		(letrec ([walk
			  (lambda (es)
			    (let ([e (car (car es))]
				  [es (cdr es)])
			      (if (null? es)
				  (list e)	;;; else
				  (cons (parse-expression e)
					(walk es)))))])
		  (walk (cdr e)))
		(map (compose parse-expression cadr) (cdr e)))
	      (if (cond-sicp-ok? e)	;;; ++
		  (make-CondExpr
		   (letrec ([walk
			     (lambda (es)
			       (let ([e (car (car es))]
				     [es (cdr es)])
				 (if (null? es)
				     (list e)	;;; else
				     (cons (parse-expression e)
					   (walk es)))))])
		     (walk (cdr e)))
		   (map (lambda (clause)
			  (if (null? (cddr clause))
			      (cadr clause)
			      (cons 'begin (cdr clause))))
			(cdr e)))
		  (error 'parse-expression "Illegal cond: ~s" e)))]
	 [(case)
	  (if (case-ok? e)
	      (make-CaseExpr (parse-expression (cadr e))
			     (map car (cddr e))
			     (map (compose parse-expression cadr)
				  (cddr e)))
	      (if (case-sicp-ok? e)	;;; ++
		  (make-CaseExpr (parse-expression (cadr e))
				 (map car (cddr e))
				 (map (lambda (clause)
					(if (null? (cddr clause))
					    (cadr clause)
					    (cons 'begin (cdr clause))))
				      (cddr e)))
		  (error 'parse-expression "Illegal case: ~s" e)))]
	 [(case-record)
	  (if (case-record-ok? e)
	      (make-CaseRecordExpr (parse-expression (cadr e))
				   (map car (cddr e))
				   (map (compose parse-expression cadr)
					(cddr e)))
	      (error 'parse-expression "Illegal case-record: ~s" e))]
	 [(and)
	  (if (and-ok? e)
	      (make-ConjExpr (map parse-expression (cdr e)))
	      (error 'parse-expression "Illegal and: ~s" e))]
	 [(or)
	  (if (or-ok? e)
	      (make-DisjExpr (map parse-expression (cdr e)))
	      (error 'parse-expression "Illegal or: ~s" e))]
         [(let)
	  (if (let-ok? e)
	      (let ([clauses (cadr e)])
		(if (null? clauses)
		    (parse-expression (caddr e))
		    (make-LetExpr (map car clauses)
				  (map (compose parse-expression cadr)
				       clauses)
				  (parse-expression (caddr e)))))
	      (if (let-sicp-ok? e)
		  (let ([clauses (cadr e)])
		    (if (null? clauses)
			(parse-expression (cons 'begin (cddr e)))
			(make-LetExpr (map car clauses)
				      (map (compose parse-expression cadr)
					   clauses)
				      (parse-expression (cons 'begin (cddr e))))))
		  (if (let-named-ok? e)
		      (let ([name (cadr e)]
			    [clauses (caddr e)]
			    [body (if (null? (cddddr e))
				      (cadddr e)
				      (cons 'begin (cdddr e)))])
			(parse-expression (list 'letrec (list (list name (list 'lambda (map car clauses)
							     body)))
					     (cons name (map cadr clauses)))))
		      (error 'parse-expression "Illegal let: ~s" e))))]
         [(let*)
	  (if (let*-ok? e)
	      (let ([clauses (cadr e)])
		(if (null? clauses)
		    (parse-expression (caddr e))
		    (make-SLetExpr (map car clauses)
				   (map (compose parse-expression cadr)
					clauses)
				   (parse-expression (caddr e)))))
	      (if (let*-sicp-ok? e)
		  (let ([clauses (cadr e)])
		    (if (null? clauses)
			(parse-expression (cons 'begin (cdddr e)))
			(make-SLetExpr (map car clauses)
				       (map (compose parse-expression cadr)
					    clauses)
				       (parse-expression (cons 'begin (cddr e))))))
		  (error 'parse-expression "Illegal let*: ~s" e)))]
         [(letrec)
	  (if (letrec-ok? e)
	      (let ([clauses (cadr e)])
		(if (null? clauses)
		    (parse-expression (caddr e))
		    (make-LetRecExpr (map car clauses)
				     (map (compose parse-expression cadr)
					  clauses)
				     (parse-expression (caddr e)))))
	      (if (letrec-sicp-ok? e)
		  (let ([clauses (cadr e)])
		    (if (null? clauses)
			(parse-expression (cons 'begin (cdddr e)))
			(make-LetRecExpr (map car clauses)
					 (map (compose parse-expression cadr)
					      clauses)
					 (parse-expression (cons 'begin (cdddr e))))))
	      (error 'parse-expression "Illegal letrec: ~s" e)))]
	 [(begin)
	  (if (begin-ok? e)
	      (make-SequenceExpr (map parse-expression (cdr e)))
	      (error 'parse-expression "Illegal begin: ~s" e))]
	 [(suspend)
	  (if (suspend-ok? e)
	      (make-Suspend (parse-expression (cadr e)))
	      (error 'parse-expression "Illegal suspend: ~s" e))]
	 [(delay)
	  (if (delay-ok? e)
	      (make-Delay (parse-expression (cadr e)))
	      (error 'parse-expression "Illegal delay: ~s" e))]
	 [(set!)
	  (if (set!-ok? e)
	      (make-Assign (cadr e) (parse-expression (caddr e)))
	      (error 'parse-expression "Illegal set!: ~s" e))]
	 [(do)	;;; ++
	  (if (do-ok? e)
	      (let ([clauses (cadr e)]
		    [increment (caddr e)]
		    [commands (cddr e)])
		(let ([loop-name (gensym! "do%")]
		      [header (map (lambda (clause)
				     (list (car clause) (cadr clause)))
				   clauses)]
		      [test (car increment)]
		      [increments (cdr increment)]
		      [actuals (map (lambda (clause)
				      (caddr clause))
				    clauses)])
		  (parse-expression
		    (list 'let loop-name header
		      (list 'if
                            test
			    (if (null? increments)
			       "done"
			       (cons 'begin increments))
			    (if (null? commands)
			       (cons loop-name actuals)
			       (cons 'begin (append commands (list (cons loop-name actuals))))))))))
	      (error 'parse-expression "Illegal do: ~s" e))]
         [else
	  (if (call-ok? e)
	      (make-Application (parse-expression (car e))
				(map parse-expression (cdr e)))
	      (error 'parse-expression "Illegal call: ~s" e))])]
      [(integer? e)
       (make-Literal (make-Integer e))]
      [(boolean? e)
       (make-Literal (make-Boolean e))]
      [(string? e)
       (make-Literal (make-String e))]
      [(char? e)
       (make-Literal (make-Character e))]
      [(variable? e)
       (make-Variable e)]
      [else
       (error 'parse-expression "Unrecognized expression: ~s" e)])))

(define parse-definition
  (lambda (d)
    (make-DefExp (cadr d) (parse-expression (caddr d)))))


;;;;;;;;;;
;;; Main procedure:

(define parse-program
  (lambda (p)
    (letrec ([traverse
	      (lambda (p the-definitions)
		(cond
		  [(null? (cdr p))
		   (make-Parsed-Program
		     (reverse the-definitions)
		     (parse-expression (car p)))]
		  [(is-define-record? (car p))
		   (traverse (cdr p)
			     (cons (parse-record (car p))
				   the-definitions))]
		  [(is-definition? (car p))
		   (traverse (cdr p)
			     (cons (parse-definition (car p))
				   the-definitions))]
		  [(is-sicp-definition? (car p))	;;; ++
		   (traverse (cdr p)
			     (cons (parse-definition (list 'define (caadr (car p))
							(list 'lambda (cdadr (car p))
							  (let ([bodies (cddar p)])
							     (if (null? (cdr bodies))
								 (car bodies)
								 (cons 'begin bodies))))))
				   the-definitions))]
		  [else
		   (error 'parse-program "quasar: ~s" p)]))])
      (begin
	(warn "Parsing")
	(let ([q (traverse p '())])
	  (begin
	    (warnl " / Parsed")
	    q))))))


;;;;;;;;;;
;;; Read the file into an S-expression:

(define read-file
  (letrec ([read-the-file
	    (lambda (f fs d)
	      (begin
		(warn (string-append "(" f))
		(let ([q (call-with-input-file
			   f
			   (lambda (port)
			     (letrec ([next
				       (lambda ()
					 (let ([x (read port)])
					   (cond
					     [(eof-object? x)
					      '()]
					     [(is-load? x)
					      (let ([f (cadr x)])
						(if (member f fs)
						    (error 'read-file
							   "circular load: ~s"
							   f)
						    (let ([stuff
							   (read-the-file
							     f
							     (cons f fs)
							     "")])
						      (append stuff
							      (next)))))]
					     [(is-load-relative? x)
					      (let ([f (cadr x)])
						(if (member f fs)
						    (error 'read-file
							   "circular load-relative: ~s"
							   f)
						    (let* ([actual-f
							    (if (char=? (string-ref f 0) #\/)
								f
								(string-append d f))]
							   [stuff
							    (read-the-file
							      actual-f
							      (cons f fs)
							      (extract-directory-name actual-f))])
						      (append stuff
							      (next)))))]
					     [else
					      (cons x (next))])))])
			       (next))))])
		  (begin
		    (warn ")")
		    q))))])
    (lambda (f)
      (let ([res (read-the-file f '() (extract-directory-name f))])
	(begin
	  (newline (current-output-port))
	  res)))))


;;;;;;;;;;

;;; end of "0parser.scm"
