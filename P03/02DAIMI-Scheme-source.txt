% 02DAIMI-Scheme-source.txt -*- text -*-
% dOvs'03

This file describes the lexical and syntactic aspects of our subset of
Scheme: DAIMI-Scheme, including its syntactic sugar.

All references to 'r5rs' are references to the 'Revised^5 Report on
the Algorithmic Language Scheme', which can be found at:

        <http://www.schemers.org/Documents/Standards/R5RS/>

-----------------------------------------------------------------------------

Notational conventions:

(1) All occurrences of
        <something>*
mean zero or more occurrences of <something>, with the exception of
        let*
that really means "the four-letter identifier let*" and of
        *
that really means "the one-letter identifier *" and of
        #\*
that really means "the character *".

(2) All occurrences of
        <something>+
mean one or more occurrences of <something>, with the exception of
        +
that really means "the one-letter identifier +" and of
        #\+
that really means "the character +".

(3) All occurrences of
        <something>?
mean zero or one occurrence of <something>, with the exception of
        ?, number?, procedure?, null?, ...
that are identifiers.

-----------------------------------------------------------------------------

Lexical structure (simplified version of Section 7.1.1 of the r5rs)
-----------------

          <token> ::= <identifier>
                    | <boolean>
                    | <numeral>
                    | <string>
                    | (
                    | )
                    | [
                    | ]
                    | '

      <delimiter> ::= "
                    | '
                    | (
                    | )
                    | [
                    | ]
                    | <whitespace>
                    | <comment>

<intertoken space> ::= <atmosphere>*

      <atmosphere> ::= <whitespace> | <comment>

      <whitespace> ::= <space or tabulation or newline>

         <comment> ::= ; <all subsequent characters up to a line break>

         <keyword> ::= define
                     | lambda
                     | if
                     | set!
                     | let
                     | let*
                     | letrec
                     | cond
                     | case
                     | else
                     | and
                     | or
                     | begin
                     | delay
                     | suspend
                     | define-record
                     | case-record
                     | quote
                     | load
                     | load-relative

        <variable> ::= <any <identifier> that is not also a <keyword>>

      <identifier> ::= <letter>+

          <letter> ::= a | b | c | ... | z
                     | A | B | C | ... | Z
                     | <digit>
                     | ! | $ | % | & | * | / | : | < | = | > | ? | ~ | _ | ^
                     | + | - | .

         <boolean> ::= #t
                     | #f

         <numeral> ::= <sign>? <digit>+

            <sign> ::= +
                     | -

           <digit> ::= 0 | 1 | 2 | ... | 9

          <string> ::= " <string element>* "
  <string element> ::= <any character other than " or \>
                     | \"
                     | \\

       <character> ::= #\<the character>

Identifiers are tokens that match the identifier regular expression but
none of the integer and keyword regular expressions.

S-expressions containing square brackets can be quoted,
and the square brackets are to be treated as round ones, as in Petite
Chez Scheme.

Keywords can be quoted.

-----------------------------------------------------------------------------

Misc. notes:

For simplicity, legal characters are the printable ones, ie,
        #\  #\! #\" #\# #\$ #\% #\& #\'
        #\( #\) #\* #\+ #\, #\- #\. #\/ 
        #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7
        #\8 #\9 #\: #\; #\< #\= #\> #\?
        #\@ #\A #\B #\C #\D #\E #\F #\G
        #\H #\I #\J #\K #\L #\M #\N #\O
        #\P #\Q #\R #\S #\T #\U #\V #\W
        #\X #\Y #\Z #\[ #\\ #\] #\^ #\_
        #\` #\a #\b #\c #\d #\e #\f #\g
        #\h #\i #\j #\k #\l #\m #\n #\o
        #\p #\q #\r #\s #\t #\u #\v #\w
        #\x #\y #\z #\{ #\| #\} #\~
        #\æ #\ø #\å #\Æ #\Ø #\Å
plus
        #\space
        #\tab
        #\newline

-----------------------------------------------------------------------------

Syntactic structure (simplified version of Section 7.1.2 and 7.1.3 of the r5rs)
-------------------

                   <program> ::= <prelude>* <expression>

                   <prelude> ::= (load <string>)
                               | (load-relative <string>)
                               | <definition>

                <definition> ::= (define-record (<variable> <variable>*))
                               | (define <variable> <expression>)

                <expression> ::= <literal>
                               | <variable>
                               | <lambda-abstraction>
                               | <conditional>
                               | <assignment>
                               | <derived expression>
                               | <procedure call>

                   <literal> ::= <constant>
                               | <quotation>

                  <constant> ::= <boolean>
                               | <numeral>
                               | <character>
                               | <string>

                 <quotation> ::= '<quoted datum>
                               | (quote <quoted datum>)

              <quoted datum> ::= <quoted simple datum>
                               | <quoted compound datum>

       <quoted simple datum> ::= <constant>
                               | <symbol>

                    <symbol> ::= <identifier>

     <quoted compound datum> ::= (<quoted datum>*)
                               | '<quoted datum>

        <lambda-abstraction> ::= (lambda <formals> <expression>)

                   <formals> ::= (<variable>*)
                               | <variable>

               <conditional> ::= (if <expression> <expression> <expression>)

                <assignment> ::= (set! <variable> <expression>)

        <derived expression> ::= (cond
                                   [<expression> <expression>]*
                                   [else <expression>])
                               | (case <expression>
                                   [(<simple datum>*) <expression>]*
                                   [else <expression>])
                               | (case-record <expression>
                                   [(<variable> <variable>*) <expression>]*
                                   [else <expression>])
                               | (and <expression>*)
                               | (or <expression>*)
                               | (let ([<variable> <expression>]*)
                                   <expression>)
                               | (let* ([<variable> <expression>]*)
                                   <expression>)
                               | (letrec ([<variable> <lambda-abstraction>]*)
                                   <expression>)
                               | (delay <expression>)
                               | (suspend <expression>)
                               | (begin <expression>* <expression>)

              <simple datum> ::= <boolean>
                               | <numeral>
                               | <character>
                               | <symbol>

            <procedure call> ::= (<expression> <expression>*)

-----------------------------------------------------------------------------

Misc. notes:

----------

(load <string>) is just a useful thing to have to be able to load files
of definitions.  The name of the file is either absolute (eg,
"/users/course/dOvs/...") or relative to the current directory in which
the compiler is running (eg, "foo.scm" or "lib/standard-prelude.scm").

NB. A loaded file must contain <prelude>* and only <prelude>*.

----------

(load-relative <string>) is like load except that the directory of the
loaded file is relative to the directory where the currently loaded file
resides.

Example: "foo.scm" is in the current directory.  It contains
    (load-relative "Bar/bar.scm")
and "bar.scm" contains 
    (load-relative "Baz/baz.scm").
When the compiler is called with "foo.scm", it imports the definitions
contained in "Bar/bar.scm" and also the definitions of "Bar/Baz/baz.scm".

----------

In the productions
                   <formals> ::= (<variable>*)
        <derived expression> ::= (let ([<variable> <expression>]*)
                                   <expression>)
                               | (letrec ([<variable> <lambda-abstraction>]*)
                                   <expression>)
                               | (case-record <expression>
                                   [(<variable> <variable>*) <expression>]*
                                   [else <expression>])
                <definition> ::= (define-record (<variable> <variable>*))
all variables should be distinct.

----------

Macro-definitions of define-record and case-record (for use in Petite
Chez Scheme) are available in
        /users/courses/dOvs/Scheme/records.scm

In general, the compatibility package to load in Petite Chez Scheme
in order to have a DAIMI-Scheme environment is in
        /users/courses/dOvs/Project03/DAIMI-Scheme/lib/standard-prelude.scm

-----------------------------------------------------------------------------

Predefined procedures
---------------------

Integers:
        integer?        -- as in r5rs
        +               -- binary, and otherwise as in r5rs
        -               -- binary, and otherwise as in r5rs
        *               -- binary, and otherwise as in r5rs
        quotient        -- as in r5rs
        remainder       -- as in r5rs
        <               -- binary, and otherwise as in r5rs
        <=              -- binary, and otherwise as in r5rs
        =               -- binary, and otherwise as in r5rs
        >=              -- binary, and otherwise as in r5rs
        >               -- binary, and otherwise as in r5rs

Booleans:
        boolean?        -- as in r5rs

Symbols:
        symbol?         -- as in r5rs

Characters:
        char?           -- as in r5rs
        char->integer   -- as in r5rs
        integer->char   -- as in r5rs

Strings:
        string          -- as in r5rs
        make-string     -- binary, and otherwise as in r5rs
        string?         -- as in r5rs
        string-length   -- as in r5rs
        string-append   -- binary, and otherwise as in r5rs
        string=?        -- as in r5rs
        string-ref      -- as in r5rs
        string->symbol  -- as in r5rs
        symbol->string  -- as in r5rs

Pairs:
        pair?           -- as in r5rs
        cons            -- as in r5rs
        car             -- as in r5rs
        cdr             -- as in r5rs
        set-car!        -- as in r5rs
        set-cdr!        -- as in r5rs

Lists:
        null?           -- as in r5rs

Vectors:
        vector          -- as in r5rs
        make-vector     -- binary, and otherwise as in r5rs
        vector?         -- as in r5rs
        vector-length   -- as in r5rs
        vector-ref      -- as in r5rs
        vector-set!     -- as in r5rs

Procedures:
        procedure?      -- as in r5rs
        apply           -- binary, and otherwise as in r5rs

Misc:
        eqv?            -- as in r5rs

Control:
        call/cc         -- as call-with-current-continuation in r5rs
        exit            -- unary, and expects an integer
                           that can be interpreted as an exit code in Unix:
                           stops DAIMI-Scheme

Input:
        open-input-file         -- as in r5rs
        input-port?             -- as in r5rs
        close-input-port        -- as in r5rs
        current-input-port      -- as in r5rs
        read-char               -- unary, and otherwise as in r5rs
        peek-char               -- unary, and otherwise as in r5rs

        eof-object?             -- as in r5rs

Output:
        open-output-file        -- as in r5rs
        output-port?            -- as in r5rs
        close-output-port       -- as in r5rs
        current-output-port     -- as in r5rs
        write-char              -- binary, and otherwise as in r5rs

-----------------------------------------------------------------------------

% end of 02DAIMI-Scheme-source.txt

