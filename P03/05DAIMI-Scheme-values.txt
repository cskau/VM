% 05DAIMI-Scheme-values.txt -*- text -*-
% dOvs'03

This file describes the values obtained by evaluating a DAIMI-Scheme
expression.

-----------------------------------------------------------------------------

datatype value = INTEGER of integer
               | BOOLEAN of boolean
               | CHARACTER of character
               | STRING of string
               | SYMBOL of string
               | NIL
               | VOID
               | UNINITIALIZED
               | END_OF_FILE
               | INPUT_PORT of TextIO.instream
               | OUTPUT_PORT of TextIO.outstream
               | PAIR of value ref * value ref
               | VECTOR of value Array.array
               | USER_DEFINED_FUNCTION of value list -> value
               | PREDEFINED_FUNCTION of value list -> value
               | CONTINUATION_FUNCTION of value -> value

NB. The choices of representations above (ie, value Array.array, value
list -> value, TextIO.instream, etc.) are implementation-dependent.

==========

At its core, the virtual-machine processor manipulates Scheme values.
These Scheme values are atomic or compound:

Atomic values:

    - integers
    
    - booleans
    
    - characters
    
    - strings
    
    - symbols
    
    - the empty list

    - void

    - the uninitialized value (!)

    - the end-of-file value

    - I/O ports

Compound values:

    - pairs

    - vectors

    - function closures

==========

These values are introduced (produced) and eliminated (consumed) as
follows:

----------

Integers:

- An integer value arises from evaluating a integer literal in the text
  of a DAIMI-Scheme program.

- An integer can be produced by some of the predefined procedures:
  +, -, *, quotient, remainder, char->integer, string-length, and
  vector-length.

- An integer can be consumed by either of the predefined procedures
  +, -, * quotient, remainder, <, <=, =, >=, >,
  integer->char, string-ref, make-vector, vector-ref, vector-set!, eqv?,
  and by any of the type predicates (integer?, boolean?, etc.).

  In addition, since in Scheme, everything that is not false is true,
  an integer can be consumed by a conditional expression.

  Any other way to consume an integer will yield an error.

----------

Booleans:

- A boolean value arises from evaluating a boolean literal (#t or #f) in
  the text of a DAIMI-Scheme program.

- A boolean can be consumed by any predicate, by eqv?, and by conditional
  expressions.

  Any other way to consume a boolean will yield an error.

----------

Characters:

- A character value arises from evaluating a character literal (eg, #\a
  or #\newline) in the text of a DAIMI-Scheme program.

- A character can be produced by some of the predefined procedures:
  integer->char, string-ref, read-char, and peek-char.

- A character can be consumed by either of the predefined procedures
  char->integer, string, make-string, write-char, eqv?, and by any of the
  type predicates (integer?, boolean?, etc.).

  In addition, since in Scheme, everything that is not false is true,
  a character can be consumed by a conditional expression.

  Any other way to consume a character will yield an error.

----------

Strings:

- A string value arises from evaluating a string literal (eg, "foo")
  in the text of a DAIMI-Scheme program.

- A string can be produced by some of the predefined procedures:
  string, make-string, string-append, and symbol->string.

- A string can be consumed by either of the predefined procedures
  string-length, string-append, string=?, string-ref, string->symbol,
  open-input-file, open-output-file, eqv?, and by any of the
  type predicates (integer?, boolean?, etc.).

  In addition, since in Scheme, everything that is not false is true,
  a string can be consumed by a conditional expression.

  Any other way to consume a string will yield an error.

----------

Symbols:

- A symbol value arises from evaluating a quotation (eg, 'foo)
  in the text of a DAIMI-Scheme program.

- A symbol can be produced by the predefined procedure string->symbol.

- A symbol can be consumed by the predefined procedure symbol->string,
  eqv?, and by any of the type predicates (integer?, boolean?, etc.).

  In addition, since in Scheme, everything that is not false is true,
  a symbol can be consumed by a conditional expression.

  Any other way to consume a symbol will yield an error.

----------

The empty list:

- The empty-list value arises from evaluating the empty-list literal
  (namely, '()) in the text of a DAIMI-Scheme program.

- The empty list can be produced by applying (lambda xs xs) to zero
  argument.

- The empty list can be consumed by any of the type predicates (integer?,
  boolean?, etc.).

  In addition, since in Scheme, everything that is not false is true,
  the empty list can be consumed by a conditional expression.

  Any other way to consume the empty list will yield an error.

----------

The void value:

- The void value can be produced as the result of evaluating a set!
  expression, or of applying one of the predefined procedures that
  perform side effects: set-car!, set-cdr!, vector-set!,
  close-input-port, close-output-port, and write-char.

- The void value can only be consumed in a conditional expression
  since in Scheme, everything that is not false is true.  So for
  example, evaluating 
    (if (set-car! p 10) 20 30)
  should yield 20.

  Any other way to consume the void value will yield an error.

----------

The unitialized value:

- The unitialized value is used as the initial value of global variables;
  it is an error to evaluate a global variable that denotes the
  unitialized value.

----------

The end-of-file value:

- The end-of-file value cannot occur in the text of a DAIMI-Scheme
  program.

- The end-of-file value (a.k.a. end-of-file object) arises from applying
  the predefined functions denoted by read-char or peek-char when trying
  to access beyond the end of an input file.

- The end-of-file value can be consumed by any of the type predicates
  (eg, eof-object?).

  In addition, since in Scheme, everything that is not false is true,
  the end-of-file object can be consumed by a conditional expression.

  Any other way to consume the end-of-file object will yield an error.

----------

I/O ports:

- Ports cannot occur in the text of a DAIMI-Scheme program.

- A port can be produced by the predefined procedures open-input-file
  (which yields an input-port value) and open-output-file (which yields
  an output-port value).

- A port can be consumed by the predefined procedure input-port?,
  close-input-port, read-char, peek-char, output-port?,
  close-output-port, write-char, newline, eqv?, and by any of the type
  predicates (integer?, boolean?, etc.).

  In addition, since in Scheme, everything that is not false is true,
  a port can be consumed by a conditional expression.

  Any other way to consume a port will yield an error.

----------

Pairs:

- A pair is constructed by the predefined procedure cons.

- A pair is modified by the predefined procedures set-car! and set-cdr!

- A pair is consumed by the predefined procedures car and cdr.

  In addition, since in Scheme, everything that is not false is true,
  a pair can be consumed by a conditional expression.

  Any other way to consume a pair will yield an error.

----------

Vectors:

- A vector is constructed by the predefined procedures vector and
  make-vector.

- A vector is modified by the predefined procedure vector-set!.

- A vector is consumed by the predefined procedures vector-length,
  vector-ref.

  In addition, since in Scheme, everything that is not false is true,
  a vector can be consumed by a conditional expression.

  Any other way to consume a vector will yield an error.

----------

Procedures (represented by closures):

There are essentially three kinds of closures: predefined closures,
function closures, and continuation closures.

- Predefined closures are built when the virtual machine is initialized.
  They implement the predefined procedures, and are available in the
  initial environment.  For example, +, car, and eof-object? denote such
  predefined functions.

  Function closures are built every time a lambda-abstraction is
  evaluated.

  Continuation closures are built by call/cc.

- A closure is consumed by an application and by the predefined procedures
  call/cc and apply.

  In addition, since in Scheme, everything that is not false is true,
  a closure can be consumed by a conditional expression.

  Any other way to consume a closure will yield an error.

-----------------------------------------------------------------------------

% end of 05DAIMI-Scheme-values.txt
